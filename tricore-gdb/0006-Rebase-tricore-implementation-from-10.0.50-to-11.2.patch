From 32f912d40cad16c87acb70d220769ecb02926a4e Mon Sep 17 00:00:00 2001
From: Domenico Iezzi <domenico.iezzi1@schindler.com>
Date: Wed, 26 Jan 2022 08:55:35 +0100
Subject: [PATCH] Rebase tricore implementation from 10.0.50 to 11.2

This commit aims at rebasing tricore architecture support found
at repository [1] onto the latest release tag 11.2. While the
origin of that repository is unknown, code seems to be contributed
by Hightec developers [2].

[1] https://github.com/Gigallith/gdb-tricore
[2] https://hightec-rt.com/en/

Signed-off-by: Domenico Iezzi <domenico.iezzi1@schindler.com>
---
 bfd/Makefile.am                      |     4 +
 bfd/Makefile.in                      |     4 +
 bfd/archures.c                       |    13 +
 bfd/bfd-in2.h                        |   103 +
 bfd/config.bfd                       |     5 +
 bfd/configure                        |     1 +
 bfd/configure.ac                     |     1 +
 bfd/cpu-tricore.c                    |   328 +
 bfd/elf32-tricore.c                  |  2115 ++++++
 bfd/libbfd.h                         |    78 +
 bfd/po/SRC-POTFILES.in               |     1 +
 bfd/reloc.c                          |   176 +
 bfd/targets.c                        |     3 +
 binutils/readelf.c                   |     5 +
 config.sub                           |     4 +
 gas/Makefile.am                      |     2 +
 gas/config/tc-tricore.c              | 10098 +++++++++++++++++++++++++
 gas/config/tc-tricore.h              |   151 +
 gas/configure.tgt                    |     5 +-
 gas/po/POTFILES.in                   |     2 +
 gdb/Makefile.in                      |     2 +
 gdb/configure.tgt                    |     5 +
 gdb/features/Makefile                |     5 +-
 gdb/features/tricore-core.xml        |    56 +
 gdb/features/tricore-fpu.xml         |    17 +
 gdb/features/tricore.c               |    65 +
 gdb/features/tricore.xml             |    13 +
 gdb/regformats/tricore.dat           |    58 +
 gdb/tricore-tdep.c                   |   738 ++
 gdb/tricore-tdep.h                   |    98 +
 include/elf/tricore.h                |   210 +
 include/opcode/tricore.h             |   459 ++
 ld/Makefile.in                       |     2 +
 ld/configure.tgt                     |     6 +
 ld/emulparams/elf32tricore.sh        |    26 +
 ld/emulparams/elf32tricoreel.sh      |     2 +
 ld/scripttempl/elftricore.sc         |   469 ++
 opcodes/Makefile.am                  |     2 +
 opcodes/Makefile.in                  |     4 +
 opcodes/configure                    |     1 +
 opcodes/configure.ac                 |     1 +
 opcodes/disassemble.c                |     6 +
 opcodes/disassemble.h                |     1 +
 opcodes/po/POTFILES.in               |     2 +
 opcodes/tricore-dis.c                |  1948 +++++
 opcodes/tricore-opc.c                |  2497 ++++++
 readline/readline/support/config.sub |     5 +
 47 files changed, 19795 insertions(+), 2 deletions(-)
 create mode 100644 bfd/cpu-tricore.c
 create mode 100644 bfd/elf32-tricore.c
 create mode 100644 gas/config/tc-tricore.c
 create mode 100644 gas/config/tc-tricore.h
 create mode 100644 gdb/features/tricore-core.xml
 create mode 100644 gdb/features/tricore-fpu.xml
 create mode 100644 gdb/features/tricore.c
 create mode 100644 gdb/features/tricore.xml
 create mode 100644 gdb/regformats/tricore.dat
 create mode 100644 gdb/tricore-tdep.c
 create mode 100644 gdb/tricore-tdep.h
 create mode 100644 include/elf/tricore.h
 create mode 100644 include/opcode/tricore.h
 create mode 100644 ld/emulparams/elf32tricore.sh
 create mode 100644 ld/emulparams/elf32tricoreel.sh
 create mode 100644 ld/scripttempl/elftricore.sc
 create mode 100644 opcodes/tricore-dis.c
 create mode 100644 opcodes/tricore-opc.c

diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index ed2f701805d..f9ed0122683 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -161,6 +161,7 @@ ALL_MACHINES = \
 	cpu-tic6x.lo \
 	cpu-tilegx.lo \
 	cpu-tilepro.lo \
+	cpu-tricore.lo \
 	cpu-v850.lo \
 	cpu-v850_rh850.lo \
 	cpu-vax.lo \
@@ -245,6 +246,7 @@ ALL_MACHINES_CFILES = \
 	cpu-tic6x.c \
 	cpu-tilegx.c \
 	cpu-tilepro.c \
+	cpu-tricore.c \
 	cpu-v850.c \
 	cpu-v850_rh850.c \
 	cpu-vax.c \
@@ -343,6 +345,7 @@ BFD32_BACKENDS = \
 	elf32-tic6x.lo \
 	elf32-tilegx.lo \
 	elf32-tilepro.lo \
+	elf32-tricore.lo \
 	elf32-v850.lo \
 	elf32-vax.lo \
 	elf32-visium.lo \
@@ -476,6 +479,7 @@ BFD32_BACKENDS_CFILES = \
 	elf32-tic6x.c \
 	elf32-tilegx.c \
 	elf32-tilepro.c \
+	elf32-tricore.c \
 	elf32-v850.c \
 	elf32-vax.c \
 	elf32-visium.c \
diff --git a/bfd/Makefile.in b/bfd/Makefile.in
index 12807d99760..899cdc9fcaa 100644
--- a/bfd/Makefile.in
+++ b/bfd/Makefile.in
@@ -586,6 +586,7 @@ ALL_MACHINES = \
 	cpu-tic6x.lo \
 	cpu-tilegx.lo \
 	cpu-tilepro.lo \
+	cpu-tricore.lo \
 	cpu-v850.lo \
 	cpu-v850_rh850.lo \
 	cpu-vax.lo \
@@ -670,6 +671,7 @@ ALL_MACHINES_CFILES = \
 	cpu-tic6x.c \
 	cpu-tilegx.c \
 	cpu-tilepro.c \
+	cpu-tricore.c \
 	cpu-v850.c \
 	cpu-v850_rh850.c \
 	cpu-vax.c \
@@ -769,6 +771,7 @@ BFD32_BACKENDS = \
 	elf32-tic6x.lo \
 	elf32-tilegx.lo \
 	elf32-tilepro.lo \
+	elf32-tricore.lo \
 	elf32-v850.lo \
 	elf32-vax.lo \
 	elf32-visium.lo \
@@ -902,6 +905,7 @@ BFD32_BACKENDS_CFILES = \
 	elf32-tic6x.c \
 	elf32-tilegx.c \
 	elf32-tilepro.c \
+	elf32-tricore.c \
 	elf32-v850.c \
 	elf32-vax.c \
 	elf32-visium.c \
diff --git a/bfd/archures.c b/bfd/archures.c
index 390691bfba1..36d61bd3877 100644
--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -528,6 +528,17 @@ DESCRIPTION
 .#define bfd_mach_tilepro	1
 .#define bfd_mach_tilegx	1
 .#define bfd_mach_tilegx32	2
+.  bfd_arch_tricore, {* Infineon TriCore.  *}
+.#define bfd_mach_tricore   0
+.#define bfd_mach_tricore_v1_1 0x1
+.#define bfd_mach_tricore_v1_2 0x2
+.#define bfd_mach_tricore_v1_3 0x4
+.#define bfd_mach_tricore_v1_3_1 0x100
+.#define bfd_mach_tricore_v1_6 0x200
+.#define bfd_mach_tricore_v1_6_1 0x400
+.#define bfd_mach_tricore_pcp 0x10
+.#define bfd_mach_tricore_pcp2 0x20
+.#define bfd_mach_tricore_mask 0xf0f
 .  bfd_arch_aarch64,   {* AArch64.  *}
 .#define bfd_mach_aarch64 0
 .#define bfd_mach_aarch64_8R	1
@@ -680,6 +691,7 @@ extern const bfd_arch_info_type bfd_tic54x_arch;
 extern const bfd_arch_info_type bfd_tic6x_arch;
 extern const bfd_arch_info_type bfd_tilegx_arch;
 extern const bfd_arch_info_type bfd_tilepro_arch;
+extern const bfd_arch_info_type bfd_tricore_arch;
 extern const bfd_arch_info_type bfd_v850_arch;
 extern const bfd_arch_info_type bfd_v850_rh850_arch;
 extern const bfd_arch_info_type bfd_vax_arch;
@@ -767,6 +779,7 @@ static const bfd_arch_info_type * const bfd_archures_list[] =
     &bfd_tic6x_arch,
     &bfd_tilegx_arch,
     &bfd_tilepro_arch,
+    &bfd_tricore_arch,
     &bfd_v850_arch,
     &bfd_v850_rh850_arch,
     &bfd_vax_arch,
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 57b3c453649..69f262e40bc 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -1905,6 +1905,17 @@ enum bfd_architecture
 #define bfd_mach_tilepro       1
 #define bfd_mach_tilegx        1
 #define bfd_mach_tilegx32      2
+  bfd_arch_tricore, /* Infineon TriCore.  */
+#define bfd_mach_tricore   0
+#define bfd_mach_tricore_v1_1 0x1
+#define bfd_mach_tricore_v1_2 0x2
+#define bfd_mach_tricore_v1_3 0x4
+#define bfd_mach_tricore_v1_3_1 0x100
+#define bfd_mach_tricore_v1_6 0x200
+#define bfd_mach_tricore_v1_6_1 0x400
+#define bfd_mach_tricore_pcp 0x10
+#define bfd_mach_tricore_pcp2 0x20
+#define bfd_mach_tricore_mask 0xf0f
   bfd_arch_aarch64,   /* AArch64.  */
 #define bfd_mach_aarch64 0
 #define bfd_mach_aarch64_8R    1
@@ -6145,6 +6156,98 @@ assembler and not (currently) written to any object files.  */
   BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD,
   BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD,
 
+/* These are relocation types defined in the TriCore ABI.  */
+  BFD_RELOC_TRICORE_NONE,
+  BFD_RELOC_TRICORE_32REL,
+  BFD_RELOC_TRICORE_32ABS,
+  BFD_RELOC_TRICORE_24REL,
+  BFD_RELOC_TRICORE_24ABS,
+  BFD_RELOC_TRICORE_16SM,
+  BFD_RELOC_TRICORE_HIADJ,
+  BFD_RELOC_TRICORE_LO,
+  BFD_RELOC_TRICORE_LO2,
+  BFD_RELOC_TRICORE_18ABS,
+  BFD_RELOC_TRICORE_10SM,
+  BFD_RELOC_TRICORE_15REL,
+
+/* These are relocation types defined for TriCore's PCP co-processor.  */
+  BFD_RELOC_TRICORE_PCPHI,
+  BFD_RELOC_TRICORE_PCPLO,
+  BFD_RELOC_TRICORE_PCPPAGE,
+  BFD_RELOC_TRICORE_PCPOFF,
+  BFD_RELOC_TRICORE_PCPTEXT,
+
+/* These are GNU extensions of TriCore relocations, which allow
+to relocate all non-register operands.  */
+  BFD_RELOC_TRICORE_HI,
+  BFD_RELOC_TRICORE_16CONST,
+  BFD_RELOC_TRICORE_9ZCONST,
+  BFD_RELOC_TRICORE_9SCONST,
+  BFD_RELOC_TRICORE_8REL,
+  BFD_RELOC_TRICORE_8CONST,
+  BFD_RELOC_TRICORE_10OFF,
+  BFD_RELOC_TRICORE_16OFF,
+  BFD_RELOC_TRICORE_8ABS,
+  BFD_RELOC_TRICORE_16ABS,
+  BFD_RELOC_TRICORE_1BIT,
+  BFD_RELOC_TRICORE_3POS,
+  BFD_RELOC_TRICORE_5POS,
+  BFD_RELOC_TRICORE_5POS2,
+  BFD_RELOC_TRICORE_BRCC,
+  BFD_RELOC_TRICORE_BRCZ,
+  BFD_RELOC_TRICORE_BRNN,
+  BFD_RELOC_TRICORE_RRN,
+  BFD_RELOC_TRICORE_4CONST,
+  BFD_RELOC_TRICORE_4REL,
+  BFD_RELOC_TRICORE_4REL2,
+  BFD_RELOC_TRICORE_5POS3,
+  BFD_RELOC_TRICORE_4OFF,
+  BFD_RELOC_TRICORE_4OFF2,
+  BFD_RELOC_TRICORE_4OFF4,
+  BFD_RELOC_TRICORE_42OFF,
+  BFD_RELOC_TRICORE_42OFF2,
+  BFD_RELOC_TRICORE_42OFF4,
+  BFD_RELOC_TRICORE_2OFF,
+  BFD_RELOC_TRICORE_8CONST2,
+  BFD_RELOC_TRICORE_4POS,
+  BFD_RELOC_TRICORE_16SM2,
+  BFD_RELOC_TRICORE_5REL,
+
+/* These are GNU extensions of TriCore relocations, which allow
+the linker to optimize virtual tables (C++).  */
+  BFD_RELOC_TRICORE_GNU_VTENTRY,
+  BFD_RELOC_TRICORE_GNU_VTINHERIT,
+
+/* These TriCore relocations add support for shared objects.  */
+  BFD_RELOC_TRICORE_PCREL16,
+  BFD_RELOC_TRICORE_PCREL8,
+  BFD_RELOC_TRICORE_GOT,
+  BFD_RELOC_TRICORE_GOT2,
+  BFD_RELOC_TRICORE_GOTHI,
+  BFD_RELOC_TRICORE_GOTLO,
+  BFD_RELOC_TRICORE_GOTLO2,
+  BFD_RELOC_TRICORE_GOTUP,
+  BFD_RELOC_TRICORE_GOTOFF,
+  BFD_RELOC_TRICORE_GOTOFF2,
+  BFD_RELOC_TRICORE_GOTOFFHI,
+  BFD_RELOC_TRICORE_GOTOFFLO,
+  BFD_RELOC_TRICORE_GOTOFFLO2,
+  BFD_RELOC_TRICORE_GOTOFFUP,
+  BFD_RELOC_TRICORE_GOTPC,
+  BFD_RELOC_TRICORE_GOTPC2,
+  BFD_RELOC_TRICORE_GOTPCHI,
+  BFD_RELOC_TRICORE_GOTPCLO,
+  BFD_RELOC_TRICORE_GOTPCLO2,
+  BFD_RELOC_TRICORE_GOTPCUP,
+  BFD_RELOC_TRICORE_PLT,
+  BFD_RELOC_TRICORE_COPY,
+  BFD_RELOC_TRICORE_GLOB_DAT,
+  BFD_RELOC_TRICORE_JMP_SLOT,
+  BFD_RELOC_TRICORE_RELATIVE,
+
+/* This supports allocating single bit objects.  */
+  BFD_RELOC_TRICORE_BITPOS,
+
 /* Linux eBPF relocations.  */
   BFD_RELOC_BPF_64,
   BFD_RELOC_BPF_32,
diff --git a/bfd/config.bfd b/bfd/config.bfd
index 30087e3b8f8..779d6116211 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -204,6 +204,7 @@ sparc*)		 targ_archs=bfd_sparc_arch ;;
 spu*)            targ_archs=bfd_spu_arch ;;
 tilegx*)	 targ_archs=bfd_tilegx_arch ;;
 tilepro*)	 targ_archs=bfd_tilepro_arch ;;
+tricore*)  targ_archs=bfd_tricore_arch ;;
 v850*)		 targ_archs="bfd_v850_arch bfd_v850_rh850_arch" ;;
 visium*)	 targ_archs=bfd_visium_arch ;;
 wasm32)		 targ_archs=bfd_wasm32_arch ;;
@@ -1341,6 +1342,10 @@ case "${targ}" in
     targ_defvec=tilepro_elf32_vec
     ;;
 
+  tricore-*-*)
+    targ_defvec=tricore_elf32_le_vec
+    ;;
+
   ft32*-*-*)
     targ_defvec=ft32_elf32_vec
     ;;
diff --git a/bfd/configure b/bfd/configure
index daa51244369..b9348658f74 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -13483,6 +13483,7 @@ do
     tilegx_elf64_be_vec)	 tb="$tb elf64-tilegx.lo elfxx-tilegx.lo elf64.lo $elf" ; target_size=64 ;;
     tilegx_elf64_le_vec)	 tb="$tb elf64-tilegx.lo elfxx-tilegx.lo elf64.lo $elf" ; target_size=64 ;;
     tilepro_elf32_vec)		 tb="$tb elf32-tilepro.lo elf32.lo $elf" ;;
+    tricore_elf32_le_vec)  tb="$tb elf32-tricore.lo elf32.lo $elf" ;;
     v800_elf32_vec)		 tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     v850_elf32_vec)		 tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     vax_aout_1knbsd_vec)	 tb="$tb vax1knetbsd.lo aout32.lo" ;;
diff --git a/bfd/configure.ac b/bfd/configure.ac
index 07a75ed1626..434cdcac281 100644
--- a/bfd/configure.ac
+++ b/bfd/configure.ac
@@ -673,6 +673,7 @@ do
     tilegx_elf64_be_vec)	 tb="$tb elf64-tilegx.lo elfxx-tilegx.lo elf64.lo $elf" ; target_size=64 ;;
     tilegx_elf64_le_vec)	 tb="$tb elf64-tilegx.lo elfxx-tilegx.lo elf64.lo $elf" ; target_size=64 ;;
     tilepro_elf32_vec)		 tb="$tb elf32-tilepro.lo elf32.lo $elf" ;;
+    tricore_elf32_le_vec)  tb="$tb elf32-tricore.lo elf32.lo $elf" ;;
     v800_elf32_vec)		 tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     v850_elf32_vec)		 tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     vax_aout_1knbsd_vec)	 tb="$tb vax1knetbsd.lo aout32.lo" ;;
diff --git a/bfd/cpu-tricore.c b/bfd/cpu-tricore.c
new file mode 100644
index 00000000000..fcd57c60a08
--- /dev/null
+++ b/bfd/cpu-tricore.c
@@ -0,0 +1,328 @@
+/* BFD support for Infineon's TriCore architecture.
+   Copyright (C) 1998-2003 Free Software Foundation, Inc.
+   Contributed by Michael Schumacher (mike@hightec-rt.com).
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf/tricore.h"
+#include "opcode/tricore.h"
+
+/* Opcode masks for TriCore's various instruction formats.  */
+
+unsigned long tricore_mask_abs;
+unsigned long tricore_mask_absb;
+unsigned long tricore_mask_b;
+unsigned long tricore_mask_bit;
+unsigned long tricore_mask_bo;
+unsigned long tricore_mask_bol;
+unsigned long tricore_mask_brc;
+unsigned long tricore_mask_brn;
+unsigned long tricore_mask_brr;
+unsigned long tricore_mask_rc;
+unsigned long tricore_mask_rcpw;
+unsigned long tricore_mask_rcr;
+unsigned long tricore_mask_rcrr;
+unsigned long tricore_mask_rcrw;
+unsigned long tricore_mask_rlc;
+unsigned long tricore_mask_rr;
+unsigned long tricore_mask_rr1;
+unsigned long tricore_mask_rr2;
+unsigned long tricore_mask_rrpw;
+unsigned long tricore_mask_rrr;
+unsigned long tricore_mask_rrr1;
+unsigned long tricore_mask_rrr2;
+unsigned long tricore_mask_rrrr;
+unsigned long tricore_mask_rrrw;
+unsigned long tricore_mask_sys;
+unsigned long tricore_mask_sb;
+unsigned long tricore_mask_sbc;
+unsigned long tricore_mask_sbr;
+unsigned long tricore_mask_sbrn;
+unsigned long tricore_mask_sc;
+unsigned long tricore_mask_slr;
+unsigned long tricore_mask_slro;
+unsigned long tricore_mask_sr;
+unsigned long tricore_mask_src;
+unsigned long tricore_mask_sro;
+unsigned long tricore_mask_srr;
+unsigned long tricore_mask_srrs;
+unsigned long tricore_mask_ssr;
+unsigned long tricore_mask_ssro;
+unsigned long tricore_opmask[TRICORE_FMT_MAX];
+
+void tricore_init_arch_vars (unsigned long);
+
+/* Describe the various flavours of the TriCore architecture.  */
+
+static const bfd_arch_info_type arch_info_struct[] =
+{
+  /* V1.1 ISA.  */
+  {
+    32,				/* 32 bits per word.  */
+    32,				/* 32 bits per address.  */
+    8,				/* 8 bits per byte.  */
+    bfd_arch_tricore,		/* Architecture type.  */
+    EF_EABI_TRICORE_V1_1,	/* Machine type.  */
+    "tricore",			/* Name of architecture (internal use).  */
+    "TriCore:V1.1",		/* Name of architecture to print.  */
+    3,				/* Align sections on 8 byte boundaries.  */
+    0,			/* No, this is ain't the default arch type.  */
+    bfd_default_compatible,	/* We're compatible with ourselves.  */
+    bfd_default_scan,		/* Let BFD find the default arch.  */
+    bfd_arch_default_fill, /* Default fill.  */
+    &arch_info_struct[1],	/* Next TriCore architecture.  */
+    0 /* Maximum offset of a reloc from the start of an insn.  */
+  },
+
+  /* V1.3 ISA.  */
+  {
+    32,				/* 32 bits per word.  */
+    32,				/* 32 bits per address.  */
+    8,				/* 8 bits per byte.  */
+    bfd_arch_tricore,		/* Architecture type.  */
+    EF_EABI_TRICORE_V1_3,	/* Machine type.  */
+    "tricore",			/* Name of architecture (internal use).  */
+    "TriCore:V1.3",		/* Name of architecture to print.  */
+    3,				/* Align sections on 8 byte boundaries.  */
+    0,			/* No, this is ain't the default arch type.  */
+    bfd_default_compatible,	/* We're compatible with ourselves.  */
+    bfd_default_scan,		/* Let BFD find the default arch.  */
+    bfd_arch_default_fill, /* Default fill.  */
+    &arch_info_struct[2],	/* Next TriCore architecture.  */
+    0 /* Maximum offset of a reloc from the start of an insn.  */
+  },
+
+  /* TC V1.3.1 ISA.  */
+  {
+    32,				/* 32 bits per word.  */
+    32,				/* 32 bits per address.  */
+    8,				/* 8 bits per byte.  */
+    bfd_arch_tricore,		/* Architecture type.  */
+    EF_EABI_TRICORE_V1_3_1,	/* Machine type.  */
+    "tricore",			/* Name of architecture (internal use).  */
+    "TriCore:V1.3.1",		/* Name of architecture to print.  */
+    3,				/* Align sections on 8 byte boundaries.  */
+    0,			/* No, this is ain't the default arch type.  */
+    bfd_default_compatible,	/* We're compatible with ourselves.  */
+    bfd_default_scan,		/* Let BFD find the default arch.  */
+    bfd_arch_default_fill, /* Default fill.  */
+    &arch_info_struct[3],	/* Next TriCore architecture.  */
+    0 /* Maximum offset of a reloc from the start of an insn.  */
+  },
+
+  /* TriCore V1_6 ISA.  */
+  {
+    32,				/* 32 bits per word.  */
+    32,				/* 32 bits per address.  */
+    8,				/* 8 bits per byte.  */
+    bfd_arch_tricore,		/* Architecture type.  */
+    EF_EABI_TRICORE_V1_6,		/* Machine type.  */
+    "tricore",			/* Name of architecture (internal use).  */
+    "TriCore:V1_6",		/* Name of architecture to print.  */
+    3,				/* Align sections on 8 byte boundaries.  */
+    0,			/* No, this is ain't the default arch type.  */
+    bfd_default_compatible,	/* We're compatible with ourselves.  */
+    bfd_default_scan,		/* Let BFD find the default arch.  */
+    bfd_arch_default_fill, /* Default fill.  */
+    &arch_info_struct[4],	/* Next TriCore architecture.  */
+    0 /* Maximum offset of a reloc from the start of an insn.  */
+  },
+
+  /* TriCore V1.6.1 ISA.  */
+  {
+    32,				/* 32 bits per word.  */
+    32,				/* 32 bits per address.  */
+    8,				/* 8 bits per byte.  */
+    bfd_arch_tricore,		/* Architecture type.  */
+    EF_EABI_TRICORE_V1_6_1,	/* Machine type.  */
+    "tricore",			/* Name of architecture (internal use).  */
+    "TriCore:V1_6_1",		/* Name of architecture to print.  */
+    3,				/* Align sections on 8 byte boundaries.  */
+    0,			/* No, this is ain't the default arch type.  */
+    bfd_default_compatible,	/* We're compatible with ourselves.  */
+    bfd_default_scan,		/* Let BFD find the default arch.  */
+    bfd_arch_default_fill, /* Default fill.  */
+    NULL,	/* No more arch types for TriCore.  */
+    0 /* Maximum offset of a reloc from the start of an insn.  */
+  }
+};
+
+const bfd_arch_info_type bfd_tricore_arch =
+{
+  /* V1.2 ISA.  */
+  32,				/* 32 bits per word.  */
+  32,				/* 32 bits per address.  */
+  8,				/* 8 bits per byte.  */
+  bfd_arch_tricore,		/* Architecture type.  */
+  EF_EABI_TRICORE_V1_2,		/* Machine type.  */
+  "tricore",			/* Name of architecture (internal use).  */
+  "TriCore:V1.2",		/* Name of architecture to print.  */
+  3,				/* Align sections on 8 byte boundaries.  */
+  1,				/* Yes, this is the default arch type.  */
+  bfd_default_compatible,	/* We're compatible with ourselves.  */
+  bfd_default_scan,		/* Let BFD find the default arch.  */
+  bfd_arch_default_fill,	/* Default fill.  */
+  &arch_info_struct[0],		/* Next arch type for TriCore.  */
+  0 /* Maximum offset of a reloc from the start of an insn.  */
+};
+
+/* Initialize the architecture-specific variables.  This must be called
+   by the assembler and disassembler prior to encoding/decoding any
+   TriCore instructions;  the linker (or more precisely, the specific
+   back-end, bfd/elf32-tricore.c:tricore_elf32_relocate_section) will
+   also have to call this if it ever accesses the variables below, but
+   it currently doesn't.  */
+
+void
+tricore_init_arch_vars (unsigned long mach)
+{
+  switch (mach & EF_EABI_TRICORE_CORE_MASK)
+    {
+    case EF_EABI_TRICORE_V1_1:
+      tricore_mask_abs =  0x0c0000ff;
+      tricore_mask_absb = 0x0c0000ff;
+      tricore_mask_b =    0x000000ff;
+      tricore_mask_bit =  0x006000ff;
+      tricore_mask_bo =   0x0fc000ff;
+      tricore_mask_bol =  0x000000ff;
+      tricore_mask_brc =  0x800000ff;
+      tricore_mask_brn =  0x8000007f;
+      tricore_mask_brr =  0x800000ff;
+      tricore_mask_rc =   0x0fe000ff;
+      tricore_mask_rcpw = 0x006000ff;
+      tricore_mask_rcr =  0x00e000ff;
+      tricore_mask_rcrr = 0x00e000ff;
+      tricore_mask_rcrw = 0x00e000ff;
+      tricore_mask_rlc =  0x000000ff;
+      tricore_mask_rr =   0x0ff000ff;
+      tricore_mask_rrpw = 0x006000ff;
+      tricore_mask_rrr =  0x00f000ff;
+      tricore_mask_rrr1 = 0x00fc00ff;
+      tricore_mask_rrr2 = 0x00ff00ff;
+      tricore_mask_rrrr = 0x00e000ff;
+      tricore_mask_rrrw = 0x00e000ff;
+      tricore_mask_sys =  0x07c000ff;
+      tricore_mask_sb =       0x00ff;
+      tricore_mask_sbc =      0x00ff;
+      tricore_mask_sbr =      0x00ff;
+      tricore_mask_sbrn =     0x007f;
+      tricore_mask_sc =       0x00ff;
+      tricore_mask_slr =      0x00ff;
+      tricore_mask_slro =     0x00ff;
+      tricore_mask_sr =       0xf0ff;
+      tricore_mask_src =      0x00ff;
+      tricore_mask_sro =      0x00ff;
+      tricore_mask_srr =      0x00ff;
+      tricore_mask_srrs =     0x003f;
+      tricore_mask_ssr =      0x00ff;
+      tricore_mask_ssro =     0x00ff;
+      break;
+
+    case EF_EABI_TRICORE_V1_2:
+    case EF_EABI_TRICORE_V1_3:
+    case EF_EABI_TRICORE_V1_3_1:
+    case EF_EABI_TRICORE_V1_6:
+    case EF_EABI_TRICORE_V1_6_1:
+      tricore_mask_abs =  0x0c0000ff;
+      tricore_mask_absb = 0x0c0000ff;
+      tricore_mask_b =    0x000000ff;
+      tricore_mask_bit =  0x006000ff;
+      tricore_mask_bo =   0x0fc000ff;
+      tricore_mask_bol =  0x000000ff;
+      tricore_mask_brc =  0x800000ff;
+      tricore_mask_brn =  0x8000007f;
+      tricore_mask_brr =  0x800000ff;
+      tricore_mask_rc =   0x0fe000ff;
+      tricore_mask_rcpw = 0x006000ff;
+      tricore_mask_rcr =  0x00e000ff;
+      tricore_mask_rcrr = 0x00e000ff;
+      tricore_mask_rcrw = 0x00e000ff;
+      tricore_mask_rlc =  0x000000ff;
+      tricore_mask_rr =   0x0ff300ff;
+      tricore_mask_rr1 =  0x0ffc00ff;
+      tricore_mask_rr2 =  0x0fff00ff;
+      tricore_mask_rrpw = 0x006000ff;
+      tricore_mask_rrr =  0x00f300ff;
+      tricore_mask_rrr1 = 0x00fc00ff;
+      tricore_mask_rrr2 = 0x00ff00ff;
+      tricore_mask_rrrr = 0x00e000ff;
+      tricore_mask_rrrw = 0x00e000ff;
+      tricore_mask_sys =  0x0fc000ff;
+      tricore_mask_sb =       0x00ff;
+      tricore_mask_sbc =      0x00ff;
+      tricore_mask_sbr =      0x00ff;
+      tricore_mask_sbrn =     0x00ff;
+      tricore_mask_sc =       0x00ff;
+      tricore_mask_slr =      0x00ff;
+      tricore_mask_slro =     0x00ff;
+      tricore_mask_sr =       0xf0ff;
+      tricore_mask_src =      0x00ff;
+      tricore_mask_sro =      0x00ff;
+      tricore_mask_srr =      0x00ff;
+      tricore_mask_srrs =     0x003f;
+      tricore_mask_ssr =      0x00ff;
+      tricore_mask_ssro =     0x00ff;
+      break;
+    }
+
+  /* Now fill in tricore_opmask[].  */
+
+  tricore_opmask[TRICORE_FMT_ABS] = tricore_mask_abs;
+  tricore_opmask[TRICORE_FMT_ABSB] = tricore_mask_absb;
+  tricore_opmask[TRICORE_FMT_B] = tricore_mask_b;
+  tricore_opmask[TRICORE_FMT_BIT] = tricore_mask_bit;
+  tricore_opmask[TRICORE_FMT_BO] = tricore_mask_bo;
+  tricore_opmask[TRICORE_FMT_BOL] = tricore_mask_bol;
+  tricore_opmask[TRICORE_FMT_BRC] = tricore_mask_brc;
+  tricore_opmask[TRICORE_FMT_BRN] = tricore_mask_brn;
+  tricore_opmask[TRICORE_FMT_BRR] = tricore_mask_brr;
+  tricore_opmask[TRICORE_FMT_RC] = tricore_mask_rc;
+  tricore_opmask[TRICORE_FMT_RCPW] = tricore_mask_rcpw;
+  tricore_opmask[TRICORE_FMT_RCR] = tricore_mask_rcr;
+  tricore_opmask[TRICORE_FMT_RCRR] = tricore_mask_rcrr;
+  tricore_opmask[TRICORE_FMT_RCRW] = tricore_mask_rcrw;
+  tricore_opmask[TRICORE_FMT_RLC] = tricore_mask_rlc;
+  tricore_opmask[TRICORE_FMT_RR] = tricore_mask_rr;
+  tricore_opmask[TRICORE_FMT_RR1] = tricore_mask_rr1;
+  tricore_opmask[TRICORE_FMT_RR2] = tricore_mask_rr2;
+  tricore_opmask[TRICORE_FMT_RRPW] = tricore_mask_rrpw;
+  tricore_opmask[TRICORE_FMT_RRR] = tricore_mask_rrr;
+  tricore_opmask[TRICORE_FMT_RRR1] = tricore_mask_rrr1;
+  tricore_opmask[TRICORE_FMT_RRR2] = tricore_mask_rrr2;
+  tricore_opmask[TRICORE_FMT_RRRR] = tricore_mask_rrrr;
+  tricore_opmask[TRICORE_FMT_RRRW] = tricore_mask_rrrw;
+  tricore_opmask[TRICORE_FMT_SYS] = tricore_mask_sys;
+  tricore_opmask[TRICORE_FMT_SB] = tricore_mask_sb;
+  tricore_opmask[TRICORE_FMT_SBC] = tricore_mask_sbc;
+  tricore_opmask[TRICORE_FMT_SBR] = tricore_mask_sbr;
+  tricore_opmask[TRICORE_FMT_SBRN] = tricore_mask_sbrn;
+  tricore_opmask[TRICORE_FMT_SC] = tricore_mask_sc;
+  tricore_opmask[TRICORE_FMT_SLR] = tricore_mask_slr;
+  tricore_opmask[TRICORE_FMT_SLRO] = tricore_mask_slro;
+  tricore_opmask[TRICORE_FMT_SR] = tricore_mask_sr;
+  tricore_opmask[TRICORE_FMT_SRC] = tricore_mask_src;
+  tricore_opmask[TRICORE_FMT_SRO] = tricore_mask_sro;
+  tricore_opmask[TRICORE_FMT_SRR] = tricore_mask_srr;
+  tricore_opmask[TRICORE_FMT_SRRS] = tricore_mask_srrs;
+  tricore_opmask[TRICORE_FMT_SSR] = tricore_mask_ssr;
+  tricore_opmask[TRICORE_FMT_SSRO] = tricore_mask_ssro;
+}
+
+/* End of cpu-tricore.c.  */
diff --git a/bfd/elf32-tricore.c b/bfd/elf32-tricore.c
new file mode 100644
index 00000000000..89673925390
--- /dev/null
+++ b/bfd/elf32-tricore.c
@@ -0,0 +1,2115 @@
+/* TriCore-specific support for 32-bit ELF.
+   Copyright (C) 1998-2003 Free Software Foundation, Inc.
+   Contributed by Michael Schumacher (mike@hightec-rt.com).
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "bfdlink.h"
+#include "genlink.h"
+#include "elf-bfd.h"
+#include "elf/tricore.h"
+#include <stdbool.h>
+
+/* The full name of the default instruction set architecture.  */
+
+#define DEFAULT_ISA "TriCore:V1.2"		/* Name of default architecture to print.  */
+
+/* The full name of the dynamic interpreter; put in the .interp section.  */
+
+#define ELF_DYNAMIC_INTERPRETER "/lib/ld-tricore.so.1"
+
+/* The number of reserved entries at the beginning of the PLT.  */
+
+#define PLT_RESERVED_SLOTS 2
+
+/* The size (in bytes) of a PLT entry.  */
+
+#define PLT_ENTRY_SIZE 12
+
+/* Section flag for PCP sections.  */
+
+#define PCP_SEG SEC_ARCH_BIT_0
+
+/* Section flags for dynamic relocation sections.  */
+
+#define RELGOTSECFLAGS	(SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS \
+			 | SEC_IN_MEMORY | SEC_LINKER_CREATED | SEC_READONLY)
+#define DYNOBJSECFLAGS  (SEC_HAS_CONTENTS | SEC_IN_MEMORY \
+			 | SEC_LINKER_CREATED | SEC_READONLY)
+
+/* Will references to this symbol always reference the symbol in this obj?  */
+
+/*
+#define SYMBOL_REFERENCES_LOCAL(INFO, H)				\
+  ((!INFO->shared							\
+    || INFO->symbolic							\
+    || (H->dynindx == -1)						\
+    || (ELF_ST_VISIBILITY (H->other) == STV_INTERNAL)			\
+    || (ELF_ST_VISIBILITY (H->other) == STV_HIDDEN))			\
+   && ((H->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0))
+*/
+/* Will _calls_ to this symbol always call the version in this object?  */
+/*
+#define SYMBOL_CALLS_LOCAL(INFO, H)					\
+  ((!INFO->shared							\
+    || INFO->symbolic							\
+    || (H->dynindx == -1)						\
+    || (ELF_ST_VISIBILITY (H->other) != STV_DEFAULT))			\
+   && ((H->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0))
+*/
+/* Describe "short addressable" memory areas (SDAs, Small Data Areas).  */
+
+typedef struct _sda_t
+{
+  /* Name of this SDA's short addressable data section.  */
+  const char *data_section_name;
+
+  /* Name of this SDA's short addressable BSS section.  */
+  const char *bss_section_name;
+
+  /* Name of the symbol that contains the base address of this SDA.  */
+  const char *sda_symbol_name;
+
+  /* Pointers to the BFD representations of the above data/BSS sections.  */
+  asection *data_section;
+  asection *bss_section;
+
+  /* The base address of this SDA; usually points to the middle of a 64k
+     memory area to provide full access via a 16-bit signed offset; this
+     can, however, be overridden by the user (via "--defsym" on the command
+     line, or in the linker script with an assignment statement such as
+     "_SMALL_DATA_ = ABSOLUTE (.);" in output section ".sbss" or ".sdata").  */
+  bfd_vma gp_value;
+
+  /* The number of the address register that contains the base address
+     of this SDA.  This is 0 for .sdata/.sbss (or 12 if this is a dynamic
+     executable, because in this case the SDA follows immediately after the
+     GOT, and both are accessed via the GOT pointer), 1 for .sdata2/.sbss2,
+     8 for .sdata3/.sbss3, and 9 for .sdata4/.sbss4.  */
+  int areg;
+
+  /* 1 if this SDA has been specified as an output section in the
+     linker script; it suffices if either the data or BSS section of
+     this SDA has been specified (e.g., just ".sbss2", but not ".sdata2"
+     for SDA1, or just ".sdata", but not ".sbss" for SDA0).  */
+  int valid;
+} sda_t;
+
+/* We allow up to four independent SDAs in executables.  For instance,
+   if you need 128k of initialized short addressable data, and 128k of
+   uninitialized short addressable data, you could specify .sdata, .sdata2,
+   .sbss3, and .sbss4 as output sections in your linker script.  Note,
+   however, that according to the EABI only the first SDA must be supported,
+   while support for the second SDA (called "literal section") is optional.
+   The other two SDAs are GNU extensions and can only be used in standalone
+   applications, or if an underlying OS doesn't use %a8 and %a9 for its own
+   purposes.  Also note that shared objects may only use the first SDA,
+   which will be addressed via the GOT pointer (%a12), so it can't exceed
+   32k, and may only use it for static variables.  That's because if a
+   program references a global variable defined in a shared object, the
+   linker reserves space for it in the program's ".dynbss" section and emits
+   a COPY reloc that will be resolved by the dynamic linker.  If, however,
+   the variable would be defined in the SDA of a SO, then this would lead
+   to different accesses to this variable, as the program expects it to live
+   in its ".dynbss" section, while the SO was compiled to access it in its
+   SDA -- clearly a situation that must be avoided.  */
+
+#define NR_SDAS 4
+
+sda_t small_data_areas[NR_SDAS] =
+{
+  { ".sdata",
+    ".sbss",
+    "_SMALL_DATA_",
+    (asection *) NULL,
+    (asection *) NULL,
+    0,
+    0,
+    0
+  },
+
+  { ".sdata2",
+    ".sbss2",
+    "_SMALL_DATA2_",
+    (asection *) NULL,
+    (asection *) NULL,
+    0,
+    1,
+    0
+  },
+
+  { ".sdata3",
+    ".sbss3",
+    "_SMALL_DATA3_",
+    (asection *) NULL,
+    (asection *) NULL,
+    0,
+    8,
+    0
+  },
+
+  { ".sdata4",
+    ".sbss4",
+    "_SMALL_DATA4_",
+    (asection *) NULL,
+    (asection *) NULL,
+    0,
+    9,
+    0
+  }
+};
+
+/* If the user requested an extended map file, we might need to keep a list
+   of global (and possibly static) symbols.  */
+
+typedef struct _symbol_t
+{
+  /* Name of symbol/variable.  */
+  const char *name;
+
+  /* Memory location of this variable, or value if it's an absolute symbol.  */
+  bfd_vma address;
+
+  /* Alignment of this variable (in output section).  */
+  int align;
+
+  /* Name of memory region this variable lives in.  */
+  char *region_name;
+
+  /* 1 if this is a bit variable.  */
+  int is_bit;
+
+  /* Bit position if this is a bit variable.  */
+  int bitpos;
+
+  /* 1 if this is a static variable.  */
+  int is_static;
+
+  /* Size of this variable.  */
+  bfd_vma size;
+
+  /* Pointer to the section in which this symbol is defined.  */
+  asection *section;
+
+  /* Name of module in which this symbol is defined.  */
+  const char *module_name;
+} symbol_t;
+
+/* Symbols to be listed are stored in a dynamically allocated array.  */
+
+// static symbol_t *symbol_list;
+// static int symbol_list_idx = -1;
+// static int symbol_list_max = 512;
+
+/* This describes memory regions defined by the user; must be kept in
+   sync with ld/emultempl/tricoreelf.em.  */
+
+typedef struct _memreg
+{
+  /* Name of region.  */
+  char *name;
+
+  /* Start of region.  */
+  bfd_vma start;
+
+  /* Length of region.  */
+  bfd_size_type length;
+
+  /* Number of allocated (used) bytes.  */
+  bfd_size_type used;
+} memreg_t;
+
+/* This array describes TriCore relocations.  */
+
+static reloc_howto_type tricore_elf32_howto_table[] =
+{
+      /* No relocation (ignored).  */
+  HOWTO (R_TRICORE_NONE,	/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_NONE",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* 32 bit PC-relative relocation.  */
+  HOWTO (R_TRICORE_32REL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 1,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_32REL",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 1),			/* pcrel_offset */
+
+  /* 32 bit absolute relocation.  */
+  HOWTO (R_TRICORE_32ABS,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_32ABS",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* relB 25 bit PC-relative relocation.  */
+  HOWTO (R_TRICORE_24REL,	/* type */
+	 1,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 25,			/* bitsize */
+	 1,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_TRICORE_24REL",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffff00,		/* dst_mask */
+	 1),			/* pcrel_offset */
+
+  /* absB 24 bit absolute address relocation.  */
+  HOWTO (R_TRICORE_24ABS,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_24ABS",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffff00,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* bolC 16 bit small data section relocation.  */
+  HOWTO (R_TRICORE_16SM,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_16SM",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff0000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* RLC High 16 bits of symbol value, adjusted.  */
+  HOWTO (R_TRICORE_HIADJ,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_HIADJ",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* RLC Low 16 bits of symbol value.  */
+  HOWTO (R_TRICORE_LO,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_LO",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* BOL Low 16 bits of symbol value.  */
+  HOWTO (R_TRICORE_LO2,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_LO2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff0000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* ABS 18 bit absolute address relocation.  */
+  HOWTO (R_TRICORE_18ABS,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 18,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_TRICORE_18ABS",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xf3fff000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* BO 10 bit relative small data relocation.  */
+  HOWTO (R_TRICORE_10SM,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 10,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_TRICORE_10SM",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xf03f0000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* BR 15 bit PC-relative relocation.  */
+  HOWTO (R_TRICORE_15REL,	/* type */
+	 1,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 1,			/* pc_relative */
+	 16,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_15REL",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x7fff0000,		/* dst_mask */
+	 1),			/* pcrel_offset */
+
+  /* RLC High 16 bits of symbol value.  */
+  HOWTO (R_TRICORE_HI,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_TRICORE_HI",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* rlcC 16 bit signed constant.  */
+  HOWTO (R_TRICORE_16CONST,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_16CONST",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* rcC2 9 bit unsigned constant.  */
+  HOWTO (R_TRICORE_9ZCONST,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_9ZCONST",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x001ff000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* RcC 9 bit signed constant.  */
+  HOWTO (R_TRICORE_9SCONST,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_9SCONST",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x001ff000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* sbD 9 bit PC-relative displacement.  */
+  HOWTO (R_TRICORE_8REL,	/* type */
+	 1,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,			/* bitsize */
+	 1,			/* pc_relative */
+	 8,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_8REL",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xff00,		/* dst_mask */
+	 1),			/* pcrel_offset */
+
+  /* scC 8 bit unsigned constant.  */
+  HOWTO (R_TRICORE_8CONST,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 0,			/* pc_relative */
+	 8,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_8CONST",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xff00,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* BO 10 bit data offset.  */
+  HOWTO (R_TRICORE_10OFF,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 10,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_10OFF",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xf03f0000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* bolC 16 bit data offset.  */
+  HOWTO (R_TRICORE_16OFF,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_16OFF",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff0000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* 8 bit absolute data relocation.  */
+  HOWTO (R_TRICORE_8ABS,	/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_TRICORE_8ABS",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xff,			/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* 16 bit absolute data relocation.  */
+  HOWTO (R_TRICORE_16ABS,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_16ABS",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* absBb 1 bit relocation.  */
+  HOWTO (R_TRICORE_1BIT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 1,			/* bitsize */
+	 0,			/* pc_relative */
+	 11,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_1BIT",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x00000800,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* absBp 3 bit bit position.  */
+  HOWTO (R_TRICORE_3POS,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 3,			/* bitsize */
+	 0,			/* pc_relative */
+	 8,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_3POS",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x00000700,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* bitP1 5 bit bit position.  */
+  HOWTO (R_TRICORE_5POS,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 0,			/* pc_relative */
+	 16,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_5POS",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x001f0000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* PCP HI relocation.  */
+  HOWTO (R_TRICORE_PCPHI,	/* type */
+	 1,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_PCPHI",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* PCP LO relocation.  */
+  HOWTO (R_TRICORE_PCPLO,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_PCPLO",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* PCP PAGE relocation.  */
+  HOWTO (R_TRICORE_PCPPAGE,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_PCPPAGE",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xff00,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* PCP OFF relocation.  */
+  HOWTO (R_TRICORE_PCPOFF,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_PCPOFF",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x003f,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* PCP TEXT relocation.  */
+  HOWTO (R_TRICORE_PCPTEXT,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_PCPTEXT",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* bitP2 5 bit bit position.  */
+  HOWTO (R_TRICORE_5POS2,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 0,			/* pc_relative */
+	 23,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_5POS2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0f800000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* brcC 4 bit signed offset.  */
+  HOWTO (R_TRICORE_BRCC,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 4,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_BRCC",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000f000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* brcC2 4 bit unsigned offset.  */
+  HOWTO (R_TRICORE_BRCZ,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 4,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_BRCZ",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000f000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* brnN 5 bit bit position.  */
+  HOWTO (R_TRICORE_BRNN,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_BRNN",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000f080,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* rrN 2 bit unsigned constant.  */
+  HOWTO (R_TRICORE_RRN,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 2,			/* bitsize */
+	 0,			/* pc_relative */
+	 16,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_RRN",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x00030000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* sbcC 4 bit signed constant.  */
+  HOWTO (R_TRICORE_4CONST,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 4,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_4CONST",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xf000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* sbcD/sbrD 5 bit PC-relative, zero-extended displacement.  */
+  HOWTO (R_TRICORE_4REL,	/* type */
+	 1,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 1,			/* pc_relative */
+	 8,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_4REL",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0f00,		/* dst_mask */
+	 1),			/* pcrel_offset */
+
+  /* sbrD 5 bit PC-relative, one-extended displacement.  */
+  HOWTO (R_TRICORE_4REL2,	/* type */
+	 1,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 1,			/* pc_relative */
+	 8,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_4REL2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0f00,		/* dst_mask */
+	 1),			/* pcrel_offset */
+
+  /* sbrN 5 bit bit position.  */
+  HOWTO (R_TRICORE_5POS3,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_5POS3",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xf080,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* slroO 4 bit zero-extended offset.  */
+  HOWTO (R_TRICORE_4OFF,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 4,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_4OFF",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xf000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* slroO2 5 bit zero-extended offset.  */
+  HOWTO (R_TRICORE_4OFF2,	/* type */
+	 1,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_4OFF2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xf000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* slroO4 6 bit zero-extended offset.  */
+  HOWTO (R_TRICORE_4OFF4,	/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 6,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_4OFF4",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xf000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* sroO 4 bit zero-extended offset.  */
+  HOWTO (R_TRICORE_42OFF,	/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 4,			/* bitsize */
+	 0,			/* pc_relative */
+	 8,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_42OFF",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0f00,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* sroO2 5 bit zero-extended offset.  */
+  HOWTO (R_TRICORE_42OFF2,	/* type */
+	 1,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 0,			/* pc_relative */
+	 8,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_42OFF2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0f00,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* slroO4 6 bit zero-extended offset.  */
+  HOWTO (R_TRICORE_42OFF4,	/* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 6,			/* bitsize */
+	 0,			/* pc_relative */
+	 8,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_42OFF4",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0f00,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* srrsN 2 bit zero-extended constant.  */
+  HOWTO (R_TRICORE_2OFF,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 2,			/* bitsize */
+	 0,			/* pc_relative */
+	 6,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_2OFF",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x00c0,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* scC 8 bit zero-extended offset.  */
+  HOWTO (R_TRICORE_8CONST2,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 0,			/* pc_relative */
+	 8,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_8CONST2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xff00,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* sbrnN 4 bit zero-extended constant.  */
+  HOWTO (R_TRICORE_4POS,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 4,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_4POS",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xf000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* rlcC 16 bit small data section relocation.  */
+  HOWTO (R_TRICORE_16SM2,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_16SM2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* sbcD/sbrD 6 bit PC-relative, zero-extended displacement.  */
+  HOWTO (R_TRICORE_5REL,	/* type */
+	 1,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 5,			/* bitsize */
+	 1,			/* pc_relative */
+	 8,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_5REL",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0f00,		/* dst_mask */
+	 1),			/* pcrel_offset */
+
+  /* Special reloc for optimizing virtual tables.  */
+  HOWTO (R_TRICORE_GNU_VTENTRY,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GNU_VTENTRY",/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* Special reloc for optimizing virtual tables.  */
+  HOWTO (R_TRICORE_GNU_VTINHERIT,/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GNU_VTINHERIT",/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 0),  		/* pcrel_offset */
+
+  /* 16 bit PC-relative relocation.  */
+  HOWTO (R_TRICORE_PCREL16,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 1,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_PCREL16",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 1),			/* pcrel_offset */
+
+  /* 8 bit PC-relative relocation.  */
+  HOWTO (R_TRICORE_PCREL8,	/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 1,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_PCREL8",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xff,			/* dst_mask */
+	 1),			/* pcrel_offset */
+
+  /* rlcC 16 bit GOT symbol entry.  */
+  HOWTO (R_TRICORE_GOT,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOT",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* bolC 16 bit GOT symbol entry.  */
+  HOWTO (R_TRICORE_GOT2,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOT2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff0000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* rlcC 16 bit GOTHI symbol entry.  */
+  HOWTO (R_TRICORE_GOTHI,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTHI",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* rlcC 16 bit GOTLO symbol entry.  */
+  HOWTO (R_TRICORE_GOTLO,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTLO",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* bolC 16 bit GOTLO symbol entry.  */
+  HOWTO (R_TRICORE_GOTLO2,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTLO2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff0000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* rlcC 16 bit GOTUP symbol entry.  */
+  HOWTO (R_TRICORE_GOTUP,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTUP",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* rlcC 16 bit GOTOFF symbol entry.  */
+  HOWTO (R_TRICORE_GOTOFF,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTOFF",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* bolC 16 bit GOTOFF symbol entry.  */
+  HOWTO (R_TRICORE_GOTOFF2,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTOFF2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff0000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* rlcC 16 bit GOTOFFHI symbol entry.  */
+  HOWTO (R_TRICORE_GOTOFFHI,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTOFFHI",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* rlcC 16 bit GOTOFFLO symbol entry.  */
+  HOWTO (R_TRICORE_GOTOFFLO,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTOFFLO",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* bolC 16 bit GOTOFFLO symbol entry.  */
+  HOWTO (R_TRICORE_GOTOFFLO2,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTOFFLO2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff0000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* rlcC 16 bit GOTOFFUP symbol entry.  */
+  HOWTO (R_TRICORE_GOTOFFUP,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTOFFUP",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* rlcC 16 bit GOTPC symbol entry.  */
+  HOWTO (R_TRICORE_GOTPC,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTPC",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* bolC 16 bit GOTPC symbol entry.  */
+  HOWTO (R_TRICORE_GOTPC2,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTPC2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff0000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* rlcC 16 bit GOTPCHI symbol entry.  */
+  HOWTO (R_TRICORE_GOTPCHI,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTPCHI",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* rlcC 16 bit GOTPCLO symbol entry.  */
+  HOWTO (R_TRICORE_GOTPCLO,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTPCLO",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* bolC 16 bit GOTPCLO symbol entry.  */
+  HOWTO (R_TRICORE_GOTPCLO2,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTPCLO2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff0000,		/* dst_mask */
+	 0),		/* pcrel_offset */
+
+  /* rlcC 16 bit GOTPCUP symbol entry.  */
+  HOWTO (R_TRICORE_GOTPCUP,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GOTPCUP",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0ffff000,		/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* relB PLT entry.  */
+  HOWTO (R_TRICORE_PLT,		/* type */
+	 1,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 25,			/* bitsize */
+	 1,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_TRICORE_PLT",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffff00,		/* dst_mask */
+	 1),			/* pcrel_offset */
+
+  /* COPY.  */
+  HOWTO (R_TRICORE_COPY,	/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_COPY",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 1), 		/* pcrel_offset */
+
+  /* GLOB_DAT.  */
+  HOWTO (R_TRICORE_GLOB_DAT,	/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_GLOB_DAT",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 1), 		/* pcrel_offset */
+
+  /* JMP_SLOT.  */
+  HOWTO (R_TRICORE_JMP_SLOT,	/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_JMP_SLOT",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 1), 		/* pcrel_offset */
+
+  /* RELATIVE.  */
+  HOWTO (R_TRICORE_RELATIVE,	/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_RELATIVE",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 1),	 		/* pcrel_offset */
+
+  /* BITPOS.  */
+  HOWTO (R_TRICORE_BITPOS,	/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 0,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_BITPOS",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 0)	 		/* pcrel_offset */
+#if 0
+// TO BE REVIEW
+    ,
+  /* SMALL DATA Baseregister operand 2.  */
+  HOWTO (R_TRICORE_SBREG_S2,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 4,			/* bitsize */
+	 0,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_SBREG_S2",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xf000,	/* dst_mask */
+	 0), 		/* pcrel_offset */
+
+  /* SMALL DATA Baseregister operand 1.  */
+  HOWTO (R_TRICORE_SBREG_S1,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 4,			/* bitsize */
+	 0,			/* pc_relative */
+	 8,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_SBREG_S1",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0f00,	/* dst_mask */
+	 0),	 		/* pcrel_offset */
+
+  /* SMALL DATA Baseregister destination.  */
+  HOWTO (R_TRICORE_SBREG_D,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 4,			/* bitsize */
+	 0,			/* pc_relative */
+	 28,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_TRICORE_SBREG_D",	/* name */
+	 0,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xf0000000,/* dst_mask */
+	 0)	 		/* pcrel_offset */
+#endif
+};
+
+
+/* Describe the mapping between BFD and TriCore relocs.  */
+
+struct elf_reloc_map {
+  bfd_reloc_code_real_type bfd_reloc_val;
+  enum elf_tricore_reloc_type tricore_val;
+};
+
+static const struct elf_reloc_map tricore_reloc_map[] =
+{
+  {BFD_RELOC_NONE,              R_TRICORE_NONE},
+  {BFD_RELOC_TRICORE_32REL,     R_TRICORE_32REL},
+  {BFD_RELOC_TRICORE_32ABS,     R_TRICORE_32ABS},
+  {BFD_RELOC_TRICORE_24REL,     R_TRICORE_24REL},
+  {BFD_RELOC_TRICORE_24ABS,     R_TRICORE_24ABS},
+  {BFD_RELOC_TRICORE_16SM,      R_TRICORE_16SM},
+  {BFD_RELOC_TRICORE_HIADJ,     R_TRICORE_HIADJ},
+  {BFD_RELOC_TRICORE_LO,        R_TRICORE_LO},
+  {BFD_RELOC_TRICORE_LO2,       R_TRICORE_LO2},
+  {BFD_RELOC_TRICORE_18ABS,     R_TRICORE_18ABS},
+  {BFD_RELOC_TRICORE_10SM,      R_TRICORE_10SM},
+  {BFD_RELOC_TRICORE_15REL,     R_TRICORE_15REL},
+  {BFD_RELOC_TRICORE_HI,        R_TRICORE_HI},
+  {BFD_RELOC_TRICORE_16CONST,   R_TRICORE_16CONST},
+  {BFD_RELOC_TRICORE_9ZCONST,   R_TRICORE_9ZCONST},
+  {BFD_RELOC_TRICORE_9SCONST,   R_TRICORE_9SCONST},
+  {BFD_RELOC_TRICORE_8REL,      R_TRICORE_8REL},
+  {BFD_RELOC_TRICORE_8CONST,    R_TRICORE_8CONST},
+  {BFD_RELOC_TRICORE_10OFF,     R_TRICORE_10OFF},
+  {BFD_RELOC_TRICORE_16OFF,     R_TRICORE_16OFF},
+  {BFD_RELOC_TRICORE_8ABS,      R_TRICORE_8ABS},
+  {BFD_RELOC_TRICORE_16ABS,     R_TRICORE_16ABS},
+  {BFD_RELOC_TRICORE_1BIT,      R_TRICORE_1BIT},
+  {BFD_RELOC_TRICORE_3POS,      R_TRICORE_3POS},
+  {BFD_RELOC_TRICORE_5POS,      R_TRICORE_5POS},
+  {BFD_RELOC_TRICORE_PCPHI,     R_TRICORE_PCPHI},
+  {BFD_RELOC_TRICORE_PCPLO,     R_TRICORE_PCPLO},
+  {BFD_RELOC_TRICORE_PCPPAGE,   R_TRICORE_PCPPAGE},
+  {BFD_RELOC_TRICORE_PCPOFF,    R_TRICORE_PCPOFF},
+  {BFD_RELOC_TRICORE_PCPTEXT,   R_TRICORE_PCPTEXT},
+  {BFD_RELOC_TRICORE_5POS2,     R_TRICORE_5POS2},
+  {BFD_RELOC_TRICORE_BRCC,      R_TRICORE_BRCC},
+  {BFD_RELOC_TRICORE_BRCZ,      R_TRICORE_BRCZ},
+  {BFD_RELOC_TRICORE_BRNN,      R_TRICORE_BRNN},
+  {BFD_RELOC_TRICORE_RRN,       R_TRICORE_RRN},
+  {BFD_RELOC_TRICORE_4CONST,    R_TRICORE_4CONST},
+  {BFD_RELOC_TRICORE_4REL,      R_TRICORE_4REL},
+  {BFD_RELOC_TRICORE_4REL2,     R_TRICORE_4REL2},
+  {BFD_RELOC_TRICORE_5POS3,     R_TRICORE_5POS3},
+  {BFD_RELOC_TRICORE_4OFF,      R_TRICORE_4OFF},
+  {BFD_RELOC_TRICORE_4OFF2,     R_TRICORE_4OFF2},
+  {BFD_RELOC_TRICORE_4OFF4,     R_TRICORE_4OFF4},
+  {BFD_RELOC_TRICORE_42OFF,     R_TRICORE_42OFF},
+  {BFD_RELOC_TRICORE_42OFF2,    R_TRICORE_42OFF2},
+  {BFD_RELOC_TRICORE_42OFF4,    R_TRICORE_42OFF4},
+  {BFD_RELOC_TRICORE_2OFF,      R_TRICORE_2OFF},
+  {BFD_RELOC_TRICORE_8CONST2,   R_TRICORE_8CONST2},
+  {BFD_RELOC_TRICORE_4POS,      R_TRICORE_4POS},
+  {BFD_RELOC_TRICORE_16SM2,     R_TRICORE_16SM2},
+  {BFD_RELOC_TRICORE_5REL,      R_TRICORE_5REL},
+  {BFD_RELOC_VTABLE_ENTRY,      R_TRICORE_GNU_VTENTRY},
+  {BFD_RELOC_VTABLE_INHERIT,    R_TRICORE_GNU_VTINHERIT},
+  {BFD_RELOC_TRICORE_PCREL16,	R_TRICORE_PCREL16},
+  {BFD_RELOC_TRICORE_PCREL8,	R_TRICORE_PCREL8},
+  {BFD_RELOC_TRICORE_GOT,       R_TRICORE_GOT},
+  {BFD_RELOC_TRICORE_GOT2,      R_TRICORE_GOT2},
+  {BFD_RELOC_TRICORE_GOTHI,     R_TRICORE_GOTHI},
+  {BFD_RELOC_TRICORE_GOTLO,     R_TRICORE_GOTLO},
+  {BFD_RELOC_TRICORE_GOTLO2,    R_TRICORE_GOTLO2},
+  {BFD_RELOC_TRICORE_GOTUP,     R_TRICORE_GOTUP},
+  {BFD_RELOC_TRICORE_GOTOFF,    R_TRICORE_GOTOFF},
+  {BFD_RELOC_TRICORE_GOTOFF2,   R_TRICORE_GOTOFF2},
+  {BFD_RELOC_TRICORE_GOTOFFHI,  R_TRICORE_GOTOFFHI},
+  {BFD_RELOC_TRICORE_GOTOFFLO,  R_TRICORE_GOTOFFLO},
+  {BFD_RELOC_TRICORE_GOTOFFLO2, R_TRICORE_GOTOFFLO2},
+  {BFD_RELOC_TRICORE_GOTOFFUP,  R_TRICORE_GOTOFFUP},
+  {BFD_RELOC_TRICORE_GOTPC,     R_TRICORE_GOTPC},
+  {BFD_RELOC_TRICORE_GOTPC2,    R_TRICORE_GOTPC2},
+  {BFD_RELOC_TRICORE_GOTPCHI,   R_TRICORE_GOTPCHI},
+  {BFD_RELOC_TRICORE_GOTPCLO,   R_TRICORE_GOTPCLO},
+  {BFD_RELOC_TRICORE_GOTPCLO2,  R_TRICORE_GOTPCLO2},
+  {BFD_RELOC_TRICORE_GOTPCUP,   R_TRICORE_GOTPCUP},
+  {BFD_RELOC_TRICORE_PLT,       R_TRICORE_PLT},
+  {BFD_RELOC_TRICORE_COPY,      R_TRICORE_COPY},
+  {BFD_RELOC_TRICORE_GLOB_DAT,  R_TRICORE_GLOB_DAT},
+  {BFD_RELOC_TRICORE_JMP_SLOT,  R_TRICORE_JMP_SLOT},
+  {BFD_RELOC_TRICORE_RELATIVE,  R_TRICORE_RELATIVE},
+  {BFD_RELOC_TRICORE_BITPOS,    R_TRICORE_BITPOS},
+#if 0
+// TO BE REVIEW
+  {BFD_RELOC_TRICORE_SBREG_S2, R_TRICORE_SBREG_S2},
+  {BFD_RELOC_TRICORE_SBREG_S1, R_TRICORE_SBREG_S1},
+  {BFD_RELOC_TRICORE_SBREG_D,  R_TRICORE_SBREG_D}
+#endif
+};
+
+static unsigned int nr_maps = sizeof tricore_reloc_map / sizeof tricore_reloc_map[0];
+
+/* 1 if we should compress bit objects during the relaxation pass.  */
+
+int tricore_elf32_relax_bdata = 0;
+
+/* 1 if we should relax call and jump instructions whose target
+   addresses are out of reach.  */
+
+int tricore_elf32_relax_24rel = 0;
+
+/* 1 if we should output diagnostic messages when relaxing sections.  */
+
+int tricore_elf32_debug_relax = 0;
+
+/* If the linker was invoked with -M or -Map, we save the pointer to
+   the map file in this variable; used to list allocated bit objects
+   and other fancy extensions.  */
+
+FILE *tricore_elf32_map_file = (FILE *) NULL;
+
+/* If the linker was invoked with --extmap in addition to -M/-Map, we
+   also save the filename of the map file (NULL means stdout).  */
+
+char *tricore_elf32_map_filename = (char *) NULL;
+
+/* 1 if an extended map file should be produced.  */
+
+int tricore_elf32_extmap_enabled = 0;
+
+/* 1 if the map file should include the version of the linker, the
+   date of the link run, and the name of the map file.  */
+
+int tricore_elf32_extmap_header = 0;
+
+/* 1 if the map file should contain an augmented memory segment map.  */
+
+int tricore_elf32_extmap_memory_segments = 0;
+
+/* 1 if global symbols should be listed in the map file, 2 if all symbols
+   should be listed; symbols are sorted by name.  */
+
+int tricore_elf32_extmap_syms_by_name = 0;
+
+/* 1 if global symbols should be listed in the map file, 2 if all symbols
+   should be listed; symbols are sorted by address.  */
+
+int tricore_elf32_extmap_syms_by_addr = 0;
+
+/* Name of the linker; only valid if tricore_elf32_extmap_enabled.  */
+
+char *tricore_elf32_extmap_ld_name = (char *) NULL;
+
+/* Pointer to a function that prints the linker version to a file;
+   only valid if tricore_elf32_extmap_enabled.  */
+
+void (*tricore_elf32_extmap_ld_version) (FILE *);
+
+/* Pointer to a function that returns a list of defined memory regions;
+   only valid if tricore_elf32_extmap_enabled.  */
+
+memreg_t *(*tricore_elf32_extmap_get_memregs) (int *) = NULL;
+
+/* If >= 0, describes the address mapping scheme for PCP sections.  */
+
+int tricore_elf32_pcpmap = -1;
+
+/* 1 if PCP address mappings should be printed (for debugging only).  */
+
+int tricore_elf32_debug_pcpmap = 0;
+
+/* 1 if small data accesses should be checked for non-small accesses.  */
+
+int tricore_elf32_check_sdata = 0;
+
+/* the core architecture of the executable set in the eflags of the ELF header*/
+unsigned long tricore_core_arch = EF_EABI_TRICORE_V1_2;
+
+/* Forward declarations.  */
+
+static reloc_howto_type *tricore_elf32_reloc_type_lookup
+      (bfd *, bfd_reloc_code_real_type);
+
+static reloc_howto_type *tricore_elf_reloc_name_lookup
+      (bfd *, const char *);
+
+static int tricore_elf32_info_to_howto
+      (bfd *, arelent *, Elf_Internal_Rela *);
+
+// static void tricore_elf32_final_sda_bases
+//  (bfd *, struct bfd_link_info *);
+
+// static bfd_reloc_status_type tricore_elf32_final_sda_base
+//      (asection *, bfd_vma *, int *);
+
+static int tricore_elf32_merge_private_bfd_data (bfd *, struct bfd_link_info *);
+
+static int tricore_elf32_copy_private_bfd_data (bfd *, bfd *);
+
+const bfd_target *tricore_elf32_object_p (bfd *);
+
+// static int tricore_elf32_fake_sections
+//      (bfd *, Elf_Internal_Shdr *, asection *);
+
+// static int tricore_elf32_section_flags
+//      (flagword *, Elf_Internal_Shdr *);
+
+// static int tricore_elf32_final_gp
+//      (bfd *, struct bfd_link_info *);
+
+// static void tricore_elf32_set_arch_mach
+//      (bfd *, enum bfd_architecture);
+
+// static int tricore_elf32_size_dynamic_sections
+//      (bfd *, struct bfd_link_info *);
+
+// static int tricore_elf32_adjust_dynamic_symbol
+//      (struct bfd_link_info *, struct elf_link_hash_entry *);
+
+
+// static unsigned long tricore_elf32_get_bitpos
+//      (bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
+//              Elf_Internal_Shdr *, Elf_Internal_Sym *,
+//              struct elf_link_hash_entry **, asection *, int *);
+
+// static int tricore_elf32_adjust_bit_relocs
+//      (bfd *, struct bfd_link_info *, unsigned long,
+//              bfd_vma, bfd_vma, int, unsigned int);
+
+
+// static void tricore_elf32_list_bit_objects (struct bfd_link_info *);
+
+// static symbol_t *tricore_elf32_new_symentry (void);
+
+// static void tricore_elf32_do_extmap (struct bfd_link_info *);
+
+// static int tricore_elf32_extmap_sort_addr (const void *, const void *);
+
+// static int tricore_elf32_extmap_sort_name (const void *, const void *);
+
+// static int tricore_elf32_extmap_sort_memregs
+//      (const void *, const void *);
+
+// static int tricore_elf32_extmap_add_sym
+//      (struct bfd_link_hash_entry *, PTR);
+
+// static int tricore_elf32_finish_dynamic_symbol
+//      (bfd *, struct bfd_link_info *,
+//              struct elf_link_hash_entry *, Elf_Internal_Sym *sym);
+
+// static int tricore_elf32_finish_dynamic_sections
+//      (bfd *, struct bfd_link_info *);
+
+// static enum elf_reloc_type_class tricore_elf32_reloc_type_class
+//      (const Elf_Internal_Rela *);
+
+// static asection *tricore_elf32_gc_mark_hook
+//      (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
+//              struct elf_link_hash_entry *, Elf_Internal_Sym *);
+
+// static int tricore_elf32_gc_sweep_hook
+//      (bfd *, struct bfd_link_info *, asection *,
+//              const Elf_Internal_Rela *);
+
+
+/* Given a BFD reloc type CODE, return the corresponding howto structure.  */
+
+static reloc_howto_type *
+tricore_elf32_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+                                 bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+
+  if (code == BFD_RELOC_8)
+    code = BFD_RELOC_TRICORE_8ABS;
+  else if (code == BFD_RELOC_16)
+    code = BFD_RELOC_TRICORE_16ABS;
+  else if (code == BFD_RELOC_32)
+    code = BFD_RELOC_TRICORE_32ABS;
+  else if (code == BFD_RELOC_32_PCREL)
+    code = BFD_RELOC_TRICORE_32REL;
+  else if (code == BFD_RELOC_16_PCREL)
+    code = BFD_RELOC_TRICORE_PCREL16;
+  else if (code == BFD_RELOC_8_PCREL)
+    code = BFD_RELOC_TRICORE_PCREL8;
+
+  for (i = 0; i < nr_maps; ++i)
+    if (tricore_reloc_map[i].bfd_reloc_val == code)
+      return &tricore_elf32_howto_table[(tricore_reloc_map[i].tricore_val)];
+
+  bfd_set_error (bfd_error_bad_value);
+  return (reloc_howto_type *) 0;
+}
+
+/* Given a BFD reloc name, return the corresponding howto structure.  */
+
+static reloc_howto_type *
+tricore_elf_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+				  const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0; i < nr_maps; i++)
+    if (tricore_elf32_howto_table[i].name != NULL
+	&& strcasecmp (tricore_elf32_howto_table[i].name, r_name) == 0)
+      return &tricore_elf32_howto_table[i];
+
+  return NULL;
+}
+
+/* Set CACHE_PTR->howto to the howto entry for the relocation DST.  */
+
+static int
+tricore_elf32_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
+                             arelent *cache_ptr,
+                             Elf_Internal_Rela *dst)
+{
+	unsigned int r_type;
+
+	r_type = ELF32_R_TYPE (dst->r_info);
+	if (r_type >= R_TRICORE_max)
+		{
+		/* xgettext:c-format */
+		_bfd_error_handler (_("%pB: unsupported relocation type %#x"),
+				abfd, r_type);
+		bfd_set_error (bfd_error_bad_value);
+		return 0;
+		}
+	
+	cache_ptr->howto = &tricore_elf32_howto_table[r_type];
+
+	return 1;
+}
+
+
+#if 0
+/* This is called once from tricore_elf32_relocate_section, before any
+   relocation has been performed.  We need to determine the final offset
+   for the GOT pointer, which is currently zero, meaning that the symbol
+   "_GLOBAL_OFFSET_TABLE_" will point to the beginning of the ".got"
+   section.  There are, however, two cases in which this is undesirable:
+
+      1. If the GOT contains more than 8192 entries, single TriCore
+	 instructions can't address the excessive entries with their
+	 16-bit signed offset.  Of course, that's only a problem
+	 when there are modules compiled with "-fpic".
+
+      2. In a shared object, the GOT pointer is also used to address
+         variables in SDA0, so the combined size of the ".got", ".sbss"
+	 and ".sdata" sections must not exceed 32k (well, of course the
+	 combined size of these sections can be 64k, but not if the
+	 GOT pointer offset is zero).
+
+   To address these problems, we use the following algorithm to determine
+   the final GOT offset:
+
+      1. If the combined size of the ".got", ".sbss" and ".sdata"
+	 sections is <= 32k, we'll keep the zero offset.
+
+      2. If the GOT contains more than 8192 entries, we'll
+	 set the offset to 0x8000, unless doing that would
+	 render any SDA entries unaccessible.
+
+      3. In all other cases, we'll set the offset to the size
+	 of the ".got" section minus 4 (because of the _DYNAMIC
+	 entry at _GLOBAL_OFFSET_TABLE_[0]).
+
+   In any case, if either ".sdata" or ".sbss" is non-empty, we're adjusting
+   the symbol "_SMALL_DATA_" to have the same value as "_GLOBAL_OFFSET_TABLE_",
+   as both the GOT and the SDA are addressed via the same register (%a12).
+   Note that the algorithm described above won't guarantee that all GOT
+   and SDA entries are reachable using a 16-bit offset -- it's just
+   increasing the probability for this to happen.  */
+
+static boolean
+tricore_elf32_final_gp (bfd *output_bfd, struct bfd_link_info *info)
+{
+  asection *sgot;
+
+  sgot = bfd_get_section_by_name (output_bfd, ".got");
+  if (sgot && (sgot->_raw_size > 0))
+    {
+      struct elf_link_hash_entry *h;
+      bfd_vma gp, sda;
+      asection *sdata = NULL, *sbss = NULL;
+      long got_size = sgot->_raw_size, sda_size = 0;
+      long gp_offset;
+
+      if (info->shared)
+        {
+	  sdata = bfd_get_section_by_name (output_bfd, ".sdata");
+          sbss = bfd_get_section_by_name (output_bfd, ".sbss");
+          if (sdata != NULL)
+            {
+              if (sdata->_cooked_size != 0)
+	        sda_size += sdata->_cooked_size;
+	      else
+	        sda_size += sdata->_raw_size;
+	    }
+
+          if (sbss != NULL)
+            {
+              if (sbss->_cooked_size != 0)
+	        sda_size += sbss->_cooked_size;
+	      else
+	        sda_size += sbss->_raw_size;
+	    }
+
+          if (sda_size > (0x8000 - 4))
+            {
+	      (*_bfd_error_handler) (_("%s: Too many SDA entries (%ld bytes)"),
+	  			     bfd_archive_filename (output_bfd),
+				     sda_size);
+	      return false;
+	    }
+        }
+
+      if ((got_size + sda_size) <= 0x8000)
+        gp_offset = 0;
+      else if ((got_size > 0x8000)
+	       && ((sda_size + got_size - 0x8000) <= 0x8000))
+	gp_offset = 0x8000;
+      else
+        gp_offset = got_size - 4;
+
+      if (gp_offset != 0)
+	elf_hash_table (info)->hgot->root.u.def.value = gp_offset;
+
+      /* If there's any data in ".sdata"/".sbss", set the value of
+         _SMALL_DATA_ to that of the GOT pointer.  */
+      if (((sdata != NULL) && (sdata->_raw_size > 0))
+          || ((sbss != NULL) && (sbss->_raw_size > 0)))
+        {
+	  h = (struct elf_link_hash_entry *)
+	       bfd_link_hash_lookup (info->hash, "_SMALL_DATA_",
+	  			     false, false, false);
+	  if (h == NULL)
+	    {
+	      /* This can't possibly happen, as we're always creating the
+	         ".sdata"/".sbss" output sections and the "_SMALL_DATA_"
+		 symbol in tricore_elf32_check_relocs.  */
+	      (*_bfd_error_handler)
+	       (_("%s: SDA entries, but _SMALL_DATA_ undefined"),
+	       bfd_archive_filename (output_bfd));
+	      return false;
+	    }
+	  gp = gp_offset + sgot->output_section->vma + sgot->output_offset;
+	  sdata = h->root.u.def.section;
+	  sda = sdata->output_section->vma + sdata->output_offset;
+	  h->root.u.def.value = gp - sda;
+	}
+    }
+
+  return 1;
+}
+#endif
+
+                                        
+
+/* Check whether it's okay to merge objects IBFD and OBFD.  */
+
+static int
+tricore_elf32_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
+{
+  int error = 0;
+  unsigned long mask;
+
+  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
+      || bfd_get_flavour (info->output_bfd) != bfd_target_elf_flavour)
+    return 1;
+
+  if ((bfd_get_arch (ibfd) != bfd_arch_tricore) ||
+      (bfd_get_arch (info->output_bfd) != bfd_arch_tricore))
+    {
+      error = 1;
+      (*_bfd_error_handler)
+       (_("%s and/or %s don't use the TriCore architecture."),
+        bfd_get_filename (ibfd), bfd_get_filename (info->output_bfd));
+    }
+  else
+    {
+      unsigned long new_isa;
+
+      mask = tricore_elf32_convert_eflags(elf_elfheader(ibfd)->e_flags);
+      new_isa = mask & EF_EABI_TRICORE_CORE_MASK;
+      // old_isa = tricore_core_arch & EF_EABI_TRICORE_CORE_MASK;
+      switch (tricore_core_arch & EF_EABI_TRICORE_CORE_MASK)
+        {
+	case EF_EABI_TRICORE_V1_1:
+	  if (new_isa != EF_EABI_TRICORE_V1_1)
+	    {
+	      error = 1;
+	    }
+	  break;
+	case EF_EABI_TRICORE_V1_2:
+	case EF_EABI_TRICORE_V1_3:
+	  switch (new_isa)
+	    {
+	    case EF_EABI_TRICORE_V1_1:
+	    case EF_EABI_TRICORE_V1_3_1:
+	    case EF_EABI_TRICORE_V1_6:
+	    case EF_EABI_TRICORE_V1_6_1:
+	      error = 1;
+	      break;
+	    }
+	  break;
+	case EF_EABI_TRICORE_V1_3_1:
+	  switch (new_isa)
+	    {
+	    case EF_EABI_TRICORE_V1_1:
+	    case EF_EABI_TRICORE_V1_6:
+	    case EF_EABI_TRICORE_V1_6_1:
+	      error = 1;
+	      break;
+	    }
+	  break;
+	case EF_EABI_TRICORE_V1_6:
+	  switch (new_isa)
+	    {
+	    case EF_EABI_TRICORE_V1_1:
+	    case EF_EABI_TRICORE_V1_6_1:
+	      error = 1;
+	      break;
+	    }
+	  break;
+	case EF_EABI_TRICORE_V1_6_1:
+	  switch (new_isa)
+	    {
+	    case EF_EABI_TRICORE_V1_1:
+	      error = 1;
+	      break;
+	    }
+	  break;
+	}
+
+
+      if (error == 1)
+	{
+          (*_bfd_error_handler)
+           ("%s uses an incompatible TriCore instruction set architecture.",
+            bfd_get_filename (ibfd));
+	}
+      else
+        {
+	  elf_elfheader (info->output_bfd)->e_flags = tricore_core_arch;
+	}
+    }
+
+  if (error)
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return 0;
+    }
+
+  return 1;
+}
+
+/* Copy e_flags from IBFD to OBFD.  */
+
+static int
+tricore_elf32_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
+{
+  int error = 0;
+
+  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
+      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
+    return 1;
+
+  if (bfd_get_arch (ibfd) != bfd_arch_tricore)
+    {
+      error = 1;
+      (*_bfd_error_handler)
+       (_("%s doesn't use the TriCore architecture."), bfd_get_filename (ibfd));
+    }
+  else
+    elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
+
+  if (error)
+    {
+      bfd_set_error (bfd_error_bad_value);
+      return 0;
+    }
+
+  return 1;
+}
+
+/* Set the correct machine number (i.e., the ID for the instruction set
+   architecture) for a TriCore ELF file.  */
+
+// static void
+// tricore_elf32_set_arch_mach (bfd *abfd, enum bfd_architecture arch)
+// {
+//   bfd_arch_info_type *ap, *def_ap;
+//   unsigned long mach;
+
+//   if (arch != bfd_arch_tricore)
+//     return; /* Case already handled by bfd_default_set_arch_mach.  */
+
+//   mach = tricore_elf32_convert_eflags (elf_elfheader (abfd)->e_flags) & EF_EABI_TRICORE_CORE_MASK;
+
+//   /* Find the default arch_info.  */
+//   def_ap = (bfd_arch_info_type *) bfd_scan_arch (DEFAULT_ISA);
+
+//   /* Scan all sub-targets of the default architecture until we find
+//      the one that matches "mach".  If we find a target that is not
+//      the current default, we're making it the new default.  */
+//   for (ap = def_ap; ap != NULL; ap = (bfd_arch_info_type *) ap->next)
+//     if (ap->mach == mach)
+//       {
+// 	abfd->arch_info = ap;
+// 	return;
+//       }
+
+//   abfd->arch_info = &bfd_default_arch_struct;
+//   bfd_set_error (bfd_error_bad_value);
+// }
+
+/* This hack is needed because it's not possible to redefine the
+   function bfd_default_set_arch_mach.  Since we need to set the
+   correct instruction set architecture, we're redefining
+   bfd_elf32_object_p below (but calling it here to do the real work)
+   and then we're calling tricore_elf32_set_arch_mach to set the
+   correct ISA.  */
+
+// const bfd_target *
+// tricore_elf32_object_p (bfd *abfd)
+// {
+//   const bfd_target *bt;
+//   struct elf_backend_data *ebd;
+//   extern const bfd_target *elf_object_p (bfd *);
+
+//   if ((bt = bfd_elf32_object_p (abfd)) != NULL)
+//     {
+//       ebd = abfd->xvec->backend_data;
+//       tricore_elf32_set_arch_mach (abfd, ebd->arch);
+//     }
+
+//   return bt;
+// }
+
+
+/* Now #define all necessary stuff to describe this target.  */
+
+#define USE_RELA			1
+#define ELF_ARCH			bfd_arch_tricore
+#define ELF_MACHINE_CODE		EM_TRICORE
+#define ELF_MAXPAGESIZE			0x4000
+#define TARGET_LITTLE_SYM		tricore_elf32_le_vec
+#define TARGET_LITTLE_NAME		"elf32-tricore"
+#define bfd_elf32_bfd_reloc_type_lookup	tricore_elf32_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup tricore_elf_reloc_name_lookup
+//#define bfd_elf32_object_p		tricore_elf32_object_p
+#define bfd_elf32_bfd_merge_private_bfd_data tricore_elf32_merge_private_bfd_data
+#define bfd_elf32_bfd_copy_private_bfd_data tricore_elf32_copy_private_bfd_data
+#define elf_info_to_howto		tricore_elf32_info_to_howto
+#define elf_info_to_howto_rel		0
+
+#include "elf32-target.h"
\ No newline at end of file
diff --git a/bfd/libbfd.h b/bfd/libbfd.h
index c37ddc03cfd..675d393d099 100644
--- a/bfd/libbfd.h
+++ b/bfd/libbfd.h
@@ -3318,6 +3318,84 @@ static const char *const bfd_reloc_code_real_names[] = { "@@uninitialized@@",
   "BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD",
   "BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD",
   "BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD",
+  "BFD_RELOC_TRICORE_NONE",
+  "BFD_RELOC_TRICORE_32REL",
+  "BFD_RELOC_TRICORE_32ABS",
+  "BFD_RELOC_TRICORE_24REL",
+  "BFD_RELOC_TRICORE_24ABS",
+  "BFD_RELOC_TRICORE_16SM",
+  "BFD_RELOC_TRICORE_HIADJ",
+  "BFD_RELOC_TRICORE_LO",
+  "BFD_RELOC_TRICORE_LO2",
+  "BFD_RELOC_TRICORE_18ABS",
+  "BFD_RELOC_TRICORE_10SM",
+  "BFD_RELOC_TRICORE_15REL",
+  "BFD_RELOC_TRICORE_PCPHI",
+  "BFD_RELOC_TRICORE_PCPLO",
+  "BFD_RELOC_TRICORE_PCPPAGE",
+  "BFD_RELOC_TRICORE_PCPOFF",
+  "BFD_RELOC_TRICORE_PCPTEXT",
+  "BFD_RELOC_TRICORE_HI",
+  "BFD_RELOC_TRICORE_16CONST",
+  "BFD_RELOC_TRICORE_9ZCONST",
+  "BFD_RELOC_TRICORE_9SCONST",
+  "BFD_RELOC_TRICORE_8REL",
+  "BFD_RELOC_TRICORE_8CONST",
+  "BFD_RELOC_TRICORE_10OFF",
+  "BFD_RELOC_TRICORE_16OFF",
+  "BFD_RELOC_TRICORE_8ABS",
+  "BFD_RELOC_TRICORE_16ABS",
+  "BFD_RELOC_TRICORE_1BIT",
+  "BFD_RELOC_TRICORE_3POS",
+  "BFD_RELOC_TRICORE_5POS",
+  "BFD_RELOC_TRICORE_5POS2",
+  "BFD_RELOC_TRICORE_BRCC",
+  "BFD_RELOC_TRICORE_BRCZ",
+  "BFD_RELOC_TRICORE_BRNN",
+  "BFD_RELOC_TRICORE_RRN",
+  "BFD_RELOC_TRICORE_4CONST",
+  "BFD_RELOC_TRICORE_4REL",
+  "BFD_RELOC_TRICORE_4REL2",
+  "BFD_RELOC_TRICORE_5POS3",
+  "BFD_RELOC_TRICORE_4OFF",
+  "BFD_RELOC_TRICORE_4OFF2",
+  "BFD_RELOC_TRICORE_4OFF4",
+  "BFD_RELOC_TRICORE_42OFF",
+  "BFD_RELOC_TRICORE_42OFF2",
+  "BFD_RELOC_TRICORE_42OFF4",
+  "BFD_RELOC_TRICORE_2OFF",
+  "BFD_RELOC_TRICORE_8CONST2",
+  "BFD_RELOC_TRICORE_4POS",
+  "BFD_RELOC_TRICORE_16SM2",
+  "BFD_RELOC_TRICORE_5REL",
+  "BFD_RELOC_TRICORE_GNU_VTENTRY",
+  "BFD_RELOC_TRICORE_GNU_VTINHERIT",
+  "BFD_RELOC_TRICORE_PCREL16",
+  "BFD_RELOC_TRICORE_PCREL8",
+  "BFD_RELOC_TRICORE_GOT",
+  "BFD_RELOC_TRICORE_GOT2",
+  "BFD_RELOC_TRICORE_GOTHI",
+  "BFD_RELOC_TRICORE_GOTLO",
+  "BFD_RELOC_TRICORE_GOTLO2",
+  "BFD_RELOC_TRICORE_GOTUP",
+  "BFD_RELOC_TRICORE_GOTOFF",
+  "BFD_RELOC_TRICORE_GOTOFF2",
+  "BFD_RELOC_TRICORE_GOTOFFHI",
+  "BFD_RELOC_TRICORE_GOTOFFLO",
+  "BFD_RELOC_TRICORE_GOTOFFLO2",
+  "BFD_RELOC_TRICORE_GOTOFFUP",
+  "BFD_RELOC_TRICORE_GOTPC",
+  "BFD_RELOC_TRICORE_GOTPC2",
+  "BFD_RELOC_TRICORE_GOTPCHI",
+  "BFD_RELOC_TRICORE_GOTPCLO",
+  "BFD_RELOC_TRICORE_GOTPCLO2",
+  "BFD_RELOC_TRICORE_GOTPCUP",
+  "BFD_RELOC_TRICORE_PLT",
+  "BFD_RELOC_TRICORE_COPY",
+  "BFD_RELOC_TRICORE_GLOB_DAT",
+  "BFD_RELOC_TRICORE_JMP_SLOT",
+  "BFD_RELOC_TRICORE_RELATIVE",
+  "BFD_RELOC_TRICORE_BITPOS",
   "BFD_RELOC_BPF_64",
   "BFD_RELOC_BPF_32",
   "BFD_RELOC_BPF_16",
diff --git a/bfd/po/SRC-POTFILES.in b/bfd/po/SRC-POTFILES.in
index c83b86cd663..7e96b838870 100644
--- a/bfd/po/SRC-POTFILES.in
+++ b/bfd/po/SRC-POTFILES.in
@@ -117,6 +117,7 @@ cpu-tic54x.c
 cpu-tic6x.c
 cpu-tilegx.c
 cpu-tilepro.c
+cpu-tricore.c
 cpu-v850.c
 cpu-v850_rh850.c
 cpu-vax.c
diff --git a/bfd/reloc.c b/bfd/reloc.c
index 6d920e1df06..a912686016f 100644
--- a/bfd/reloc.c
+++ b/bfd/reloc.c
@@ -7951,6 +7951,182 @@ ENUMX
 ENUMDOC
   Tilera TILE-Gx Relocations.
 
+ENUM
+  BFD_RELOC_TRICORE_NONE
+ENUMX
+  BFD_RELOC_TRICORE_32REL
+ENUMX
+  BFD_RELOC_TRICORE_32ABS
+ENUMX
+  BFD_RELOC_TRICORE_24REL
+ENUMX
+  BFD_RELOC_TRICORE_24ABS
+ENUMX
+  BFD_RELOC_TRICORE_16SM
+ENUMX
+  BFD_RELOC_TRICORE_HIADJ
+ENUMX
+  BFD_RELOC_TRICORE_LO
+ENUMX
+  BFD_RELOC_TRICORE_LO2
+ENUMX
+  BFD_RELOC_TRICORE_18ABS
+ENUMX
+  BFD_RELOC_TRICORE_10SM
+ENUMX
+  BFD_RELOC_TRICORE_15REL
+ENUMDOC
+  These are relocation types defined in the TriCore ABI.
+
+ENUM
+  BFD_RELOC_TRICORE_PCPHI
+ENUMX
+  BFD_RELOC_TRICORE_PCPLO
+ENUMX
+  BFD_RELOC_TRICORE_PCPPAGE
+ENUMX
+  BFD_RELOC_TRICORE_PCPOFF
+ENUMX
+  BFD_RELOC_TRICORE_PCPTEXT
+ENUMDOC
+  These are relocation types defined for TriCore's PCP co-processor.
+
+ENUM
+  BFD_RELOC_TRICORE_HI
+ENUMX
+  BFD_RELOC_TRICORE_16CONST
+ENUMX
+  BFD_RELOC_TRICORE_9ZCONST
+ENUMX
+  BFD_RELOC_TRICORE_9SCONST
+ENUMX
+  BFD_RELOC_TRICORE_8REL
+ENUMX
+  BFD_RELOC_TRICORE_8CONST
+ENUMX
+  BFD_RELOC_TRICORE_10OFF
+ENUMX
+  BFD_RELOC_TRICORE_16OFF
+ENUMX
+  BFD_RELOC_TRICORE_8ABS
+ENUMX
+  BFD_RELOC_TRICORE_16ABS
+ENUMX
+  BFD_RELOC_TRICORE_1BIT
+ENUMX
+  BFD_RELOC_TRICORE_3POS
+ENUMX
+  BFD_RELOC_TRICORE_5POS
+ENUMX
+  BFD_RELOC_TRICORE_5POS2
+ENUMX
+  BFD_RELOC_TRICORE_BRCC
+ENUMX
+  BFD_RELOC_TRICORE_BRCZ
+ENUMX
+  BFD_RELOC_TRICORE_BRNN
+ENUMX
+  BFD_RELOC_TRICORE_RRN
+ENUMX
+  BFD_RELOC_TRICORE_4CONST
+ENUMX
+  BFD_RELOC_TRICORE_4REL
+ENUMX
+  BFD_RELOC_TRICORE_4REL2
+ENUMX
+  BFD_RELOC_TRICORE_5POS3
+ENUMX
+  BFD_RELOC_TRICORE_4OFF
+ENUMX
+  BFD_RELOC_TRICORE_4OFF2
+ENUMX
+  BFD_RELOC_TRICORE_4OFF4
+ENUMX
+  BFD_RELOC_TRICORE_42OFF
+ENUMX
+  BFD_RELOC_TRICORE_42OFF2
+ENUMX
+  BFD_RELOC_TRICORE_42OFF4
+ENUMX
+  BFD_RELOC_TRICORE_2OFF
+ENUMX
+  BFD_RELOC_TRICORE_8CONST2
+ENUMX
+  BFD_RELOC_TRICORE_4POS
+ENUMX
+  BFD_RELOC_TRICORE_16SM2
+ENUMX
+  BFD_RELOC_TRICORE_5REL
+ENUMDOC
+  These are GNU extensions of TriCore relocations, which allow
+  to relocate all non-register operands.
+
+ENUM
+  BFD_RELOC_TRICORE_GNU_VTENTRY
+ENUMX  
+  BFD_RELOC_TRICORE_GNU_VTINHERIT
+ENUMDOC
+  These are GNU extensions of TriCore relocations, which allow
+  the linker to optimize virtual tables (C++).
+
+ENUM
+  BFD_RELOC_TRICORE_PCREL16
+ENUMX  
+  BFD_RELOC_TRICORE_PCREL8
+ENUMX
+  BFD_RELOC_TRICORE_GOT
+ENUMX
+  BFD_RELOC_TRICORE_GOT2
+ENUMX
+  BFD_RELOC_TRICORE_GOTHI
+ENUMX
+  BFD_RELOC_TRICORE_GOTLO
+ENUMX
+  BFD_RELOC_TRICORE_GOTLO2
+ENUMX
+  BFD_RELOC_TRICORE_GOTUP
+ENUMX
+  BFD_RELOC_TRICORE_GOTOFF
+ENUMX
+  BFD_RELOC_TRICORE_GOTOFF2
+ENUMX
+  BFD_RELOC_TRICORE_GOTOFFHI
+ENUMX
+  BFD_RELOC_TRICORE_GOTOFFLO
+ENUMX
+  BFD_RELOC_TRICORE_GOTOFFLO2
+ENUMX
+  BFD_RELOC_TRICORE_GOTOFFUP
+ENUMX
+  BFD_RELOC_TRICORE_GOTPC
+ENUMX
+  BFD_RELOC_TRICORE_GOTPC2
+ENUMX
+  BFD_RELOC_TRICORE_GOTPCHI
+ENUMX
+  BFD_RELOC_TRICORE_GOTPCLO
+ENUMX
+  BFD_RELOC_TRICORE_GOTPCLO2
+ENUMX
+  BFD_RELOC_TRICORE_GOTPCUP
+ENUMX
+  BFD_RELOC_TRICORE_PLT
+ENUMX
+  BFD_RELOC_TRICORE_COPY
+ENUMX
+  BFD_RELOC_TRICORE_GLOB_DAT
+ENUMX
+  BFD_RELOC_TRICORE_JMP_SLOT
+ENUMX
+  BFD_RELOC_TRICORE_RELATIVE
+ENUMDOC
+  These TriCore relocations add support for shared objects.
+
+ENUM
+  BFD_RELOC_TRICORE_BITPOS
+ENUMDOC
+  This supports allocating single bit objects.
+
 ENUM
   BFD_RELOC_BPF_64
 ENUMX
diff --git a/bfd/targets.c b/bfd/targets.c
index 89b49e721b4..701074f9fc7 100644
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -914,6 +914,7 @@ extern const bfd_target tilegx_elf32_le_vec;
 extern const bfd_target tilegx_elf64_be_vec;
 extern const bfd_target tilegx_elf64_le_vec;
 extern const bfd_target tilepro_elf32_vec;
+extern const bfd_target tricore_elf32_le_vec;
 extern const bfd_target v800_elf32_vec;
 extern const bfd_target v850_elf32_vec;
 extern const bfd_target ft32_elf32_vec;
@@ -1319,6 +1320,8 @@ static const bfd_target * const _bfd_target_vector[] =
 #endif
 	&tilepro_elf32_vec,
 
+	&tricore_elf32_le_vec,
+
 	&ft32_elf32_vec,
 
 	&v800_elf32_vec,
diff --git a/binutils/readelf.c b/binutils/readelf.c
index af10bcd0e17..e0f60e42c4d 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -152,6 +152,7 @@
 #include "elf/tic6x.h"
 #include "elf/tilegx.h"
 #include "elf/tilepro.h"
+#include "elf/tricore.h"
 #include "elf/v850.h"
 #include "elf/vax.h"
 #include "elf/visium.h"
@@ -1627,6 +1628,10 @@ dump_relocations (Filedata *          filedata,
 	  rtype = elf_tilepro_reloc_type (type);
 	  break;
 
+	case EM_TRICORE:
+	  rtype = elf_tricore_reloc_type (type);
+	  break;
+
 	case EM_WEBASSEMBLY:
 	  rtype = elf_wasm32_reloc_type (type);
 	  break;
diff --git a/config.sub b/config.sub
index 7384e9198b4..8ed318ca1ac 100755
--- a/config.sub
+++ b/config.sub
@@ -997,6 +997,9 @@ case $cpu-$vendor in
 	orion-unknown)
 		vendor=highlevel
 		;;
+	tricore-unknown)
+		vendor=infineon
+		;;
 	xps-unknown | xps100-unknown)
 		cpu=xps100
 		vendor=honeywell
@@ -1248,6 +1251,7 @@ case $cpu-$vendor in
 			| tahoe \
 			| thumbv7* \
 			| tic30 | tic4x | tic54x | tic55x | tic6x | tic80 \
+			| tricore \
 			| tron \
 			| ubicom32 \
 			| v70 | v850 | v850e | v850e1 | v850es | v850e2 | v850e2v3 \
diff --git a/gas/Makefile.am b/gas/Makefile.am
index 34190e78b8c..c09e738121d 100644
--- a/gas/Makefile.am
+++ b/gas/Makefile.am
@@ -192,6 +192,7 @@ TARGET_CPU_CFILES = \
 	config/tc-tic6x.c \
 	config/tc-tilegx.c \
 	config/tc-tilepro.c \
+	config/tc-tricore.c \
 	config/tc-v850.c \
 	config/tc-vax.c \
 	config/tc-visium.c \
@@ -266,6 +267,7 @@ TARGET_CPU_HFILES = \
 	config/tc-tic6x.h \
 	config/tc-tilegx.h \
 	config/tc-tilepro.h \
+	config/tc-tricore.h \
 	config/tc-v850.h \
 	config/tc-vax.h \
 	config/tc-visium.h \
diff --git a/gas/config/tc-tricore.c b/gas/config/tc-tricore.c
new file mode 100644
index 00000000000..7317d691dc6
--- /dev/null
+++ b/gas/config/tc-tricore.c
@@ -0,0 +1,10098 @@
+/* tc-tricore.c -- Assemble code for Infineon's TriCore MPU/MCU/DSP
+		   (incl. MMU, FPU) and its on-chip PCP coprocessor.
+   Copyright (C) 1998-2005 Free Software Foundation.
+   Contributed by Michael Schumacher (mike@hightec-rt.com).
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include "as.h"
+#include "subsegs.h"
+#include "obstack.h"
+#include "dwarf2dbg.h"
+#include "opcode/tricore.h"
+#include "elf/tricore.h"
+#include "bfd.h"
+#include "elf-bfd.h"
+#ifdef HTC_SUPPORT
+#include "htc/htc_support.h"
+#endif
+#include <assert.h>
+
+#define MAX_OPS 5
+#define MAX_PCPOPS 5
+#define MAX_RELAXED_INSN_SIZE 12
+#define INITIAL_INSNLINELENGTH 1024
+#define NUMOPCODES tricore_numopcodes
+#define NUMPCPOPCODES pcp_numopcodes
+#define NUMSFRS tricore_numsfrs
+#define NO_RELOC _dummy_first_bfd_reloc_code_real
+#define BFD_RELOC_TRICORE_PCPREL6 BFD_RELOC_NONE+1
+#define BFD_RELOC_TRICORE_PCPREL10 BFD_RELOC_NONE+2
+#define CHECK_RELOC(i) if ((reloc = find_relocation (i)) == NO_RELOC) return
+#define VAL(i) the_insn.opexp[i].X_add_number
+#define PCPVAL(i) pcp_insn.opexp[i].X_add_number
+#define SP_REGNUM 10
+#define OPC_ADDR(f) (valueT) ((f)->fr_opcode)
+#define BFD_RELOC_TRICORE_24CALL BFD_RELOC_TRICORE_24REL
+#define GET_RELOC_NAME(code) \
+	  ((code <= BFD_RELOC_NONE) \
+	   ? bfd_get_reloc_code_name (code) \
+	   : pcp_internal_reloc_name[code - BFD_RELOC_NONE])
+#define MATCHES_ISA(isa) \
+	  (((isa) == TRICORE_GENERIC) \
+	   || ((isa & TRICORE_ISA_MASK) & current_isa))
+
+/* This array holds the chars that always start a comment.  If the
+   pre-processor is disabled, these aren't very useful.  */
+
+const char comment_chars[] = "#";
+
+/* This array holds the chars that only start a comment at the beginning
+   of a line.  If the line seems to have the form '# 123 filename',
+   .line and .file directives will appear in the pre-processed output.
+   Note that input_file.c hand checks for '#' at the beginning of the
+   first line of the input file.  This is because the compiler outputs
+   #NO_APP at the beginning of its output.  Also note that comments
+   started like this one will always work, no matter if the pre-processor
+   is enabled or not.  */
+
+const char line_comment_chars[] = "#";
+
+/* These chars may be used to separate lines (i.e., insns, labels and
+   pseudo-ops).  We're using the semicolon for this purpose, as it
+   cannot be part of any legal TriCore/PCP insn.  */
+
+const char line_separator_chars[] = ";";
+
+/* Chars that can be used to separate the mantissa from the exponent
+   in floating point numbers.  */
+
+const char EXP_CHARS[] = "eE";
+
+/* Chars that mean this number is a floating point constant, as in
+   0f12.456 or 0d1.2345e12.  */
+
+const char FLT_CHARS[] = "fFdD";
+
+/* Additional assembler flags.  */
+
+const char *md_shortopts = "VYm:";
+
+/* Additional assembler options.  */
+
+#define OPTION_NOOPT		(OPTION_MD_BASE)
+#define OPTION_INSN32_ONLY	(OPTION_MD_BASE + 1)
+#define OPTION_INSN32_PREF	(OPTION_MD_BASE + 2)
+#define OPTION_ENFORCE_ALIGN	(OPTION_MD_BASE + 3)
+
+struct option md_longopts[] =
+{
+  {"dont-optimize", no_argument, NULL, OPTION_NOOPT},
+  {"insn32-only", no_argument, NULL, OPTION_INSN32_ONLY},
+  {"insn32-preferred", no_argument, NULL, OPTION_INSN32_PREF},
+  {"enforce-aligned-data", no_argument, NULL, OPTION_ENFORCE_ALIGN},
+  {NULL, no_argument, NULL, 0}
+};
+
+size_t md_longopts_size = sizeof md_longopts;
+
+/* Additional and overridden pseudo opcodes.  */
+
+static void set_16bit_code_flag (int);
+static void set_32bit_code_flag (int);
+static void set_optimize_flag (int);
+static void make_section (int);
+static void pcp_init_word (int);
+static void create_bit (int);
+static void bpcons (int);
+static void tricore_uacons (int);
+#define TOC_SECTION	0
+#define RODATA_SECTION	1
+#define SDATA_SECTION	2
+#define SBSS_SECTION	3
+#define ZDATA_SECTION	4
+#define ZBSS_SECTION	5
+#define PCPTEXT_SECTION	6
+#define PCPDATA_SECTION 7
+const pseudo_typeS md_pseudo_table[] =
+{
+  {"code16", set_16bit_code_flag, 1},
+  {"code32", set_32bit_code_flag, 1},
+  {"optim", set_optimize_flag, 1},
+  {"noopt", set_optimize_flag, 0},
+  {"word", cons, 4},
+  {"blcomm", s_lcomm_bytes, 1},
+  {"toc", make_section, TOC_SECTION},
+  {"rodata", make_section, RODATA_SECTION},
+  {"sdata", make_section, SDATA_SECTION},
+  {"sbss", make_section, SBSS_SECTION},
+  {"zdata", make_section, ZDATA_SECTION},
+  {"zbss", make_section, ZBSS_SECTION},
+  {"pcptext", make_section, PCPTEXT_SECTION},
+  {"pcpdata", make_section, PCPDATA_SECTION},
+  {"pcpinitword", pcp_init_word, 0},
+  {"bit", create_bit, 1},
+  {"lbit", create_bit, 0},
+  {"bpos", bpcons, 1},
+  {"bposb", bpcons, 1},
+  {"bposh", bpcons, 2},
+  {"bposw", bpcons, 4},
+  {"uahalf", tricore_uacons, 2},
+  {"uaword", tricore_uacons, 4},
+  {"uaxword", tricore_uacons, 8},
+  {"file", (void (*) (int)) dwarf2_directive_file, 0},
+  {"loc", dwarf2_directive_loc, 0},
+  {NULL, 0, 0}
+};
+
+/* 1 means be extra verbose (for debugging only).  */
+
+static int show_internals = 0;
+
+/* 1 means use a 32-bit insn even if there's a 16-bit equivalent.  */
+
+static int big_insns = 0;
+
+/* 1 means use only 32-bit insns and ignore .code16 pseudo-ops.  */
+
+static int big_insns_only = 0;
+
+/* 1 means the next insn should be assembled into a 16-bit insn.  */
+
+static int use_insn16 = 0;
+
+/* 1 means the next insn should be assembled into a 32-bit insn.  */
+
+static int use_insn32 = 0;
+
+/* 1 means try to find the shortest opcode that matches the given mnemonic.  */
+
+static int optimize = 1;
+
+/* 1 means the next insn should be optimized, even if optimize == 0.  */
+
+static int optimize_next;
+
+/* 1 means always auto-align data created by .hword/.word/... pseudo-ops.  */
+
+static int enforce_aligned_data = 0;
+
+/* 1 means don't auto-align data created by .uahalf/.uaword/... pseudo-ops.  */
+
+static int tricore_no_align_cons = 0;
+
+/* 1 means automatically insert two NOPs after a DSYNC instruction.  */
+
+static int workaround_cpu9 = 0;
+
+/* 1 means automatically insert a NOP after a DSYNC instruction.  */
+
+static int workaround_cpu34 = 0;
+
+/* 1 means automatically insert a NOP between a LD.[A,DA] and an
+   indirect jump or call instruction immediately following it.  */
+
+static int workaround_cpu48 = 0;
+
+/* 1 means automatically insert a NOP after some multi-cycle instructions
+   when followed by a load instruction.  */
+
+static int workaround_cpu50 = 0;
+
+/* 1 means automatically insert a NOP between a LD.[A,DA] and a
+   LD.[D,W] instruction immediately following it.  */
+
+static int workaround_cpu60 = 0;
+
+/* 1 means automatically insert a NOP after a RSLCX instruction.  */
+
+static int workaround_cpu69 = 0;
+
+/* 1 means automatically insert 1-2 NOPs between a conditional jump
+   instruction and a LOOP instruction immediately following it.  */
+
+static int workaround_cpu70 = 0;
+
+/* 1 means automatically insert a NOP between a LD.[A,DA] and a
+   LOOP instruction immediately following it.  */
+
+static int workaround_cpu72 = 0;
+
+/* 1 means gripe when seeing a LD.[A,DA] %A10,... instruction.  */
+
+static int workaround_cpu81 = 0;
+
+/* 1 means automatically insert a NOP between a ST[LU]CX and a
+   LD.x instruction immediately following it.  */
+
+static int workaround_cpu82 = 0;
+
+/* 1 means automatically insert a NOP after a DISABLE instruction.  */
+
+static int workaround_cpu83 = 0;
+
+/* 1 means automatically insert 1 NOP between a conditional jump
+   in the IP (the jump uses a data register) and a context sensitive
+   instruction CALL, CALLA, CALLI, SYSCALL, RET, RFE */
+
+static int workaround_cpu94 = 0;
+
+/* 1 means automatically insert 1 NOP between a sat.b/sat.h and a following
+   addsc.a, addsc.at, mov.a, mtcr which use a DGPR as a source */
+
+static int workaround_cpu95 = 0;
+
+/* 1 means automatically insert a NOP as required by DMI_TC.012 HW bug. */
+
+static int workaround_dmi12 = 0;
+
+/* Names of additional PCP relocations handling PC-relative jumps.
+   These relocs are only used (and resolved) internally, meaning
+   they will never appear in object files.  For debugging only.  */
+
+static const char *pcp_internal_reloc_name[] =
+{
+  "BFD_RELOC_NONE (unused)",
+  "BFD_RELOC_TRICORE_PCPREL6 (internal)",
+  "BFD_RELOC_TRICORE_PCPREL10 (internal)"
+};
+
+/* Additional sections that can be defined using pseudo-ops.  */
+
+static segT toc_section;	/* Table-of-contents section.  */
+static segT rodata_section;	/* Read-only data section.  */
+static segT sdata_section;	/* Small data section.  */
+static segT sbss_section;	/* Small bss section.  */
+static segT zdata_section;	/* Absolute addressable data section.  */
+static segT zbss_section;	/* Absolute addressable bss section.  */
+static segT pcptext_section;	/* PCP text section.  */
+static segT pcpdata_section;	/* PCP data section.  */
+
+#define AR_FLAGS		SEC_ALLOC | SEC_RELOC
+#define ARLD_FLAGS		AR_FLAGS | SEC_LOAD | SEC_DATA
+//#define PCP_SEG			SEC_ARCH_BIT_0
+
+typedef struct _asec_t
+{
+  int sec_exists;		/* 1 if this section has been created.  */
+  int sec_align;		/* The alignment for this section.  */
+  const char *sec_name;		/* The name of this section.  */
+  segT *sec_ptr;		/* Pointer to section descriptor.  */
+  const int sec_flags;		/* Section flags (BFD style).  */
+} asec_t;
+
+static asec_t addsecs[] =
+{
+  {0, 3, ".toc",    &toc_section,    ARLD_FLAGS | SEC_READONLY},
+  {0, 3, ".rodata", &rodata_section, ARLD_FLAGS | SEC_READONLY},
+  {0, 3, ".sdata",  &sdata_section,  ARLD_FLAGS},
+  {0, 3, ".sbss",   &sbss_section,   AR_FLAGS},
+  {0, 3, ".zdata",  &zdata_section,  ARLD_FLAGS},
+  {0, 3, ".zbss",   &zbss_section,   AR_FLAGS},
+  {0, 1, ".pcptext",&pcptext_section, /* PCP_SEG | */ AR_FLAGS | SEC_LOAD | SEC_CODE},
+  {0, 6, ".pcpdata",&pcpdata_section, /* PCP_SEG | */ ARLD_FLAGS}
+};
+
+static const int nr_addsecs = sizeof addsecs / sizeof addsecs[0];
+
+/* Some handy shortcuts.  */
+
+typedef struct tricore_opcode opcode_t;
+typedef const struct tricore_core_register sfr_t;
+typedef struct pcp_opcode pcp_opcode_t;
+
+/* These are used to hash opcodes and SFRs.  */
+
+static struct htab *hash_ops = NULL;
+static struct htab *hash_sfr = NULL;
+static struct htab *hash_pcp = NULL;
+
+/* This is used to quickly find compatible operand types.  */
+
+static char *pseudo_codes[256];
+
+/* Names of TriCore instruction formats (same order as in tricore.h).  */
+
+static const char *fmt_name[] =
+{
+  "ABS", "ABSB", "B", "BIT", "BO", "BOL", "BRC", "BRN", "BRR",
+  "RC", "RCPW", "RCR", "RCRR", "RCRW", "RLC", "RR", "RR1", "RR2",
+  "RRPW", "RRR", "RRR1", "RRR2", "RRRR", "RRRW", "SYS",
+  "SB", "SBC", "SBR", "SBRN", "SC", "SLR", "SLRO", "SR",
+  "SRC", "SRO", "SRR", "SRRS", "SSR", "SSRO"
+};
+
+/* This is used to sort relocations in ascending order, while preserving
+   the order of multiple relocations for the same instruction.  */
+
+typedef struct _rel_entry
+{
+  arelent *reloc;
+  unsigned int index;
+} rel_entry;
+
+/* Forward declarations.  */
+
+int md_estimate_size_before_relax (register fragS *, register segT);
+void md_apply_fix3 (fixS *, valueT *, segT);
+long md_pcrel_from_section (fixS *, segT);
+static void check_insn_tables (void);
+static char classify_const (long);
+static int read_regno (char **str);
+static char read_regsuffix (char **str);
+static int get_expression (const char *, char **, int);
+static void tricore_ip (const char *str);
+static void insert_reg_or_const (int, int, char, int);
+static opcode_t *insn16_to_insn32 (void);
+static void delete_operand (int);
+static opcode_t *optimize_insn (opcode_t *);
+static void optimize_16bit_jumps (void);
+static opcode_t *find_opcode (void);
+static void print_the_insn (void);
+static int insert_abs18 (unsigned long *, int);
+static enum bfd_reloc_code_real find_relocation (int);
+static void emit_code (void);
+static int compare_relocs (const void *, const void *);
+//static void pcp_ip (const char *);
+//static int get_pcp_expression (const char *, char *, int, int);
+//static pcp_opcode_t *find_pcp_opcode (void);
+//static void print_pcp_insn (void);
+//static int pcp_encode (void);
+//static void pcp_emit_code (void);
+//static void pcp_assemble (const char *);
+static void md_pcp_apply_fix (fixS *, valueT *,
+				      enum bfd_reloc_code_real,
+				      char *);
+static void encode_abs (void);
+static void encode_absb (void);
+static void encode_b (void);
+static void encode_bit (void);
+static void encode_bo (void);
+static void encode_bol (void);
+static void encode_brc (void);
+static void encode_brn (void);
+static void encode_brr (void);
+static void encode_rc (void);
+static void encode_rcpw (void);
+static void encode_rcr (void);
+static void encode_rcrr (void);
+static void encode_rcrw (void);
+static void encode_rlc (void);
+static void encode_rr (void);
+static void encode_rr1 (void);
+static void encode_rr2 (void);
+static void encode_rrpw (void);
+static void encode_rrr (void);
+static void encode_rrr1 (void);
+static void encode_rrr2 (void);
+static void encode_rrrr (void);
+static void encode_rrrw (void);
+static void encode_sys (void);
+static void encode_sb (void);
+static void encode_sbc (void);
+static void encode_sbr (void);
+static void encode_sbrn (void);
+static void encode_sc (void);
+static void encode_slr (void);
+static void encode_slro (void);
+static void encode_sr (void);
+static void encode_src (void);
+static void encode_sro (void);
+static void encode_srr (void);
+static void encode_srrs (void);
+static void encode_ssr (void);
+static void encode_ssro (void);
+
+/* Array of pointers to encoding functions.  */
+
+static void (*encode[]) (void) =
+{
+  encode_abs, encode_absb, encode_b, encode_bit, encode_bo, encode_bol,
+  encode_brc, encode_brn, encode_brr, encode_rc, encode_rcpw, encode_rcr,
+  encode_rcrr, encode_rcrw, encode_rlc, encode_rr, encode_rr1, encode_rr2,
+  encode_rrpw, encode_rrr, encode_rrr1, encode_rrr2, encode_rrrr,
+  encode_rrrw, encode_sys,
+  encode_sb, encode_sbc, encode_sbr, encode_sbrn, encode_sc, encode_slr,
+  encode_slro, encode_sr, encode_src, encode_sro, encode_srr,
+  encode_srrs, encode_ssr, encode_ssro
+};
+
+/* To select between several possible relocation types, memory operands
+   may be prefixed with "hi:", "lo:", "sm:", "up:", "got:", "gothi:",
+   "gotlo:", "gotup:", "gotoff:", "gotoffhi:", "gotofflo:", "gotoffup:",
+   "gotpc:", "gotpchi:", "gotpclo:", "gotpcup:", "plt:", or "bpos:".  */
+
+typedef enum _prefix_t
+{
+  PREFIX_NONE = 0,
+  PREFIX_HI = 1,
+  PREFIX_LO = 2,
+  PREFIX_SM = 3,
+  PREFIX_UP = 4,
+  PREFIX_GOT = 5,
+  PREFIX_GOTHI = 6,
+  PREFIX_GOTLO = 7,
+  PREFIX_GOTUP = 8,
+  PREFIX_GOTOFF = 9,
+  PREFIX_GOTOFFHI = 10,
+  PREFIX_GOTOFFLO = 11,
+  PREFIX_GOTOFFUP = 12,
+  PREFIX_GOTPC = 13,
+  PREFIX_GOTPCHI = 14,
+  PREFIX_GOTPCLO = 15,
+  PREFIX_GOTPCUP = 16,
+  PREFIX_PLT = 17,
+  PREFIX_BITPOS = 18
+} prefix_t;
+
+/* The internal representation of a TriCore insn.  */
+
+typedef struct _tricore_insn_t
+{
+  const char *error;		/* Error message, or NULL on M'kay. :-)  */
+  opcode_t *code;		/* Pointer to matching opcode (hashed).  */
+  unsigned long opcode;		/* This insn's (preliminary) opcode.  */
+  unsigned long opc_address;	/* The address at which `opcode' is stored.  */
+  int nops;			/* Number of successfully parsed operands.  */
+  prefix_t prefix[MAX_OPS];	/* Operand prefixes (as defined above).  */
+  expressionS opexp[MAX_OPS];	/* Operand expressions.  */
+  unsigned char ops[MAX_OPS];	/* Operand types (as defined in tricore.h).  */
+  int regs[MAX_OPS];		/* Register number, if used as/by operand.  */
+  int matches_v[MAX_OPS];	/* 1 for operands matching type 'v'.  */
+  int matches_6[MAX_OPS];	/* 1 for operands matching type '6'.  */
+  int matches_k[MAX_OPS];	/* 1 for operands matching type 'k'.  */
+  int pcrel[MAX_OPS];		/* 1 for PC-relative operands.  */
+  int is_odd[MAX_OPS];		/* 1 for non-even constant operands.  */
+  int is_call;			/* 1 if this is a "call" or "fcall" insn.  */
+  int is_loop;			/* 1 if this is a "loop" insn.  */
+  int needs_prefix;		/* 1 if at least one operand is prefixed.  */
+  int bitpos[MAX_OPS];		/* 1 if operand is prefixed with "bpos:".  */
+} tricore_insn_t;
+
+static tricore_insn_t the_insn;
+
+/* To select between several possible PCP relocation types, memory operands
+   may be prefixed with "dptr:", "doff:", or "cptr:".  */
+
+typedef enum _pcp_pfx_t
+{
+  PCP_PREFIX_NONE = 0,
+  PCP_PREFIX_DPTR = 1,
+  PCP_PREFIX_DOFF = 2,
+  PCP_PREFIX_CPTR = 3
+} pcp_pfx_t;
+
+/* The internal representation of a PCP insn.  */
+
+typedef struct _pcp_insn_t
+{
+  const char *error;		/* Error message, or NULL on M'kay. :-)  */
+  pcp_opcode_t *code;		/* Pointer to matching opcode (hashed).  */
+  unsigned long opcode;		/* This insn's (preliminary) opcode.  */
+  int nops;			/* Number of successfully parsed operands.  */
+  pcp_pfx_t prefix[MAX_PCPOPS]; /* Operand prefixes (as defined above).  */
+  expressionS opexp[MAX_PCPOPS];/* Operand expressions.  */
+  unsigned char ops[MAX_PCPOPS];/* Operand types (as defined in tricore.h).  */
+} pcp_insn_t;
+
+//static pcp_insn_t pcp_insn;
+
+/* Names of PCP condition codes.  For debugging only.  */
+
+// static const char *pcp_ccodes[] =
+// {
+//   "uc", "z", "nz", "v", "c/ult", "ugt", "slt", "sgt",    /* CONDCA  */
+//   "n", "nn", "nv", "nc/uge", "sge", "sle", "cnz", "cnn"  /* CONDCB  */
+// };
+
+/* Which instruction set architecture are we assembling for?  */
+
+static tricore_isa current_isa = TRICORE_V1_2;
+
+/* This is used to convert 16-bit to 32-bit insns.  */
+
+typedef struct _insn16_t
+{
+  const char *name;		/* Name and operand types of 16-bit insn.  */
+  int neg_val1;			/* 1 if "VAL (1)" needs being negated.  */
+  int nr_inserts;		/* Number of reg/const insertions needed.  */
+  int reg_or_const1;		/* 1: insert register, 0: insert const.  */
+  int regno_or_val1;		/* Operand's reg number or value of const.  */
+  unsigned char op_type1;	/* Operand type of inserted reg/const.  */
+  int op_pos1;			/* Where to insert the reg/const.  */
+  int reg_or_const2;		/* Same as above, but for 2nd insertion.  */
+  int regno_or_val2;
+  unsigned char op_type2;
+  int op_pos2;
+  const char *new_name;		/* Name of equivalent 32-bit insn.  */
+  const char *new_args;		/* Operand types of equivalent 32-bit insn.  */
+  tricore_isa isa;		/* Applicable instruction set architecture.  */
+  opcode_t *new_code;		/* Pointer to equivalent 32-bit insn.  */
+} insn16_t;
+
+static insn16_t insn16_table[] =
+{
+  /* add %dn,%dx -> add %dn,%dn,%dx  */
+  {"add-dd",      0, 1,  1, 0, 'd', 0,  0, 0, 'X', 0,  "add",      "ddd",
+		  TRICORE_GENERIC, NULL},
+  /* add %dn,sconst4 -> add %dn,%dn,sconst9  */
+  {"add-d4",      0, 1,  1, 0, 'd', 0,  0, 0, 'X', 0,  "add",      "dd9",
+		  TRICORE_GENERIC, NULL},
+  /* add.a %an,%am -> add.a %an,%an,%am  */
+  {"add.a-aa",    0, 1,  1, 0, 'a', 0,  0, 0, 'X', 0,  "add.a",    "aaa",
+		  TRICORE_V1_2_UP, NULL},
+  /* add.a %an,sconst4 -> lea %an,[%an]sconst10  */
+  {"add.a-a4",    0, 1,  1, 0, '@', 0,  0, 0, 'X', 0,  "lea",      "a@0",
+		  TRICORE_V1_2_UP, NULL},
+  /* adds %dn,%dx -> adds %dn,%dn,%dx  */
+  {"adds-dd",     0, 1,  1, 0, 'd', 0,  0, 0, 'X', 0,  "adds",     "ddd",
+		  TRICORE_GENERIC, NULL},
+  /* addsc.a %an,%dn,zconst2 -> addsc.a %an,%an,%dn,zconst2  */
+  {"addsc.a-ad2", 0, 1,  1, 0, 'a', 0,  0, 0, 'X', 0,  "addsc.a",  "aad2",
+  		  TRICORE_V1_1, NULL},
+  /* addsc.a %an,%am,%d15,zconst2 -> addsc.a %an,%am,%d15,zconst2  */
+  {"addsc.a-aai2",0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "addsc.a",  "aad2",
+  		  TRICORE_V1_2_UP, NULL},
+  /* and %dn,%dx -> and %dn,%dn,%dx  */
+  {"and-dd",      0, 1,  1, 0, 'd', 0,  0, 0, 'X', 0,  "and",      "ddd",
+		  TRICORE_GENERIC, NULL},
+  /* and %d15,zconst8 -> and %d15,%d15,zconst9  */
+  {"and-i8",      0, 1,  1, 0, 'i', 0,  0, 0, 'X', 0,  "and",      "ddn",
+		  TRICORE_GENERIC, NULL},
+  /* cadd %dn,%d15,%dx -> cadd %dn,%d15,%dn,%dx  */
+  {"cadd-did",    0, 1,  1, 0, 'd', 2,  0, 0, 'X', 0,  "cadd",     "dddd",
+		  TRICORE_V1_1, NULL},
+  /* cadd %dn,%d15,sconst4 -> cadd %dn,%d15,%dn,sconst9  */
+  {"cadd-di4",    0, 1,  1, 0, 'd', 2,  0, 0, 'X', 0,  "cadd",     "ddd9",
+		  TRICORE_GENERIC, NULL},
+  /* caddn %dn,%d15,%dx -> caddn %dn,%d15,%dn,%dx  */
+  {"caddn-did",   0, 1,  1, 0, 'd', 2,  0, 0, 'X', 0,  "caddn",    "dddd",
+		  TRICORE_V1_1, NULL},
+  /* caddn %dn,%d15,sconst4 -> caddn %dn,%d15,%dn,sconst9  */
+  {"caddn-di4",   0, 1,  1, 0, 'd', 2,  0, 0, 'X', 0,  "caddn",    "ddd9",
+		  TRICORE_GENERIC, NULL},
+  /* call sdisp8 -> call sdisp24  */
+  {"call-R",      0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "call",     "O",
+		  TRICORE_V1_2_UP, NULL},
+  /* cmov %dn,%d15,%dx -> sel %dn,%d15,%dx,%dn  */
+  {"cmov-did",    0, 1,  1, 0, 'd', 3,  0, 0, 'X', 0,  "sel",      "dddd",
+		  TRICORE_GENERIC, NULL},
+  /* cmov %dn,%d15,sconst4 -> seln %dn,%d15,%dn,sconst9  */
+  {"cmov-di4",    0, 1,  1, 0, 'd', 2,  0, 0, 'X', 0,  "seln",     "ddd9",
+		  TRICORE_GENERIC, NULL},
+  /* cmovn %dn,%d15,%dx -> seln %dn,%d15,%dx,%dn  */
+  {"cmovn-did",   0, 1,  1, 0, 'd', 3,  0, 0, 'X', 0,  "seln",     "dddd",
+		  TRICORE_GENERIC, NULL},
+  /* cmovn %dn,%d15,sconst4 -> sel %dn,%d15,%dn,sconst9  */
+  {"cmovn-di4",   0, 1,  1, 0, 'd', 2,  0, 0, 'X', 0,  "sel",      "ddd9",
+		  TRICORE_GENERIC, NULL},
+  /* dvadj %en,%dx -> dvadj %en,%en,%dx  */
+  {"dvadj-Dd",    0, 1,  1, 0, 'D', 1,  0, 0, 'X', 0,  "dvadj",    "DDd",
+		  TRICORE_V1_1, NULL},
+  /* dvstep %en,%dx -> dvstep %en,%en,%dx  */
+  {"dvstep-Dd",   0, 1,  1, 0, 'D', 1,  0, 0, 'X', 0,  "dvstep",   "DDd",
+		  TRICORE_V1_1, NULL},
+  /* dvstep.u %en,%dx -> dvstep.u %en,%en,%dx  */
+  {"dvstep.u-Dd", 0, 1,  1, 0, 'D', 1,  0, 0, 'X', 0,  "dvstep.u", "DDd",
+		  TRICORE_V1_1, NULL},
+  /* j sdisp8 -> j sdisp24  */
+  {"j-R",         0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "j",        "O",
+		  TRICORE_GENERIC, NULL},
+  /* jeq %d15,%dn,zdisp4 -> jeq %d15,%dn,sdisp15  */
+  {"jeq-idm",     0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jeq",      "ddo",
+		  TRICORE_GENERIC, NULL},
+  /* jeq %d15,%dn,zdisp5 -> jeq %d15,%dn,sdisp15  */
+  {"jeq-idx",     0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jeq",      "ddo",
+  		  TRICORE_V1_3_UP, NULL},
+  /* jeq %d15,sconst4,zdisp4 -> jeq %d15,sconst4,sdisp15  */
+  {"jeq-i4m",     0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jeq",      "d4o",
+		  TRICORE_GENERIC, NULL},
+  /* jeq %d15,sconst4,zdisp5 -> jeq %d15,sconst4,sdisp15  */
+  {"jeq-i4x",     0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jeq",      "d4o",
+		  TRICORE_V1_3_UP, NULL},
+  /* jgez %dn,zdisp4 -> jge %dn,0,sdisp15  */
+  {"jgez-dm",     0, 1,  0, 0, '1', 1,  0, 0, 'X', 0,  "jge",      "d4o",
+		  TRICORE_GENERIC, NULL},
+  /* jgtz %dn,zdisp4 -> jge %dn,1,sdisp15  */
+  {"jgtz-dm",     0, 1,  0, 1, '1', 1,  0, 0, 'X', 0,  "jge",      "d4o",
+		  TRICORE_GENERIC, NULL},
+  /* jlez %dn,zdisp4 -> jlt %dn,1,sdisp15  */
+  {"jlez-dm",     0, 1,  0, 1, '1', 1,  0, 0, 'X', 0,  "jlt",      "d4o",
+		  TRICORE_GENERIC, NULL},
+  /* jltz %dn,zdisp4 -> jlt %dn,0,sdisp15  */
+  {"jltz-dm",     0, 1,  0, 0, '1', 1,  0, 0, 'X', 0,  "jlt",      "d4o",
+		  TRICORE_GENERIC, NULL},
+  /* jne %d15,%dn,zdisp4 -> jne %d15,%dn,sdisp15  */
+  {"jne-idm",     0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jne",      "ddo",
+		  TRICORE_GENERIC, NULL},
+  /* jne %d15,%dn,zdisp5 -> jne %d15,%dn,sdisp15  */
+  {"jne-idx",     0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jne",      "ddo",
+  		  TRICORE_V1_3_UP, NULL},
+  /* jne %d15,sconst4,zdisp4 -> jne %d15,sconst4,sdisp15  */
+  {"jne-i4m",     0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jne",      "d4o",
+		  TRICORE_GENERIC, NULL},
+  /* jne %d15,sconst4,zdisp5 -> jne %d15,sconst4,sdisp15  */
+  {"jne-i4x",     0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jne",      "d4o",
+  		  TRICORE_V1_3_UP, NULL},
+  /* jnz %dn,zdisp4 -> jne %dn,0,sdisp15  */
+  {"jnz-dm",      0, 1,  0, 0, '1', 1,  0, 0, 'X', 0,  "jne",      "d4o",
+		  TRICORE_GENERIC, NULL},
+  /* jnz %d15,sdisp8 -> jne %d15,0,sdisp15  */
+  {"jnz-iR",      0, 1,  0, 0, '1', 1,  0, 0, 'X', 0,  "jne",      "d4o",
+		  TRICORE_GENERIC, NULL},
+  /* jnz.a %an,zdisp4 -> jnz.a %an,sdisp15  */
+  {"jnz.a-am",    0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jnz.a",    "ao",
+		  TRICORE_GENERIC, NULL},
+  /* jnz.t %d15,zconst5,zdisp4 -> jnz.t %d15,zconst5,sdisp15  */
+  {"jnz.t-i5m",   0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jnz.t",    "d5o",
+		  TRICORE_V1_1, NULL},
+  /* jnz.t %d15,zconst4,zdisp4 -> jnz.t %d15,zconst5,sdisp15  */
+  {"jnz.t-ifm",   0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jnz.t",    "d5o",
+		  TRICORE_V1_2_UP, NULL},
+  /* jz %dn,zdisp4 -> jeq %dn,0,sdisp15  */
+  {"jz-dm",       0, 1,  0, 0, '1', 1,  0, 0, 'X', 0,  "jeq",      "d4o",
+		  TRICORE_GENERIC, NULL},
+  /* jz %d15,sdisp8 -> jeq %d15,0,sdisp15  */
+  {"jz-iR",       0, 1,  0, 0, '1', 1,  0, 0, 'X', 0,  "jeq",      "d4o",
+		  TRICORE_GENERIC, NULL},
+  /* jz.a %an,zdisp4 -> jz.a %an,sdisp15  */
+  {"jz.a-am",     0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jz.a",     "ao",
+		  TRICORE_GENERIC, NULL},
+  /* jz.t %d15,zconst5,zdisp4 -> jz.t %d15,zconst5,sdisp15  */
+  {"jz.t-i5m",    0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jz.t",     "d5o",
+		  TRICORE_V1_1, NULL},
+  /* jz.t %d15,zconst4,zdisp4 -> jz.t %d15,zconst5,sdisp15  */
+  {"jz.t-ifm",    0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "jz.t",     "d5o",
+		  TRICORE_V1_2_UP, NULL},
+  /* ld.a %an,[%am+] -> ld.a %an,[%am+]4  */
+  {"ld.a-a>",     0, 1,  0, 4, '6', 2,  0, 0, 'X', 0,  "ld.a",     "a>0",
+		  TRICORE_GENERIC, NULL},
+  /* ld.a %an,[%am] -> ld.a %an,[%am]0  */
+  {"ld.a-a@",     0, 1,  0, 0, '1', 2,  0, 0, 'X', 0,  "ld.a",     "a@w",
+		  TRICORE_GENERIC, NULL},
+  /* ld.b %dn,[%an+] -> ld.b %dn,[%an+]1  */
+  {"ld.b-d>",     0, 1,  0, 1, '1', 2,  0, 0, 'X', 0,  "ld.b",     "d>0",
+		  TRICORE_V1_1, NULL},
+  /* ld.b %dn,[%an] -> ld.b %dn,[%an]0  */
+  {"ld.b-d@",     0, 1,  0, 0, '1', 2,  0, 0, 'X', 0,  "ld.b",     "d@0",
+		  TRICORE_V1_1, NULL},
+  /* ld.bu %dn,[%an+] -> ld.bu %dn,[%an+]1  */
+  {"ld.bu-d>",    0, 1,  0, 1, '1', 2,  0, 0, 'X', 0,  "ld.bu",    "d>0",
+		  TRICORE_GENERIC, NULL},
+  /* ld.bu %dn,[%an] -> ld.bu %dn,[%an]0  */
+  {"ld.bu-d@",    0, 1,  0, 0, '1', 2,  0, 0, 'X', 0,  "ld.bu",    "d@0",
+		  TRICORE_GENERIC, NULL},
+  /* ld.h %dn,[%an+] -> ld.h %dn,[%an+]2  */
+  {"ld.h-d>",     0, 1,  0, 2, '6', 2,  0, 0, 'X', 0,  "ld.h",     "d>0",
+		  TRICORE_GENERIC, NULL},
+  /* ld.h %dn,[%an] -> ld.h %dn,[%an]0  */
+  {"ld.h-d@",     0, 1,  0, 0, '1', 2,  0, 0, 'X', 0,  "ld.h",     "d@0",
+		  TRICORE_GENERIC, NULL},
+  /* ld.w %dn,[%an+] -> ld.w %dn,[%an+]4  */
+  {"ld.w-d>",     0, 1,  0, 4, '6', 2,  0, 0, 'X', 0,  "ld.w",     "d>0",
+		  TRICORE_GENERIC, NULL},
+  /* ld.w %dn,[an] -> ld.w %dn,[%an]0  */
+  {"ld.w-d@",     0, 1,  0, 0, '1', 2,  0, 0, 'X', 0,  "ld.w",     "d@w",
+		  TRICORE_GENERIC, NULL},
+  /* loop %an,odisp4 -> loop %an,sdisp15  */
+  {"loop-ar",     0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "loop",     "ao",
+		  TRICORE_GENERIC, NULL},
+  /* mov %en,sconst4 -> mov %en,sconst16  */
+  {"mov-D4",      0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "mov",      "Dw",
+  		  TRICORE_V1_3_UP, NULL},
+  /* mov.a %an,zconst4 -> lea %an,abs10  */
+  {"mov.a-af",    0, 0,  0, 0, 'X', 0,  0, 0, 'X', 0,  "lea",      "at",
+		  TRICORE_V1_2_UP, NULL},
+  /* movz.a %an -> lea %an,0  */
+  {"movz.a-a",    0, 1,  0, 0, 't', 1,  0, 0, 'X', 0,  "lea",      "at",
+		  TRICORE_V1_1, NULL},
+  /* mul %dn,%dm -> mul %dn,%dn,%dm  */
+  {"mul-dd",      0, 1,  1, 0, 'd', 1,  0, 0, 'X', 0,  "mul",      "ddd",
+		  TRICORE_GENERIC, NULL},
+  /* nor/not %dn -> nor %dn,%dn,0  */
+  {"nor-d",       0, 2,  1, 0, 'd', 1,  0, 0, '1', 2,  "nor",      "ddn",
+		  TRICORE_GENERIC, NULL},
+  /* or %dn,%dm -> or %dn,%dn,%dx  */
+  {"or-dd",       0, 1,  1, 0, 'd', 1,  0, 0, 'X', 0,  "or",       "ddd",
+		  TRICORE_GENERIC, NULL},
+  /* or %d15,zconst8 -> or %d15,%d15,zconst9  */
+  {"or-i8",       0, 1,  1, 0, 'i', 1,  0, 0, 'X', 0,  "or",       "ddn",
+		  TRICORE_GENERIC, NULL},
+  /* rsub %dn -> rsub %dn,%dn,0  */
+  {"rsub-d",      0, 2,  1, 0, 'd', 1,  0, 0, '1', 2,  "rsub",     "dd9",
+		  TRICORE_GENERIC, NULL},
+  /* sat.b %dn -> sat.b %dn,%dn  */
+  {"sat.b-d",     0, 1,  1, 0, 'd', 1,  0, 0, 'X', 0,  "sat.b",    "dd",
+		  TRICORE_GENERIC, NULL},
+  /* sat.bu %dn -> sat.bu %dn,%dn  */
+  {"sat.bu-d",    0, 1,  1, 0, 'd', 1,  0, 0, 'X', 0,  "sat.bu",   "dd",
+		  TRICORE_GENERIC, NULL},
+  /* sat.h %dn -> sat.h %dn,%dn  */
+  {"sat.h-d",     0, 1,  1, 0, 'd', 1,  0, 0, 'X', 0,  "sat.h",    "dd",
+		  TRICORE_GENERIC, NULL},
+  /* sat.hu %dn -> sat.hu %dn,%dn  */
+  {"sat.hu-d",    0, 1,  1, 0, 'd', 1,  0, 0, 'X', 0,  "sat.hu",   "dd",
+		  TRICORE_GENERIC, NULL},
+  /* sh %dn,sconst4 -> sh %dn,%dn,sconst9  */
+  {"sh-d4",       0, 1,  1, 0, 'd', 1,  0, 0, 'X', 0,  "sh",       "dd9",
+		  TRICORE_GENERIC, NULL},
+  /* sha %dn,sconst4 -> sha %dn,%dn,sconst9  */
+  {"sha-d4",      0, 1,  1, 0, 'd', 1,  0, 0, 'X', 0,  "sha",      "dd9",
+		  TRICORE_GENERIC, NULL},
+  /* st.a [%an+],%am -> st.a [%an+]4,%am  */
+  {"st.a->a",     0, 1,  0, 4, '6', 1,  0, 0, 'X', 0,  "st.a",     ">0a",
+		  TRICORE_GENERIC, NULL},
+  /* st.a [%an],%am -> st.a [%an]0,%am  */
+  {"st.a-@a",     0, 1,  0, 0, '1', 1,  0, 0, 'X', 0,  "st.a",     "@0a",
+		  TRICORE_GENERIC, NULL},
+  /* st.b [%an+],%dn -> st.b [%an+]1,%dn  */
+  {"st.b->d",     0, 1,  0, 1, '1', 1,  0, 0, 'X', 0,  "st.b",     ">0d",
+		  TRICORE_GENERIC, NULL},
+  /* st.b [%an],%dn -> st.b [%an]0,%dn  */
+  {"st.b-@d",     0, 1,  0, 0, '1', 1,  0, 0, 'X', 0,  "st.b",     "@0d",
+		  TRICORE_GENERIC, NULL},
+  /* st.h [%an+],%dn -> st.h [%an+]2,%dn  */
+  {"st.h->d",     0, 1,  0, 2, '6', 1,  0, 0, 'X', 0,  "st.h",     ">0d",
+		  TRICORE_GENERIC, NULL},
+  /* st.h [%an],%dn -> st.h [%an]0,%dn  */
+  {"st.h-@d",     0, 1,  0, 0, '1', 1,  0, 0, 'X', 0,  "st.h",     "@0d",
+		  TRICORE_GENERIC, NULL},
+  /* st.w [%an+],%dn -> st.w [%an+]4,%dn  */
+  {"st.w->d",     0, 1,  0, 4, '6', 1,  0, 0, 'X', 0,  "st.w",     ">0d",
+		  TRICORE_GENERIC, NULL},
+  /* st.w [%an],%dn -> st.w [%an]0,%dn  */
+  {"st.w-@d",     0, 1,  0, 0, '1', 1,  0, 0, 'X', 0,  "st.w",     "@wd",
+		  TRICORE_GENERIC, NULL},
+  /* sub %dn,%dm -> sub %dn,%dn,%dm  */
+  {"sub-dd",      0, 1,  1, 0, 'd', 1,  0, 0, 'X', 0,  "sub",      "ddd",
+		  TRICORE_GENERIC, NULL},
+  /* sub.a %sp,zconst8 -> lea %sp,[%sp]-sconst16  */
+  {"sub.a-P8",    1, 1,  1, 0, '@', 1,  0, 0, 'X', 0,  "lea",      "a@w",
+		  TRICORE_GENERIC, NULL},
+  /* subs %dn,%dm -> subs %dn,%dn,%dm  */
+  {"subs-dd",     0, 1,  1, 0, 'd', 1,  0, 0, 'X', 0,  "subs",     "ddd",
+		  TRICORE_GENERIC, NULL},
+  /* xor %dn,%dm -> xor %dn,%dn,%dm  */
+  {"xor-dd",      0, 1,  1, 0, 'd', 1,  0, 0, 'X', 0,  "xor",      "ddd",
+		  TRICORE_V1_2_UP, NULL}
+};
+
+static const int num_insn16 = sizeof insn16_table / sizeof insn16_table[0];
+static struct htab *hash_insn16 = NULL;
+
+/* This is used to convert 32-bit to 16-bit insns (aka optimizing).  */
+
+typedef struct _conv_t
+{
+  int test;			/* Number of test to apply to this insn.  */
+  const char *new_name;		/* Name of equivalent 16-bit insn.  */
+  const char *new_args;		/* Operand types of equivalent 16-bit insn.  */
+  opcode_t *new_code;		/* Pointer to equivalent 16-bit insn.  */
+} conv_t;
+
+typedef struct _insn32_t
+{
+  const char *name;		/* Name and operand types of 32-bit insn.  */
+  int nr_alt;			/* Number of alternatives for this insn.  */
+  conv_t alt[2];		/* Description of the 16-bit alternatives.  */
+  tricore_isa isa;		/* Applicable instruction set architecture.  */
+} insn32_t;
+
+static insn32_t insn32_table[] =
+{
+#define NO_ALTERNATIVE { 0, NULL,       NULL,  NULL }
+  {"add-ddd",      1, {{ 1, "add",      "dd",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"add-dd9",      1, {{ 2, "add",      "d4",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"add.a-aaa",    1, {{ 1, "add.a",    "aa",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_V1_2_UP},
+  {"adds-ddd",     1, {{ 1, "adds",     "dd",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"addsc.a-aad2", 1, {{ 1, "addsc.a",  "ad2", NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_V1_1},
+  {"and-ddd",      1, {{ 1, "and",      "dd",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"and-ddn",      1, {{ 3, "and",      "i8",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"cadd-dddd",    1, {{ 4, "cadd",     "did", NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_V1_1},
+  {"cadd-ddd9",    1, {{ 5, "cadd",     "di4", NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"caddn-dddd",   1, {{ 4, "caddn",    "did", NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_V1_1},
+  {"caddn-ddd9",   1, {{ 5, "caddn",    "di4", NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"dvadj-DDd",    1, {{ 1, "dvadj",    "Dd",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_V1_1},
+  {"dvstep-DDd",   1, {{ 1, "dvstep",   "Dd",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_V1_1},
+  {"dvstep.u-DDd", 1, {{ 1, "dvstep.u", "Dd",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_V1_1},
+  {"jeq-d4o",      2, {{ 6, "jz",       "iR",  NULL },
+		       { 7, "jz",       "dm",  NULL }}, TRICORE_GENERIC},
+  {"jge-d4o",      2, {{ 8, "jgtz",     "dm",  NULL },
+		       { 7, "jgez",     "dm",  NULL }}, TRICORE_GENERIC},
+  {"jlt-d4o",      2, {{ 8, "jlez",     "dm",  NULL },
+		       { 7, "jltz",     "dm",  NULL }}, TRICORE_GENERIC},
+  {"jne-d4o",      2, {{ 6, "jnz",      "iR",  NULL },
+		       { 7, "jnz",      "dm",  NULL }}, TRICORE_GENERIC},
+  {"ld.a-a>0",     1, {{ 9, "ld.a",     "a>",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"ld.a-a@w",     1, {{10, "ld.a",     "a@",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"ld.b-d>0",     1, {{11, "ld.b",     "d>",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_V1_1},
+  {"ld.b-d@0",     1, {{10, "ld.b",     "d@",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_V1_1},
+  {"ld.bu-d>0",    1, {{11, "ld.bu",    "d>",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"ld.bu-d@0",    1, {{10, "ld.bu",    "d@",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"ld.h-d>0",     1, {{12, "ld.h",     "d>",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"ld.h-d@0",     1, {{10, "ld.h",     "d@",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"ld.w-d>0",     1, {{ 9, "ld.w",     "d>",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"ld.w-d@w",     1, {{10, "ld.w",     "d@",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"lea-at",       1, {{13, "movz.a",   "a",   NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_V1_1},
+  {"lea-at",       1, {{21, "mov.a",    "af",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_V1_2_UP},
+  {"lea-a@w",      1, {{14, "sub.a",    "P8",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_V1_1},
+  {"lea-a@w",      2, {{14, "sub.a",    "P8",  NULL },
+		       {22, "add.a",    "a4",  NULL }}, TRICORE_V1_2_UP},
+  {"mul-ddd",      1, {{ 1, "mul",      "dd",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"nor-ddn",      1, {{15, "nor",      "d",   NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"or-ddd",       1, {{ 1, "or",       "dd",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"or-ddn",       1, {{ 3, "or",       "i8",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"rsub-dd9",     1, {{15, "rsub",     "d",   NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"sat.b-dd",     1, {{ 1, "sat.b",    "d",   NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"sat.h-dd",     1, {{ 1, "sat.h",    "d",   NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"sat.bu-dd",    1, {{ 1, "sat.bu",   "d",   NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"sat.hu-dd",    1, {{ 1, "sat.hu",   "d",   NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"sel-dddd",     1, {{16, "cmov",     "did", NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"sel-ddd9",     1, {{ 5, "cmovn",    "di4", NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"seln-dddd",    1, {{16, "cmovn",    "did", NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"seln-ddd9",    1, {{ 5, "cmov",     "di4", NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"sh-dd9",       1, {{ 2, "sh",       "d4",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"sha-dd9",      1, {{ 2, "sha",      "d4",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"st.a->0a",     1, {{17, "st.a",     ">a",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"st.a-@0a",     1, {{18, "st.a",     "@a",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"st.b->0d",     1, {{19, "st.b",     ">d",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"st.b-@0d",     1, {{18, "st.b",     "@d",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"st.h->0d",     1, {{20, "st.h",     ">d",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"st.h-@0d",     1, {{18, "st.h",     "@d",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"st.w->0d",     1, {{17, "st.w",     ">d",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"st.w-@wd",     1, {{18, "st.w",     "@d",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"sub-ddd",      1, {{ 1, "sub",      "dd",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"subs-ddd",     1, {{ 1, "subs",     "dd",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_GENERIC},
+  {"xor-ddd",      1, {{ 1, "xor",      "dd",  NULL },
+		       NO_ALTERNATIVE		    },  TRICORE_V1_2_UP}
+#undef NO_ALTERNATIVE
+};
+
+static const int num_insn32 = sizeof insn32_table / sizeof insn32_table[0];
+static struct htab *hash_insn32 = NULL;
+
+/* This table is used for relaxing.  Each entry consists of 4 numbers:
+
+   - the highest displacement reachable from the end of the base insn,
+   - the lowest displacement reachable from the end of the base insn,
+   - the number of bytes this displacement adds to the base insn, and
+   - the entry number to use if the target address is out of reach for
+     this insn (0 indicates that this is the last entry for this mode).
+
+   If a 16-bit PC-relative call or jump instruction can't reach its
+   target due to its limited range, we're converting it to its 32-bit
+   equivalent, which can reach targets within a +/-32KB range.  If that's
+   still not sufficient, we're reversing the condition code (if any) and
+   modify the instruction to branch over the 32-bit unconditional jump
+   instruction we're inserting right after it, which extends the range
+   to the maximum possible on the TriCore (+/-16MB).  However, that's
+   only the maximum possible range for calls and jumps to _local_ labels
+   (which thus restricts the size of an object's text segment), as the
+   linker (i.e., tricore-ld) is also able to relax "j", "jl", "fcall" and
+   "call" instructions targeting global labels, enabling them to reach
+   any valid address within TriCore's entire 4GB address space.
+
+   We're also relaxing PCP's "jc" and "jl" instructions; if necessary,
+   they'll be turned into "jc.a" instructions, which can reach any valid
+   address within PCP's 128KB code address space ("PCODE").  */
+
+const relax_typeS md_relax_table[] =
+{
+  /* SB -> BRC  */
+#define RELAX_SB     (relax_substateT) 0
+  {  252,   -258, 0, RELAX_SB + 1},
+  {32764, -32770, 2, RELAX_SB + 2},
+  {    1,      1, 4, 0},
+
+  /* SB -> B  */
+#define RELAX_SB2    (relax_substateT) 3
+  {  252,   -258, 0, RELAX_SB2 + 1},
+  {    1,      1, 2, 0},
+
+  /* SBC -> BRC  */
+#define RELAX_SBC    (relax_substateT) 5
+  {   28,     -2, 0, RELAX_SBC + 1},
+  {32764, -32770, 2, RELAX_SBC + 2},
+  {    1,      1, 4, 0},
+
+  /* SBC2 -> BRC  */
+#define RELAX_SBC2   (relax_substateT) 8
+  {   60,     -2, 0, RELAX_SBC2 + 1},
+  {32764, -32770, 2, RELAX_SBC2 + 2},
+  {    1,      1, 4, 0},
+
+  /* SBR -> BRR/BRC  */
+#define RELAX_SBR    (relax_substateT) 11
+  {   28,     -2, 0, RELAX_SBR + 1},
+  {32764, -32770, 2, RELAX_SBR + 2},
+  {    1,      1, 4, 0},
+
+  /* SBR2 -> BRR  */
+#define RELAX_SBR2   (relax_substateT) 14
+  {   60,     -2, 0, RELAX_SBR2 + 1},
+  {32764, -32770, 2, RELAX_SBR2 + 2},
+  {    1,      1, 4, 0},
+
+  /* SBRN -> BRN  */
+#define RELAX_SBRN   (relax_substateT) 17
+  {   28,     -2, 0, RELAX_SBRN + 1},
+  {32764, -32770, 2, RELAX_SBRN + 2},
+  {    1,      1, 4, 0},
+
+  /* SBR special case: loop  */
+#define RELAX_LOOP   (relax_substateT) 20
+  {   -4,    -34, 0, RELAX_LOOP + 1},
+  {32764, -32770, 2, RELAX_LOOP + 2},
+  {    1,      1, 8, 0},
+
+  /* BRR/BRC -> additional j instruction  */
+#define RELAX_BRX    (relax_substateT) 23
+  {32762, -32772, 0, RELAX_BRX + 1},
+  {    1,      1, 4, 0},
+
+  /* BRN -> additional j instruction  */
+#define RELAX_BRN    (relax_substateT) 25
+  {32762, -32772, 0, RELAX_BRN + 1},
+  {    1,      1, 4, 0},
+
+  /* BRR/BRC special cases: jned/jnei, additional 16-bit j instruction  */
+#define RELAX_JNEX   (relax_substateT) 27
+  {32762, -32772, 0, RELAX_JNEX + 1},
+  {    1,      1, 6, 0},
+
+  /* BRN/BRC special cases: jned/jnei, additional 32-bit j instruction  */
+#define RELAX_JNEX2  (relax_substateT) 29
+  {32762, -32772, 0, RELAX_JNEX2 + 1},
+  {    1,      1, 8, 0},
+
+  /* BRR special case: loop, additional 16-bit j instruction  */
+#define RELAX_BLOOP  (relax_substateT) 31
+  {32762, -32772, 0, RELAX_BLOOP + 1},
+  {    1,      1, 6, 0},
+ 
+  /* BRR special case: loop, additional 32-bit j instruction  */
+#define RELAX_BLOOP2 (relax_substateT) 33
+  {32762, -32772, 0, RELAX_BLOOP2 + 1},
+  {    1,      1, 8, 0},
+ 
+  /* BRR special case: loopu, replaced by a j instruction  */
+#define RELAX_LOOPU  (relax_substateT) 35
+  {32762, -32772, 0, RELAX_LOOPU + 1},
+  {    1,      1, 0, 0},
+
+  /* PCP: jc -> jc.a  */
+#define RELAX_JC     (relax_substateT) 37
+  {   62,    -64, 0, RELAX_JC + 1},
+  {    1,      1, 2, 0},
+
+  /* PCP: jl -> jc.a  */
+#define RELAX_JL     (relax_substateT) 39
+  { 1022,  -1024, 0, RELAX_JL + 1},
+  {    1,      1, 2, 0}
+};
+
+/* Relaxing of "loop" and "loopu" instructions needs special treatment:
+   the 16-bit "loop" instruction can only reach targets that are between
+   -2 and -32 bytes away, so we need to switch to the 32-bit variant if
+   the displacement is zero.  Second, "loopu" needs being replaced by a
+   "j" instruction if the target is more than +/- 32KB away, but since both
+   are 32-bit insns, the frag size won't grow, which also means that
+   write.c:relax_frag won't switch to the next state.  Both special cases
+   are handled by the macro tc-tricore.h:md_prepare_relax_scan, but we need
+   to export the initial relaxation states for these instructions, as the
+   macro will be evaluated in the context of write.c:relax_frag, and thus
+   can't access local variables defined in this module.  */
+
+relax_substateT tricore_relax_loop_state = RELAX_LOOP;
+relax_substateT tricore_relax_loopu_state = RELAX_LOOPU;
+
+/* These variables hold the opcode of relaxable 16-bit instructions.  */
+
+static unsigned char tricore_insn_j_R = 0x3c;
+static unsigned char tricore_insn_call_R = 0x5c;
+static unsigned char tricore_insn_jnz_iR = 0xee;
+static unsigned char tricore_insn_jz_iR = 0x6e;
+static unsigned char tricore_insn_loop_ar = 0xfc;
+static unsigned char tricore_insn_jeq_idm = 0x3e;
+static unsigned char tricore_insn_jeq_idx = 0xbe;
+static unsigned char tricore_insn_jne_idm = 0x7e;
+static unsigned char tricore_insn_jne_idx = 0xfe;
+static unsigned char tricore_insn_jgez_dm = 0xce;
+static unsigned char tricore_insn_jgtz_dm = 0x4e;
+static unsigned char tricore_insn_jlez_dm = 0x8e;
+static unsigned char tricore_insn_jltz_dm = 0x0e;
+static unsigned char tricore_insn_jnz_dm = 0xf6;
+static unsigned char tricore_insn_jnza_am = 0x7c;
+static unsigned char tricore_insn_jz_dm = 0x76;
+static unsigned char tricore_insn_jza_am = 0xbc;
+static unsigned char tricore_insn_jeq_i4m = 0x1e;
+static unsigned char tricore_insn_jne_i4m = 0x5e;
+static unsigned char tricore_insn_jeq_i4x = 0x9e;
+static unsigned char tricore_insn_jne_i4x = 0xde;
+static unsigned char tricore_insn_jnzt_i5m = 0x00;
+static unsigned char tricore_insn_jnzt_ifm = 0xae;
+static unsigned char tricore_insn_jzt_i5m = 0x00;
+static unsigned char tricore_insn_jzt_ifm = 0x2e;
+
+/* These variables hold the opcode of relaxable 32-bit instructions.  */
+
+static unsigned char tricore_insn_j_O = 0x1d;
+static unsigned char tricore_insn_jge_ddo = 0x7f;
+static unsigned char tricore_insn_jgeu_ddo = 0x7f;
+static unsigned char tricore_insn_jge_d4o = 0xff;
+static unsigned char tricore_insn_jgeu_dfo = 0xff;
+static unsigned char tricore_insn_jlt_ddo = 0x3f;
+static unsigned char tricore_insn_jltu_ddo = 0x3f;
+static unsigned char tricore_insn_jlt_d4o = 0xbf;
+static unsigned char tricore_insn_jltu_dfo = 0xbf;
+static unsigned char tricore_insn_jeq_ddo = 0x5f;
+static unsigned char tricore_insn_jne_ddo = 0x5f;
+static unsigned char tricore_insn_jeq_d4o = 0xdf;
+static unsigned char tricore_insn_jne_d4o = 0xdf;
+static unsigned char tricore_insn_jeqa_aao = 0x7d;
+static unsigned char tricore_insn_jnea_aao = 0x7d;
+static unsigned char tricore_insn_jnei_ddo = 0x1f;
+static unsigned char tricore_insn_jned_ddo = 0x1f;
+static unsigned char tricore_insn_jnei_d4o = 0x9f;
+static unsigned char tricore_insn_jned_d4o = 0x9f;
+static unsigned char tricore_insn_jza_ao = 0xbd;
+static unsigned char tricore_insn_jnza_ao = 0xbd;
+static unsigned char tricore_insn_jzt_d5o = 0x6f;
+static unsigned char tricore_insn_jnzt_d5o = 0x6f;
+static unsigned char tricore_insn_loop_ao = 0xfd;
+
+/* Temporary line buffer (malloc()ed), and its current length.  */
+
+static char *insnline;
+static size_t insnline_len;
+
+/* md_begin initializes the TriCore-specific part of gas.  It is
+   called after md_parse_option, but prior to any other function
+   of this module.  */
+
+void
+md_begin()
+{
+  register int opind, hopind, i;
+  register void **retval;
+  register opcode_t *pop, *hpop;
+  register pcp_opcode_t *ppop, *hppop;
+  register sfr_t *psfr;
+  register insn16_t *pinsn16;
+  register insn32_t *pinsn32;
+  register conv_t *palt;
+  unsigned long mach;
+
+  if (show_internals)
+    printf ("*** md_begin()\n");
+
+  /* Initialize ISA-specific variables.  */
+
+  switch (current_isa & TRICORE_ISA_MASK)
+    {
+    case TRICORE_V1_1:
+      mach = bfd_mach_tricore_v1_1;
+      tricore_insn_j_R = 0x5c;
+      tricore_insn_call_R = 0x00;
+      tricore_insn_jnz_iR = 0xae;
+      tricore_insn_jz_iR = 0x2e;
+      tricore_insn_loop_ar = 0xfc;
+      tricore_insn_jeq_idm = 0x1e;
+      tricore_insn_jne_idm = 0x9e;
+      tricore_insn_jgez_dm = 0xfe;
+      tricore_insn_jgtz_dm = 0x7e;
+      tricore_insn_jlez_dm = 0xbe;
+      tricore_insn_jltz_dm = 0x3e;
+      tricore_insn_jnz_dm = 0xde;
+      tricore_insn_jnza_am = 0x7c;
+      tricore_insn_jz_dm = 0x5e;
+      tricore_insn_jza_am = 0xbc;
+      tricore_insn_jeq_i4m = 0x6e;
+      tricore_insn_jne_i4m = 0xee;
+      tricore_insn_jnzt_i5m = 0x4e;
+      tricore_insn_jnzt_ifm = 0x00;
+      tricore_insn_jzt_i5m = 0x0e;
+      tricore_insn_jzt_ifm = 0x00;
+      break;
+
+    case TRICORE_V1_2:  
+      mach = bfd_mach_tricore_v1_2;
+      break;
+
+    case TRICORE_V1_3:
+      mach = bfd_mach_tricore_v1_3;
+      tricore_insn_jeq_idx = 0xbe;
+      tricore_insn_jne_idx = 0xfe;
+      tricore_insn_jeq_i4x = 0x9e;
+      tricore_insn_jne_i4x = 0xde;
+      break;
+
+    default:
+      as_fatal (_("Illegal architecture %d"),
+      		(current_isa & TRICORE_ISA_MASK));
+    }
+  tricore_init_arch_vars (mach);
+
+  /* Create the various hash tables.  */
+
+  hash_ops = htab_create_alloc (NUMOPCODES, hash_string_tuple, eq_string_tuple, NULL, xcalloc, xfree);
+  if (hash_ops == NULL)
+	as_fatal (_("Cannot create hash tables"));
+
+  hash_sfr = htab_create_alloc (NUMSFRS, hash_string_tuple, eq_string_tuple, NULL, xcalloc, xfree);
+  if (hash_sfr == NULL)
+	as_fatal (_("Cannot create hash tables"));
+
+  hash_pcp = htab_create_alloc (NUMPCPOPCODES, hash_string_tuple, eq_string_tuple, NULL, xcalloc, xfree);
+  if (hash_pcp == NULL)
+	as_fatal (_("Cannot create hash tables"));
+
+  hash_insn16 = htab_create_alloc (num_insn16, hash_string_tuple, eq_string_tuple, NULL, xcalloc, xfree);
+  if (hash_insn16 == NULL)
+	as_fatal (_("Cannot create hash tables"));
+
+  hash_insn32 = htab_create_alloc (num_insn32, hash_string_tuple, eq_string_tuple, NULL, xcalloc, xfree);
+  if (hash_insn32 == NULL)
+	as_fatal (_("Cannot create hash tables"));
+
+  /* Populate the opcode hash table.  */
+
+  pop = tricore_opcodes;
+  for (opind = 0; opind < NUMOPCODES; ++opind)
+    {
+      hpop = pop; hopind = opind;
+      retval = str_hash_insert (hash_ops, pop->name, pop, 0);
+
+      if (retval && *retval)
+        as_fatal (_("Cannot hash %s"), pop->name);
+      while ((++hopind != NUMOPCODES) && !strcmp ((++hpop)->name, pop->name))
+        /* Empty.  */;
+      pop->insind = opind;
+      pop->inslast = --hopind;
+      pop = hpop;
+      opind = hopind;
+    }
+
+  /* Populate the PCP opcode hash table.  */
+
+  ppop = pcp_opcodes;
+  for (opind = 0; opind < NUMPCPOPCODES; ++opind)
+    {
+      hppop = ppop; hopind = opind;
+	  retval = str_hash_insert (hash_pcp, ppop->name, ppop, 0);
+      if (retval && *retval)
+        as_fatal (_("Cannot hash %s"), ppop->name);
+      while ((++hopind != NUMPCPOPCODES)
+             && !strcmp ((++hppop)->name, ppop->name))
+	/* Empty.  */;
+      ppop->insind = opind;
+      ppop->inslast = --hopind;
+      ppop = hppop;
+      opind = hopind;
+    }
+
+  /* Populate the SFR hash table.  */
+
+  psfr = tricore_sfrs;
+  for (opind = 0; opind < NUMSFRS; ++opind, ++psfr)
+    if (MATCHES_ISA (psfr->isa))
+      {
+		retval = str_hash_insert (hash_sfr, psfr->name, psfr, 0);
+        if (retval && *retval)
+          as_fatal (_("Cannot hash %s"), psfr->name);
+      }
+
+  /* Populate the 16->32-bit-insn-conversion hash table.  */
+
+  pinsn16 = insn16_table;
+  for (opind = 0; opind < num_insn16; ++opind, ++pinsn16)
+    {
+      if (!MATCHES_ISA (pinsn16->isa))
+        continue;
+	  retval = str_hash_insert (hash_insn16, pinsn16->name, pinsn16, 0);
+
+      if (retval && *retval)
+        as_fatal (_("Cannot hash %s"), pinsn16->name);
+      pop = (opcode_t *) str_hash_find (hash_ops, pinsn16->new_name);
+      if ((hpop = pop) == NULL)
+        as_fatal (_("Internal error: couldn't find `%s'"), pinsn16->new_name);
+      for (hopind = hpop->insind; hopind <= hpop->inslast; ++hopind, ++pop)
+        if (pop->len32 && MATCHES_ISA (pop->isa)
+	    && !strcmp (pop->args, pinsn16->new_args))
+	  {
+	    pinsn16->new_code = pop;
+	    break;
+	  }
+      if (pinsn16->new_code == NULL)
+        as_fatal (_("Internal error: couldn't init `%s'"), pinsn16->name);
+    }
+
+  /* Populate the 32->16-bit-insn-conversion hash table.  */
+
+  pinsn32 = insn32_table;
+  for (opind = 0; opind < num_insn32; ++opind, ++pinsn32)
+    {
+      if (!MATCHES_ISA (pinsn32->isa))
+        continue;
+	  
+	  retval = str_hash_insert (hash_insn32, pinsn32->name, pinsn32, 0);
+
+      if (retval && *retval)
+        as_fatal (_("Cannot hash %s"), pinsn32->name);
+      for (i = 0; i < pinsn32->nr_alt; ++i)
+        {
+	  palt = &pinsn32->alt[i];
+	  pop = (opcode_t *) str_hash_find (hash_ops, palt->new_name);
+	  if ((hpop = pop) == NULL)
+	    as_fatal (_("Internal error: couldn't find `%s'"), palt->new_name);
+	  for (hopind = hpop->insind; hopind <= hpop->inslast; ++hopind, ++pop)
+	    if (!pop->len32 && MATCHES_ISA (pop->isa)
+	        && !strcmp (pop->args, palt->new_args))
+	      {
+	        palt->new_code = pop;
+		break;
+	      }
+	  if (palt->new_code == NULL)
+	    as_fatal (_("Internal error: couldn't init `%s'"), pinsn32->name);
+	}
+    }
+
+  /* Perform sanity checks if in debug mode.  */
+
+  if (show_internals)
+    check_insn_tables ();
+ 
+  /* Initialize the "operand compatibility matrix".  */
+
+  for (opind = 0; opind < 256; ++opind)
+    pseudo_codes[opind] = NULL;
+	pseudo_codes['d'] = (char *) "di";
+	pseudo_codes['g'] = (char *) "g";
+	pseudo_codes['G'] = (char *) "G";
+	pseudo_codes['-'] = (char *) "-";
+	pseudo_codes['+'] = (char *) "+";
+	pseudo_codes['l'] = (char *) "l";
+	pseudo_codes['L'] = (char *) "L";
+	pseudo_codes['D'] = (char *) "D";
+	pseudo_codes['i'] = (char *) "i";
+	pseudo_codes['a'] = (char *) "aAIP";
+	pseudo_codes['A'] = (char *) "AP";
+	pseudo_codes['I'] = (char *) "I";
+	pseudo_codes['P'] = (char *) "P";
+	pseudo_codes['c'] = (char *) "cU123f5v68nqW";
+	pseudo_codes['1'] = (char *) "1U";
+	pseudo_codes['2'] = (char *) "2U1";
+	pseudo_codes['3'] = (char *) "3U12";
+	pseudo_codes['4'] = (char *) "4U123";
+	pseudo_codes['f'] = (char *) "fU123";
+	pseudo_codes['5'] = (char *) "5U123fvmx";
+	pseudo_codes['F'] = (char *) "FU1234f";
+	pseudo_codes['v'] = (char *) "vU123fm";
+	pseudo_codes['6'] = (char *) "6U123f5vmx";
+	pseudo_codes['8'] = (char *) "8U123f5v6mx";
+	pseudo_codes['9'] = (char *) "9U1234f5Fv68mxrR";
+	pseudo_codes['n'] = (char *) "nU123f5v68mx";
+	pseudo_codes['k'] = (char *) "kU123f5v68nmx";
+	pseudo_codes['0'] = (char *) "0U1234f5Fv689nmxrR";
+	pseudo_codes['q'] = (char *) "qU123f5v68nk";
+	pseudo_codes['w'] = (char *) "wU1234f5Fv689nk0qmxrRo";
+	pseudo_codes['W'] = (char *) "WU123f5v68nkqmx";
+	pseudo_codes['M'] = (char *) "MU1234f5Fv689nk0qwWmxrRoO";
+	pseudo_codes['m'] = (char *) "mU123fv";
+	pseudo_codes['x'] = (char *) "xU123m";
+	pseudo_codes['r'] = (char *) "rUF4";
+	pseudo_codes['R'] = (char *) "RU1234f5Fv689mxr";
+	pseudo_codes['o'] = (char *) "oU1234f5Fv689nk0qwmxrR";
+	pseudo_codes['O'] = (char *) "OU1234f5Fv689nk0qwWmxrRo";
+	pseudo_codes['t'] = (char *) "tU1234f5Fv689nk0qwWMmxrRoO";
+	pseudo_codes['T'] = (char *) "TU1234f5Fv689nk0qwWMmxrRoOt";
+	pseudo_codes['U'] = (char *) "U";
+	pseudo_codes['@'] = (char *) "@S&";
+	pseudo_codes['&'] = (char *) "&";
+	pseudo_codes['<'] = (char *) "<";
+	pseudo_codes['>'] = (char *) ">";
+	pseudo_codes['*'] = (char *) "*";
+	pseudo_codes['#'] = (char *) "#";
+	pseudo_codes['?'] = (char *) "?";
+	pseudo_codes['S'] = (char *) "S";
+
+  /* Allocate memory for the temporary line buffer.  */
+
+  insnline = xmalloc (INITIAL_INSNLINELENGTH);
+  insnline_len = INITIAL_INSNLINELENGTH;
+
+  /* Set optimization flag.  */
+
+  optimize_next = optimize;
+
+  /* Make sure the text, data and bss sections are properly aligned.  */
+
+  (void) bfd_set_section_alignment (text_section, 1);
+  if (current_isa == TRICORE_V1_3)
+    {
+      /* FIXME: quad-word objects must be aligned to 2**4, which probably
+         means that we should dedicate one or more separate sections to
+	 them -- just to avoid wasting precious memory due to alignment
+	 restrictions when linking the final program.  However, I'm not
+	 sure whether this can (or should) be handled automatically by
+	 the assembler.  Come to think of it, I'm rather against it.  */
+      (void) bfd_set_section_alignment ( data_section, 1);
+      (void) bfd_set_section_alignment ( bss_section, 1);
+    }
+  else
+    {
+      (void) bfd_set_section_alignment ( data_section, 3);
+      (void) bfd_set_section_alignment ( bss_section, 3);
+    }
+}
+
+/* Check whether the tables for 16/32-bit insn conversions are OK.
+   However, we can only test the correctness of the name-operand
+   combo of the source insns (the correctness of the target insns
+   is tested in md_begin, though).  This function is only called
+   if show_internals is set, and thus only used for debugging.  */ 
+
+static void
+check_insn_tables ()
+{
+  insn16_t *pinsn16;
+  insn32_t *pinsn32;
+  opcode_t *pop, *hpop;
+  int opind, hopind;
+  char name[30], *cp;
+
+  pinsn16 = insn16_table;
+  for (opind = 0; opind < num_insn16; ++opind, ++pinsn16)
+    {
+      if (!MATCHES_ISA (pinsn16->isa))
+        continue;
+
+      strcpy (name, pinsn16->name);
+      if ((cp = strchr (name, '-')) == NULL)
+        as_fatal (_("Internal error: insn16_table is broken"));
+      *cp++ = '\0';
+      pop = (opcode_t *) str_hash_find (hash_ops, name);
+      if ((hpop = pop) == NULL)
+        as_fatal (_("Internal error: can't find `%s' (insn16_table)"), name);
+      for (hopind = hpop->insind; hopind <= hpop->inslast; ++hopind, ++pop)
+        if (!pop->len32 && MATCHES_ISA (pop->isa) && !strcmp (pop->args, cp))
+	  break;
+      if (hopind > hpop->inslast)
+        as_fatal (_("Internal error: can't find `%s' (insn16_table)"),
+		  pinsn16->name);
+      if ((pinsn16->nr_inserts < 0) || (pinsn16->nr_inserts > 2))
+        as_fatal (_("Internal error: too many inserts for `%s'"),
+		  pinsn16->name);
+    }
+
+  pinsn32 = insn32_table;
+  for (opind = 0; opind < num_insn32; ++opind, ++pinsn32)
+    {
+      if (!MATCHES_ISA (pinsn32->isa))
+        continue;
+
+      strcpy (name, pinsn32->name);
+      if ((cp = strchr (name, '-')) == NULL)
+        as_fatal (_("Internal error: insn32_table is broken"));
+      *cp++ = '\0';
+      pop = (opcode_t *) str_hash_find (hash_ops, name);
+      if ((hpop = pop) == NULL)
+        as_fatal (_("Internal error: can't find `%s' (insn32_table)"), name);
+      for (hopind = hpop->insind; hopind <= hpop->inslast; ++hopind, ++pop)
+        if (pop->len32 && MATCHES_ISA (pop->isa) && !strcmp (pop->args, cp))
+	  break;
+      if (hopind > hpop->inslast)
+        as_fatal (_("Internal error: can't find `%s' (insn32_table)"),
+		  pinsn32->name);
+    }
+}
+
+/* Handle TriCore-specific assembler options and flags passed on
+   the command line.  */
+
+int
+md_parse_option (int c, const char *arg)
+{
+  switch (c)
+    {
+    case 'a': /* listing option(s); apply standard treatment.  */
+      return 0;
+
+    case 'Y':
+      show_internals = 1;
+      break;
+
+    case 'V':
+      /* -V: SVR4 argument to print version ID.  */
+      print_version_id ();
+      break;
+
+    case 'm':
+      if (!strcmp (arg, "tc10")
+          || !strcmp (arg, "rider-a")
+          || !strcmp (arg, "TriCore:Rider-A"))
+        current_isa = (current_isa & ~TRICORE_ISA_MASK) | TRICORE_V1_1;
+      else if (!strcmp (arg, "tc12")
+      	       || !strcmp (arg, "rider-b")
+      	       || !strcmp (arg, "TriCore:Rider-B"))
+        current_isa = (current_isa & ~TRICORE_ISA_MASK) | TRICORE_V1_2;
+      else if (!strcmp (arg, "tc13")
+      	       || !strcmp (arg, "rider-d")
+      	       || !strcmp (arg, "TriCore:Rider-D"))
+        current_isa = (current_isa & ~TRICORE_ISA_MASK) | TRICORE_V1_2;
+      else if (!strcmp (arg, "tc2")
+      	       || !strcmp (arg, "rider-2")
+      	       || !strcmp (arg, "TriCore:V2"))
+        current_isa = (current_isa & ~TRICORE_ISA_MASK) | TRICORE_V1_3;
+      else if (!strcmp (arg, "cpu9"))
+        {
+	  workaround_cpu9 = 1;
+	  workaround_cpu34 = 0;
+	}
+      else if (!strcmp (arg, "cpu34"))
+        {
+	  workaround_cpu34 = 1;
+	  workaround_cpu9 = 0;
+	}
+      else if (!strcmp (arg, "cpu48"))
+        workaround_cpu48 = 1;
+      else if (!strcmp (arg, "cpu50"))
+        workaround_cpu50 = 1;
+      else if (!strcmp (arg, "cpu60"))
+        workaround_cpu60 = 1;
+      else if (!strcmp (arg, "cpu69"))
+        workaround_cpu69 = 1;
+      else if (!strcmp (arg, "cpu70"))
+        workaround_cpu70 = 1;
+      else if (!strcmp (arg, "cpu72"))
+        workaround_cpu72 = 1;
+      else if (!strcmp (arg, "cpu81"))
+        workaround_cpu81 = 1;
+      else if (!strcmp (arg, "cpu82"))
+        workaround_cpu82 = 1;
+      else if (!strcmp (arg, "cpu83"))
+        workaround_cpu83 = 1;
+      else if (!strcmp (arg, "cpu094"))
+        workaround_cpu94 = 1;
+      else if (!strcmp (arg, "cpu095"))
+        workaround_cpu95 = 1;
+      else if (!strcmp (arg, "dmi12"))
+        workaround_dmi12 = 1;
+      else
+        {
+          as_bad (_("unrecognized option `-%c%s'"), c, arg ? arg : "");
+          return 0;
+        }
+      break;
+
+    /* Handle long options.  */
+
+    case OPTION_NOOPT:
+      optimize = optimize_next = 0;
+      break;
+
+    case OPTION_INSN32_ONLY:
+      big_insns = big_insns_only = 1;
+      break;
+
+    case OPTION_INSN32_PREF:
+      big_insns = 1;
+      break;
+
+    case OPTION_ENFORCE_ALIGN:
+      enforce_aligned_data = 1;
+      break;
+    default:
+      as_bad (_("unrecognized option `-%c%s'"), c, arg ? arg : "");
+      return 0;
+    }
+
+  return 1;
+}
+
+/* This is the callback function for the .code16 pseudo opcode.  */
+
+static void
+set_16bit_code_flag (flag)
+     int flag;
+{
+  use_insn16 = (big_insns_only) ? 0 : flag;
+  use_insn32 = 0;
+}
+
+/* This is the callback function for the .code32 pseudo opcode.  */
+
+static void
+set_32bit_code_flag (flag)
+     int flag;
+{
+  use_insn32 = flag;
+  use_insn16 = 0;
+}
+
+/* This is the callback function for the .optim/.noopt pseudo opcodes.  */
+
+static void
+set_optimize_flag (flag)
+     int flag;
+{
+  optimize_next = flag;
+}
+
+/* This is the callback function for the .pcpinitword pseudo opcode.  */
+
+static void
+pcp_init_word (flag)
+     int flag ATTRIBUTE_UNUSED;
+{
+  expressionS init_pc, init_page, init_flags;
+  unsigned long flags = 0;
+  char *p;
+#define BAD(reason)		\
+  {				\
+    as_bad (reason);		\
+    ignore_rest_of_line ();	\
+    return;			\
+  }
+
+  BAD("PCP_SEG TO BE IMPLEMENTED");
+  return;
+//   if (!(now_seg->flags & PCP_SEG) || (now_seg->flags & SEC_CODE))
+//     BAD (_(".pcpinitword must only be used within PCP data sections"));
+
+  /* Get expression for initial PC.  */
+  if (is_it_end_of_statement ())
+    BAD (_("Expecting expression for initial PC"));
+  expression (&init_pc);
+  if ((init_pc.X_op == O_absent)
+      || ((init_pc.X_op == O_constant)
+          && (init_pc.X_add_number & ~0xffff)))
+    BAD (_("Illegal expression for initial PC"));
+
+  /* Get expression for initial data page.  */
+  SKIP_WHITESPACE ();
+  if (*input_line_pointer != ',')
+    BAD (_("Expecting expression for initial data page"));
+  ++input_line_pointer;
+  expression (&init_page);
+  if ((init_page.X_op == O_absent)
+      || ((init_page.X_op == O_constant)
+          && (init_page.X_add_number & ~0xff)))
+    BAD (_("Illegal expression for initial data page"));
+
+  /* Get expression for initial flags.  */
+  SKIP_WHITESPACE ();
+  if (*input_line_pointer != ',')
+    BAD (_("Expecting expression for initial flags"));
+  ++input_line_pointer;
+  expression (&init_flags);
+  if ((init_flags.X_op == O_absent)
+      || ((init_flags.X_op == O_constant)
+	  && (init_flags.X_add_number & ~0xff)))
+    BAD (_("Illegal expression for initial flags"));
+  demand_empty_rest_of_line ();
+
+  /* Now emit the initialization word and all required relocs.  */
+  p = frag_more (4);
+
+  if (init_pc.X_op == O_constant)
+    flags |= (init_pc.X_add_number << 16);
+  else
+    fix_new_exp (frag_now, (p + 2 - frag_now->fr_literal), 0, &init_pc, 0,
+    		 BFD_RELOC_TRICORE_PCPTEXT);
+
+  if (init_page.X_op == O_constant)
+    flags |= (init_page.X_add_number << 8);
+  else
+    fix_new_exp (frag_now, (p - frag_now->fr_literal), 0, &init_page, 0,
+    		 BFD_RELOC_TRICORE_PCPPAGE);
+
+  if (init_flags.X_op == O_constant)
+    flags |= init_flags.X_add_number;
+  else
+    fix_new_exp (frag_now, (p - frag_now->fr_literal), 0, &init_flags, 0,
+    		 BFD_RELOC_TRICORE_8ABS);
+
+  md_number_to_chars (p, flags, 4);
+
+  if (show_internals)
+    printf ("*** pcpinitword: word = 0x%08lx, relocs = %s, %s, %s\n", flags,
+      	    (init_pc.X_op != O_constant) ? "PCPTEXT" : "none",
+	    (init_page.X_op != O_constant) ? "PCPPAGE" : "none",
+	    (init_flags.X_op != O_constant) ? "8ABS": "none");
+#undef BAD
+}
+
+/* This is the callback function for the .bit/.lbit pseudo opcodes.  */
+#pragma GCC diagnostic ignored "-Wstack-usage="
+static void
+create_bit (int global)
+
+{
+  char *bname, *pname, *sname = NULL, *p, c;
+  symbolS *bsym, *psym;
+  elf_symbol_type *elfsym;
+  segT current_seg = now_seg;
+  subsegT current_subseg = now_subseg;
+  segT bdata_sec, bpos_sec;
+  int val = -1;
+
+  /* Get the name of the bit symbol.  */
+  bname = input_line_pointer;  
+  p = input_line_pointer;
+  char **tmp = &p; //todo understand what should be tmp
+  c = get_symbol_name(tmp);
+  if (bname == p)
+    {
+      as_bad (_("Expected symbol name for bit variable"));
+      *p = c;
+      discard_rest_of_line ();
+      return;
+    }
+
+  /* Make sure that local label names aren't used as local bit names, as
+     they'll usually be stripped from the symbol table.  */
+  if (!global && bfd_is_local_label_name (stdoutput, bname))
+    {
+      as_bad (_("Can't use local label name <%s> as local bit name"), bname);
+      *p = c;
+      discard_rest_of_line ();
+      return;
+    }
+
+  /* Gripe if this symbol is already defined, or else create a symbol
+     table entry for it.  */
+  if (((bsym = symbol_find (bname)) != NULL)
+      && S_IS_DEFINED (bsym))
+    {
+      as_bad (_("Symbol <%s> already defined"), bname);
+      *p = c;
+      discard_rest_of_line ();
+      return;
+    }
+  else if (bsym == NULL)
+    bsym = symbol_find_or_make (bname);
+
+  /* This prevents error messages like "Symbol <foo.pos> already defined" if
+     some error occurs before the actual section is set for "foo" at the end
+     of this function, and another .bit/.lbit pseudo-op refers to "foo" again;
+     by tentatively setting "foo"'s section to .boffs (and thus "defining" the
+     bit symbol), we'll get the correct error message "Symbol <foo> already
+     defined" in these cases.  */
+  bpos_sec = subseg_new (".boffs", 0);
+  S_SET_SEGMENT (bsym, bpos_sec);
+
+  /* Create another symbol for it in section .boffs that holds its bit offset
+     within the containing byte; gripe if this symbol already exists (note
+     that it's irrelevant whether the symbol already exists because it has
+     been actually defined, or merely because it was referenced: bit position
+     symbols may only be created by .bit/.lbit pseudo-ops (both handled by
+     this function), and the only legal way to refer to them is by using the
+     "bpos:" prefix -- and even this prefix refers only to the bit symbol
+     itself, _not_ to the corresponding bit offset symbol, so either a defined
+     or an undefined bit offset symbol spells trouble).  */
+  pname = alloca (strlen (bname) + 5);
+  sprintf (pname, "%s.pos", bname);
+  *p = c;
+  if ((psym = symbol_find (pname)) != NULL)
+    {
+      as_bad (_("Bit position symbol <%s> already exists"), pname);
+      discard_rest_of_line ();
+      return;
+    }
+  else
+    psym = symbol_find_or_make (pname);
+  seg_info (bpos_sec)->bss = 1;
+  bfd_set_section_flags ( bpos_sec, SEC_ALLOC | SEC_READONLY);
+  S_SET_SEGMENT (psym, bpos_sec);
+  if (global)
+    S_SET_EXTERNAL (psym);
+  else
+    S_CLEAR_EXTERNAL (psym);
+  subseg_set (current_seg, current_subseg);
+
+  /* Get initialization value and section name, if specified.  */
+  SKIP_WHITESPACE ();
+  if (*input_line_pointer == ',')
+    {
+      int nr_errors = had_errors ();
+
+      /* Get initialization value, if specified.  */
+      ++input_line_pointer;
+      SKIP_WHITESPACE ();
+      if (*input_line_pointer != ',')
+	{
+	  if (is_end_of_line[(unsigned char) *input_line_pointer])
+	    {
+	      as_bad (_("Missing initialization value for bit variable"));
+	      return;
+	    }
+	  val = get_absolute_expression ();
+	  if (nr_errors != had_errors ())
+	    {
+	      ignore_rest_of_line ();
+	      return;
+	    }
+	  if (val & ~1)
+	    {
+	      as_bad (_("Illegal bit value; must be 0 or 1"));
+	      ignore_rest_of_line ();
+	      return;
+	    }
+	  SKIP_WHITESPACE ();
+	}
+
+      /* Get the section name, if specified.  */
+      if (*input_line_pointer == ',')
+	{
+	  char *secname;
+	  asection *sec;
+
+	  ++input_line_pointer;
+	  SKIP_WHITESPACE ();
+	  secname = input_line_pointer;
+	  c = get_symbol_name(&input_line_pointer); //TODO understand what should be the arg here
+	  p = input_line_pointer;
+	  if (secname == p)
+	    {
+	      as_bad (_("Expected bit section name"));
+	      *p = c;
+	      discard_rest_of_line ();
+	      return;
+	    }
+
+	  /* Make sure we're dealing with a valid bit section name.  */
+	  if (strcmp (secname, ".bdata") && strncmp (secname, ".bdata.", 7)
+	      && strcmp (secname, ".bbss") && strncmp (secname, ".bbss.", 6))
+	    {
+	      as_bad (_("Illegal bit section name \"%s\""), secname);
+	      *p = c;
+	      discard_rest_of_line ();
+	      return;
+	    }
+
+	  /* If it's a new bit section, make a permanent copy of its name,
+	     or else re-use its already existing name.  */
+	  if ((sec = bfd_get_section_by_name (stdoutput, secname)) == NULL)
+	    sname = xstrdup (secname);
+	  else
+	    sname = (char *) sec->name;
+	  *p = c;
+	}
+    }
+  demand_empty_rest_of_line ();
+
+  /* If no section name was explicitly specified, default to .bdata or .bbss,
+     depending on whether an initialization value was given or not.  */
+  if (sname == NULL)
+    {
+	  
+      sname = (char* ) ((val == -1) ? ".bbss" : ".bdata");
+    }
+
+  if (val == -1)
+    {
+      /* Try to assign the symbol to a bit BSS section.  */
+      if (strcmp (sname, ".bbss") && strncmp (sname, ".bbss.", 6))
+        {
+	  as_bad (_("Illegal bit BSS section name \"%s\""), sname);
+	  return;
+	}
+      bdata_sec = subseg_new (sname, 0);
+      seg_info (bdata_sec)->bss = 1;
+      bfd_set_section_flags (bdata_sec, SEC_ALLOC);
+    }
+  else
+    {
+      /* Try to assign the symbol to a bit data section.  */
+      if (strcmp (sname, ".bdata") && strncmp (sname, ".bdata.", 7))
+        {
+	  as_bad (_("Illegal bit data section name \"%s\""), sname);
+	  return;
+	}
+      bdata_sec = subseg_new (sname, 0);
+      bfd_set_section_flags (bdata_sec, SEC_ALLOC | SEC_LOAD | SEC_DATA);
+    }
+
+  /* Finally, define the bit symbol in the requested section.  */
+  S_SET_SEGMENT (bsym, bdata_sec);
+  S_SET_VALUE (bsym, (valueT) frag_now_fix ());
+  S_SET_SIZE (bsym, 1);
+  symbol_set_frag (bsym, frag_now);
+  
+  elfsym = (elf_symbol_type *) symbol_get_bfdsym (bsym);
+  elfsym->symbol.flags |= BSF_OBJECT;
+  if (global)
+    S_SET_EXTERNAL (bsym);
+  else
+    S_CLEAR_EXTERNAL (bsym);
+  p = frag_more (1);
+  *p = (val == -1) ? 0 : val;
+  subseg_set (current_seg, current_subseg);
+
+  if (show_internals)
+    {
+      pname[strlen (pname) - 4] = '\0';
+      printf ("*** .%s <%s>,", global ? "bit" : "lbit", pname);
+      if (val == -1)
+        printf (",<%s>\n", sname);
+      else
+        printf ("%d,<%s>\n", val, sname);
+    }
+}
+
+/* This is the callback function for .bpos and friends.  */
+
+static void
+bpcons (nbytes)
+     int nbytes;
+{
+  expressionS bexp;
+  char *p;
+
+  /* Get expression for the bit symbol.  */
+  if (is_it_end_of_statement ())
+    {
+      as_bad (_("Expected symbol name for bit variable"));
+      discard_rest_of_line ();
+      return;
+    }
+  expression (&bexp);
+  if ((bexp.X_op == O_absent)
+      || ((bexp.X_op == O_constant)
+          && (bexp.X_add_number & ~0x7))
+      || ((bexp.X_op != O_constant)
+          && (bexp.X_add_number != 0))
+      || (bexp.X_add_symbol == NULL)
+      || (bexp.X_op_symbol != NULL))
+    {
+      as_bad (_("Illegal expression for bit variable"));
+      discard_rest_of_line ();
+      return;
+    }
+  demand_empty_rest_of_line ();
+
+  /* Now emit the byte(s) and required relocs.  */
+  frag_grow (nbytes);
+  p = frag_more (nbytes);
+  if (bexp.X_op == O_constant)
+    {
+      md_number_to_chars (p, bexp.X_add_number, nbytes);
+      if (show_internals)
+        printf ("*** bpcons(%d): val = %ld\n", nbytes, bexp.X_add_number);
+    }
+  else
+    {
+      enum bfd_reloc_code_real reloc = NO_RELOC;
+
+      if (nbytes == 1)
+        reloc = BFD_RELOC_8;
+      else if (nbytes == 2)
+        reloc = BFD_RELOC_16;
+      else if (nbytes == 4)
+        reloc = BFD_RELOC_32;
+
+      md_number_to_chars (p, 0, nbytes);
+      fix_new_exp (frag_now, (p - frag_now->fr_literal), 0, &bexp, 0,
+      		   BFD_RELOC_TRICORE_BITPOS);
+      fix_new_exp (frag_now, (p - frag_now->fr_literal), 0, &bexp, 0, reloc);
+
+      if (show_internals)
+        printf ("*** bpcons(%d): sym = <%s>, relocs = %s, %s\n",
+	        nbytes, S_GET_NAME (bexp.X_add_symbol),
+		"BFD_RELOC_TRICORE_BITPOS", GET_RELOC_NAME (reloc));
+    }
+}
+
+/* This is the callback function for .toc and friends.  */
+
+static void
+make_section (sec)
+     int sec;
+{
+  asec_t *aptr;
+
+  if ((sec < 0) || (sec >= nr_addsecs))
+    {
+      as_bad (_("Illegal section %d in make_section"), sec);
+      return;
+    }
+
+  aptr = &addsecs[sec];
+  *aptr->sec_ptr = subseg_new (aptr->sec_name, 0);
+  if (!aptr->sec_exists)
+    {
+      bfd_set_section_flags (*aptr->sec_ptr, aptr->sec_flags);
+      bfd_set_section_alignment (*aptr->sec_ptr, aptr->sec_align);
+      aptr->sec_exists = 1;
+      if (show_internals)
+        printf ("*** Created new section \"%s\".\n", aptr->sec_name);
+    }
+}
+
+/* Map ELF section letter 'p' to SHF_TRICORE_PCP.  */
+
+int
+tricore_elf_section_letter (letter, ptr_msg)
+     int letter;
+     char **ptr_msg;
+{
+  if (letter == 'p')
+    return SHF_TRICORE_PCP;
+
+  *ptr_msg = _("Bad .section directive: want a,p,w,x,M,S,G in string");
+  return 0;
+}
+
+/* This is called to convert special ELF section flags to their
+   BFD equivalent.  */
+
+flagword
+tricore_elf_section_flags (flagword flags, int attr ATTRIBUTE_UNUSED, int type ATTRIBUTE_UNUSED)
+ {
+  //if (attr & SHF_TRICORE_PCP)
+    //flags |= SEC_ARCH_BIT_0;
+
+  return flags;
+}
+
+/* This is called upon entering a new section.  If the new section's PCP_SEG
+   flag is set and the section has just been created, we'll set a reasonable
+   default alignment for it (NB: it's not wise to do this for every section
+   that appears to contain code or data, because some sections (notably debug
+   sections) must be byte-aligned to function correctly).  We're also making
+   sure that the user can't create or enter bit data sections via ".section"
+   and similar pseudo-ops.  */
+
+void
+tricore_elf_section_change_hook ()
+{
+  //int /*align,*/ old_align;
+
+  if ((now_seg->name[0] == '.') && (now_seg->name[1] == 'b')
+      && (!strcmp (now_seg->name, ".boffs")
+	  || !strcmp (now_seg->name, ".bdata")
+	  || !strncmp (now_seg->name, ".bdata.", 7)
+	  || !strcmp (now_seg->name, ".bbss")
+	  || !strncmp (now_seg->name, ".bbss.", 6)))
+    {
+      as_bad (_("Illegal attempt to create or enter bit data section \"%s\""),
+      	      now_seg->name);
+      return;
+    }
+
+  //   Since PCP_SEG isn't used, this section is useless 
+  // old_align = (now_seg->alignment_power + 0);
+
+  //if (old_align > 0)
+  //  return;  /* Alignment already set; we're done.  */
+
+
+//   if (now_seg->flags & PCP_SEG)
+//     {
+//       /* Align PCODE sections to 2**1 and PRAM sections to 2**6.  */
+//       align = (now_seg->flags & SEC_CODE) ? 1 : 6;
+//       if (show_internals)
+//         printf ("*** Setting alignment of %s section \"%s\" to 2**%d\n",
+//     	        align == 1 ? "PCODE" : "PRAM", now_seg->name, align);
+//       bfd_set_section_alignment (now_seg, align);
+//     }  
+}
+
+/* This is the callback function for .uahalf and friends.  */
+
+static void
+tricore_uacons (bytes)
+     int bytes;
+{
+  /* Tell tricore_cons_align to not align this value.  */
+  tricore_no_align_cons = 1;
+  cons (bytes);
+}
+
+/* This is called back by cons () and aligns constants if required.  */
+
+void
+tricore_cons_align (nbytes)
+     int nbytes;
+{
+  int nalign;
+  //char *p;
+
+  /* Only do this if we are enforcing aligned data.  */
+  if (!enforce_aligned_data)
+    return;
+
+  if (tricore_no_align_cons)
+    {
+      /* This is an unaligned pseudo-op.  */
+      tricore_no_align_cons = 0;
+      return;
+    }
+
+  nalign = 0;
+  while ((nbytes & 1) == 0)
+    {
+      ++nalign;
+      nbytes >>= 1;
+    }
+
+  if (nalign == 0)
+    return;
+
+  if (now_seg == absolute_section)
+    {
+      if ((abs_section_offset & ((1 << nalign) - 1)) != 0)
+        as_bad (_("Misaligned data in absolute section"));
+      return;
+    }
+  //unused variable
+  /*p = frag_var (rs_align_code, 1, 1, (relax_substateT) 0,
+  		(symbolS *) NULL, (offsetT) nalign, (char *) NULL);*/
+
+  record_alignment (now_seg, nalign);
+}
+
+/* Show which TriCore-specific options we can offer.  */
+
+void
+md_show_usage (stream)
+     FILE *stream;
+{
+  fprintf (stream, _("\
+TriCore-specific options:\n\
+  -V			  print assembler version number\n\
+  -Y			  print internal information (helps debugging `as')\n\
+  -mtc10		  assemble for the TC1V1.0 instruction set (deprecated)\n\
+  -mtc12		  assemble for the TC1V1.[23] instruction set (default)\n\
+  -mtc13		  assemble for the TC1V1.[23] instruction set (default)\n\
+  -mtc2			  assemble for the TC2 instruction set\n\
+  -mcpu9		  insert 2 NOPs after DSYNC (workaround for CPU.9 bug)\n\
+  -mcpu34		  insert ISYNC after DSYNC (workaround for CPU_TC.034/\n\
+			    COR17 bug)\n\
+  -mcpu48		  insert a NOP between LD.[A,DA] and an immediately\n\
+  			    following indirect jump or call instruction\n\
+			    (workaround for CPU_TC.048 bug)\n\
+  -mcpu50		  insert a NOP after certain multi-cycle instructions\n\
+			    followed by LD.x (workaround for CPU_TC.050 bug)\n\
+  -mcpu60		  insert a NOP between LD.[A,DA] and an immediately\n\
+  			    following LD.[D,W] instruction (workaround for\n\
+			    CPU_TC.060 bug)\n\
+  -mcpu69		  insert a NOP after a RSLCX instruction (workaround\n\
+			    for CPU_TC.069 bug)\n\
+  -mcpu70		  insert 1-2 NOPs after a conditional jump and a LOOP\n\
+  			    instruction following it (workaround for CPU_TC.070\n\
+			    bug)\n\
+  -mcpu72		  insert a NOP between LD.[A,DA] and an immediately\n\
+  			    following LOOP instruction (workaround for\n\
+			    CPU_TC.072 bug)\n\
+  -mcpu81		  forbid loading of %%A10 from memory (workaround\n\
+			    for CPU_TC.081 bug)\n\
+  -mcpu82		  insert a NOP between ST[LU]CX and an immediately\n\
+			    following LD.x instruction (workaround for\n\
+			    CPU_TC.082 bug)\n\
+  -mcpu83		  insert a NOP after a DISABLE instruction (workaround\n\
+			    for CPU_TC.083 bug)\n\
+  -mcpu094		  insert a NOP between an integer pipeline jump instruction\n\
+				and a CSA instruction (workaround for CPU_TC.094 bug)\n\
+  -mcpu095		  insert a NOP between a sat instruction a load and store\n\
+				pipeline instruction (addsc, mov.a, mtcr) \n\
+				(workaround for CPU_TC.095 bug)\n\
+  -mdmi12		  insert a NOP before or after certain load/store and\n\
+  			    jump instructions (workaround for DMI_TC.012 bug)\n\
+  --dont-optimize	  don't try to find the shortest matching opcode\n\
+			    (.optim, .code16 and .code32 are honored)\n\
+  --insn32-only		  use only 32-bit instructions (.code16 is ignored)\n\
+  --insn32-preferred	  use only 32-bit instructions (.code16 is honored)\n\
+  --enforce-aligned-data  force .hword/.word/etc. to be aligned correctly\n"));
+}
+
+/* See if we need to do something special with an undefined symbol.
+   This is true if NAME represents a TriCore core register.  */
+
+symbolS *
+md_undefined_symbol (char *name)
+{
+  char *src, *dst, *cname;
+  sfr_t *creg;
+  symbolS *sym;
+
+  assert (name);
+  if (*name == '$')
+    {
+      cname = xmalloc (strlen (name) + 1);
+      for (src = name, dst = cname; *src; /* Empty.  */)
+        if ((*src >= 'A') && (*src <= 'Z'))
+          *dst++ = (*src++) - 'A' + 'a';
+        else
+          *dst++ = *src++;
+      *dst = '\0';
+      creg = str_hash_find (hash_sfr, cname);
+      free (cname);
+      if (creg != NULL)
+        {
+	  if ((sym = symbol_find (creg->name)) != NULL)
+	    return sym;
+
+	  return symbol_new (creg->name, absolute_section,
+	  		     &zero_address_frag, (valueT) creg->addr);
+	}
+    }
+
+  return (symbolS *) 0;
+}
+
+/* Turn the floating point constant pointed to by input_line_pointer into
+   its binary equivalent of type TYPE.  Write the bytes in the correct
+   byte order to the buffer pointed to by LITP and set *SIZEP to the
+   number of bytes written.  Return an error message, or NULL on OK.  */
+
+const char *
+md_atof (int type, char* litP, int* sizeP)
+{
+  int i, prec;
+  char *t;
+  LITTLENUM_TYPE words[6]; /* atof-ieee.c wants 6 words.  */
+  static const int wordsize = sizeof (LITTLENUM_TYPE);
+
+  if ((type == 'f') || (type == 'F'))
+    prec = 2;
+  else if ((type == 'd') || (type == 'D'))
+    prec = 4;
+  else
+    {
+      *sizeP = 0;
+      return "Illegal precision specification";
+    }
+
+  if ((t = atof_ieee (input_line_pointer, type, words)) != NULL)
+    input_line_pointer = t;
+  *sizeP = prec * wordsize;
+
+  /* TriCore is little-endian.  */
+  for (i = prec - 1; i >= 0; --i)
+    {
+      md_number_to_chars (litP, (valueT) words[i], wordsize);
+      litP += wordsize;
+    }
+
+  return NULL;
+}
+
+/* Return the closest matching operand type for the constant value C.  */
+
+static char
+classify_const (c)
+     long c;
+{
+  if (c < 0)
+    {
+      if (c >= -8)
+        return '4';
+
+      if (c >= -16)
+        return 'F';
+
+      if ((c >= -32) && !(c & 1))
+	return 'r';
+
+      if (c >= -256)
+        return (c & 1) ? '9' : 'R';
+
+      if (c >= -512)
+        return '0';
+
+      if (c >= -32768)
+        return (c & 1) ? 'w' : 'o';
+
+      if ((c >= -16777216) && !(c & 1))
+        return 'O';
+    }
+  else
+    {
+      if (c < 2)
+        return '1';
+
+      if (c < 4)
+        return '2';
+
+      if (c < 8)
+        return '3';
+
+      if (c < 16)
+        return 'f';
+
+      if (c < 31)
+        return (c & 1) ? '5' : 'v';
+
+      if (c < 32)
+        return '5';
+
+      if ((c < 61) && !(c & 3))
+        return '6';
+
+      if ((c < 63) && !(c & 1))
+        return 'x';
+
+      if (c < 256)
+        return '8';
+
+      if (c < 512)
+        return 'n';
+
+      if ((c < 1024) && !(c & 3))
+        return 'k';
+
+      if (c < 32768)
+        return 'q';
+
+      if (c < 65536)
+        return 'W';
+
+      if ((c < 16777215) && !(c & 1))
+        return 'O';
+    }
+
+  if (!(c & 0x0fffc000))
+    return 't';
+  else if (!(c & 0x0fe00001))
+    return 'T';
+
+  return 'M';
+}
+
+/* Return the register number starting at *STR and advance *STR
+   to the first character after the number.  If no valid number
+   can be found, -1 is returned and the_insn.error is set to an
+   appropriate error message.  Valid regnos range from 00 to 15.  */
+
+static int
+read_regno (str)
+     char **str;
+{
+  char *pos = *str;
+  int no = 0, digits_seen = 0;
+
+  while ((*pos >= '0') && (*pos <= '9'))
+    {
+      ++digits_seen;
+      no = no * 10 + (*pos - '0');
+      if ((no > 15) || (digits_seen > 2))
+	{
+	  the_insn.error = _("Invalid register number");
+	  return -1;
+	}
+      else
+	++pos;
+    }
+
+  if (!digits_seen)
+    {
+      the_insn.error = _("Missing register number");
+      return -1;
+    }
+
+  *str = pos;
+  return no;
+}
+
+/* *STR points to the first character after a data register specification
+   and **STR is not '\0'.  This may mean there's a register suffix; if so,
+   return the appropriate mode and advance *STR to the first character
+   after the suffix.  Valid suffixes are u, l, ll, lu, ul and uu.  */
+
+static char
+read_regsuffix (str)
+     char **str;
+{
+  char *pos = *str;
+
+  if (*pos == 'l')
+    {
+      if (*(pos + 1) == 'l')
+        {
+	  *str += 2;
+	  return '-';
+	}
+      else if (*(pos + 1) == 'u')
+        {
+	  *str += 2;
+	  return 'l';
+	}
+
+      *str += 1;
+      return 'g';
+    }
+  else if (*pos == 'u')
+    {
+      if (*(pos + 1) == 'l')
+        {
+	  *str += 2;
+	  return 'L';
+	}
+      else if (*(pos + 1) == 'u')
+        {
+	  *str += 2;
+	  return '+';
+	}
+
+      *str += 1;
+      return 'G';
+    }
+
+  return 'd';  /* Will immediately lead to an error, as **str != '\0'.  */
+}
+
+/* Parse an expression for operand OPNR starting at *STR (SRC points
+   to the original input line).  Advance *STR to the first character
+   after the expression.  If no valid expression can be found, 0 is
+   returned and the_insn.error is set to an appropriate error message,
+   otherwise 1 is returned.  */
+
+static int
+get_expression (const char *src, char** str, int opnr)
+{
+  char *cp = *str, *save_in, *save_oldpos, *colon, *pfx;
+  
+  const char *pfxs = " hi: lo: sm: up: got: gothi: gotlo: gotup:"
+  		     " gotoff: gotoffhi: gotofflo: gotoffup:"
+		     " gotpc: gotpchi: gotpclo: gotpcup: plt: bpos:";
+  const char *plen = " 3   3   3   3   4    6      6      6     "
+  		     " 7       9         9         9        "
+		     " 6      8        8        8        4    5";
+  const char *pcod = " 1   2   3   4   5    6      7      8     "
+  		     " 9       10        11        12       "
+		     " 13     14       15       16       17   18";
+
+  /* Filter out prefixes.  */
+  if ((colon = strchr (cp, ':')) != NULL)
+    {
+      char save = colon[1];
+
+      colon[1] = '\0';
+      if (((pfx = strstr (pfxs, cp)) != NULL) && (pfx[-1] == ' '))
+        {
+	  int i, diff;
+
+	  diff = pfx - pfxs;
+	  sscanf (&pcod[diff], "%d", &i);
+	  if ((prefix_t) i == PREFIX_BITPOS)
+	    the_insn.bitpos[opnr] = 1;
+	  else
+	    {
+	      the_insn.prefix[opnr] = (prefix_t) i;
+	      the_insn.needs_prefix = 1;
+	    }
+	  sscanf (&plen[diff], "%d", &i);
+	  cp += i;
+	}
+      colon[1] = save;
+    }
+
+  /* See if this expression references the special GOT symbol.  */  
+  if (strstr (src + (cp - insnline), "_GLOBAL_OFFSET_TABLE_"))
+    {
+      switch (the_insn.prefix[opnr])
+	{
+	case PREFIX_NONE:
+	  the_insn.prefix[opnr] = PREFIX_GOTPC;
+	  break;
+
+	case PREFIX_HI:
+	  the_insn.prefix[opnr] = PREFIX_GOTPCHI;
+	  break;
+
+	case PREFIX_LO:
+	  the_insn.prefix[opnr] = PREFIX_GOTPCLO;
+	  break;
+
+	case PREFIX_UP:
+	  the_insn.prefix[opnr] = PREFIX_GOTPCUP;
+	  break;
+
+	case PREFIX_GOTPC:
+	case PREFIX_GOTPCHI:
+	case PREFIX_GOTPCLO:
+	case PREFIX_GOTPCUP:
+	  break;
+
+	default:
+	  as_bad (_("Illegal prefix for GOT expression"));
+	  break;
+	}
+    }
+
+  save_in = input_line_pointer;
+  save_oldpos = input_line_pointer = (char*) src + (cp - insnline);
+  expression (&the_insn.opexp[opnr]);
+  *str = cp + (input_line_pointer - save_oldpos);
+  input_line_pointer = save_in;
+
+  if (**str != '\0')
+    {
+      the_insn.error = _("Trailing chars after expression");
+      return 0;
+    }
+
+  if (the_insn.opexp[opnr].X_op == O_absent)
+    {
+      the_insn.error = _("Illegal expression");
+      return 0;
+    }
+
+  if (the_insn.opexp[opnr].X_op == O_constant)
+    {
+      switch (the_insn.prefix[opnr])
+        {
+	case PREFIX_NONE:
+	case PREFIX_HI:
+	case PREFIX_LO:
+	case PREFIX_UP:
+	  break;
+
+	default:
+	  the_insn.error = _("Illegal prefix for constant expression");
+	  return 0;
+	}
+      if (the_insn.bitpos[opnr] && ((VAL (opnr) < 0) || (VAL (opnr) > 7)))
+	{
+	  the_insn.error = _("Illegal constant bit position");
+	  return 0;
+        }
+      the_insn.ops[opnr] = classify_const (VAL (opnr));
+      the_insn.is_odd[opnr] = (VAL (opnr) & 1);
+      if (the_insn.prefix[opnr] != PREFIX_NONE)
+        the_insn.ops[opnr] = 'q'; /* Matches both 'w' and 'W'!  */
+      else if (the_insn.ops[opnr] == 'k')
+        the_insn.matches_k[opnr] = 1;
+      else if (the_insn.ops[opnr] == '6')
+	{
+	  the_insn.matches_6[opnr] = 1;
+	  the_insn.matches_k[opnr] = 1;
+	}
+      else if (strchr ("123fmxv", the_insn.ops[opnr]))
+	{
+	  if (!(VAL (opnr) & 1))
+	    the_insn.matches_v[opnr] = 1;
+	  if (!(VAL (opnr) & 3))
+	    {
+	      the_insn.matches_6[opnr] = 1;
+	      the_insn.matches_k[opnr] = 1;
+	    }
+	}
+      else if (strchr ("58n", the_insn.ops[opnr]))
+        if (!(VAL (opnr) & 3))
+	  the_insn.matches_k[opnr] = 1;
+    }
+  else
+    {
+      the_insn.ops[opnr] = 'U';
+      the_insn.matches_v[opnr] = 1;
+      the_insn.matches_6[opnr] = 1;
+      the_insn.matches_k[opnr] = 1;
+    }
+
+  return 1;
+}
+
+/* Parse the TriCore instruction starting at STR and fill the_insn.  */
+
+static void
+tricore_ip (const char* str)
+{
+  char *src, *dst, mode;
+  int numops = -1;
+  int preinc, postinc;
+  size_t str_len;
+  int not_hack = 0;
+
+  if ((str_len = strlen (str)) >= insnline_len)
+    {
+      insnline_len = str_len + 1;
+      insnline = xrealloc (insnline, insnline_len);
+    }
+
+  /* Make a lower-case-only copy of the input line.  */
+  for (src = (char *) str, dst = insnline; *src; /* Empty.  */)
+    if ((*src >= 'A') && (*src <= 'Z'))
+      *dst++ = (*src++) - 'A' + 'a';
+    else
+      *dst++ = *src++;
+  *dst = '\0';
+
+  /* Lookup the instruction name.  */
+  dst = strtok (insnline, ", ");
+  if ((*insnline == 'n') && !strcmp (insnline, "not"))
+    {
+      /* Pseudo-insn "not" is actually a "nor".  */
+      insnline[2] = 'r';
+      not_hack = 1;
+    }
+  else if ((*insnline == 'c') && !strcmp (insnline, "call"))
+    the_insn.is_call = 1;
+  else if ((*insnline == 'l') && !strcmp (insnline, "loop"))
+    the_insn.is_loop = 1;
+  else if ((*insnline == 'f') && !strcmp (insnline, "fcall"))
+    the_insn.is_call = 1;
+
+  if ((the_insn.code = (opcode_t *) str_hash_find (hash_ops, insnline)) == NULL)
+    {
+      the_insn.error = _("Unknown instruction");
+      return;
+    }
+
+
+  /* Parse the operands.  */
+  while ((dst = strtok (NULL, ", ")) != NULL)
+    {
+      /* Offsets after address mode specifications are not necessarily
+         comma-separated, but they need to be treated as operands on
+	 their own right.  The label below serves this purpose.  */
+restart_scan:
+      if (++numops == MAX_OPS)
+        {
+	  the_insn.error = _("Too many operands");
+	  return;
+	}
+      preinc = postinc = 0;
+      switch (*dst)
+        {
+	case '%': /* A register.  */
+	  mode = *++dst;
+	  if ((mode == 's') && (dst[1] == 'p') && (dst[2] == '\0'))
+	    {
+	      /* %sp -> %aSP_REGNUM  */
+	      the_insn.regs[numops] = SP_REGNUM;
+	      the_insn.ops[numops] = 'P';
+	      break;
+	    }
+	  if ((mode != 'd') && (mode != 'e') && (mode != 'a'))
+	    {
+	      the_insn.error = _("Invalid register specification");
+	      return;
+	    }
+	  ++dst;
+	  if ((the_insn.regs[numops] = read_regno (&dst)) == -1)
+	    return;
+
+	  if ((mode == 'd') && (*dst == '+') && (*(dst + 1) == '\0'))
+	    {
+	      mode = 'e';
+	      ++dst;
+	    }
+
+	  if ((mode == 'd') && (*dst != '\0'))
+	    mode = the_insn.ops[numops] = read_regsuffix (&dst);
+
+	  if (*dst != '\0')
+	    {
+	      the_insn.error = _("Trailing chars after register specification");
+	      return;
+	    }
+	  if (mode == 'd')
+	    {
+	      /* A data register.  */
+	      if (the_insn.regs[numops] == 15)
+	        the_insn.ops[numops] = 'i';
+	      else
+	        the_insn.ops[numops] = 'd';
+	    }
+	  else if (mode == 'e')
+	    {
+	      /* An extended data register.  */
+	      if (the_insn.regs[numops] & 1)
+	        {
+		  the_insn.error = _("Invalid extended register specification");
+		  return;
+		}
+	      the_insn.ops[numops] = 'D';
+	    }
+	  else if (mode == 'a')
+	    {
+	      /* An address register.  */
+	      if (the_insn.regs[numops] == SP_REGNUM)
+	        the_insn.ops[numops] = 'P';
+	      else if (the_insn.regs[numops] == 15)
+	        the_insn.ops[numops] = 'I';
+	      else if (the_insn.regs[numops] & 1)
+	        the_insn.ops[numops] = 'a';
+	      else
+	        the_insn.ops[numops] = 'A';
+	    }
+	  break;
+
+	case '[': /* An address mode.  */
+	  switch (*++dst)
+	    {
+	    case '\0':
+	      the_insn.error = _("Missing address register");
+	      return;
+
+	    case '+':
+	      ++dst;
+	      preinc = 1;
+	      break;
+	    }
+	  if (*dst++ != '%')
+	    {
+	      the_insn.error = _("Missing address register");
+	      return;
+	    }
+	  if ((*dst == 's') && (dst[1] == 'p'))
+	    {
+	      /* %sp -> %aSP_REGNUM  */
+	      the_insn.regs[numops] = SP_REGNUM;
+	      dst += 2;
+	    }
+	  else if (*dst == 'a')
+	    {
+	      ++dst;
+	      if ((the_insn.regs[numops] = read_regno (&dst)) == -1)
+	        return;
+	    }
+	  else
+	    {
+	      the_insn.error = _("Invalid or missing address register");
+	      return;
+	    }
+	  if (*dst == '\0')
+	    {
+	      the_insn.error = _("Missing ']'");
+	      return;
+	    }
+	  else if (*dst == ']')
+	    {
+	      if (preinc)
+	        the_insn.ops[numops] = '<';
+	      else
+	        if (the_insn.regs[numops] == 15)
+		  the_insn.ops[numops] = 'S';
+		else if (the_insn.regs[numops] == 10)
+		  the_insn.ops[numops] = '&';
+		else
+		  the_insn.ops[numops] = '@';
+	      if (*++dst != '\0')
+	        goto restart_scan;
+	      else
+	        break;
+	    }
+	  else if (*dst == '+')
+	    {
+	      if (preinc)
+	        {
+		  the_insn.error = _("Invalid address mode");
+		  return;
+		}
+	      postinc = 1;
+	      if (*++dst == '\0')
+	        {
+		  the_insn.error = _("Missing ']'");
+		  return;
+		}
+	      if (*dst == ']')
+	        {
+		  the_insn.ops[numops] = '>';
+		  if (*++dst != '\0')
+		    goto restart_scan;
+		  else
+		    break;
+		}
+	      mode = *dst;
+	      if ((mode == 'c') || (mode == 'r') || (mode == 'i'))
+	        {
+		  if (the_insn.regs[numops] & 1)
+		    {
+		      the_insn.error = _("Even address register required");
+		      return;
+		    }
+		  if (*++dst != ']')
+		    {
+		      the_insn.error = _("Missing ']'");
+		      return;
+		    }
+		  if (mode == 'c')
+		    {
+		      the_insn.ops[numops] = '*';
+		      if (*++dst != '\0')
+		        goto restart_scan;
+		    }
+		  else
+		    {
+		      the_insn.ops[numops] = (mode == 'r') ? '#' : '?';
+		      if (*++dst != '\0')
+		        {
+			  the_insn.error = _("No offset allowed for this mode");
+			  return;
+			}
+		    }
+		  break;
+		}
+	      else
+	        {
+		  the_insn.error = _("Invalid address mode");
+		  return;
+		}
+	    }
+	  else
+	    {
+	      the_insn.error = _("Invalid address mode");
+	      return;
+	    }
+
+	default: /* A constant, a symbol or a complex expression.  */
+	  if (!get_expression (str, &dst, numops))
+	    return;
+	  break;
+	}
+    }
+
+  /* This is because we started with numops = -1.  */
+  the_insn.nops = ++numops;
+
+  /* If we've seen a 'not' pseudo-insn, make sure the operands
+     are valid: either %dn or %dn,%dn,0.  */
+  if (not_hack
+      && !(((numops == 1) && strchr ("dDi", the_insn.ops[0]))
+           || ((numops == 3)
+	       && strchr ("dDi", the_insn.ops[0])
+	       && strchr ("dDi", the_insn.ops[1])
+	       && (the_insn.regs[0] == the_insn.regs[1])
+	       && (the_insn.ops[2] == '1')
+	       && (VAL (2) == 0))))
+    the_insn.error = _("Invalid operands for pseudo-insn `not'");
+}
+
+/* If INSERT_REG is non-zero, insert the register of operand REGNO
+   of type MODE at position WHERE in the_insn, otherwise insert a
+   constant value REGNO of type MODE at position WHERE.  */
+
+static void
+insert_reg_or_const (insert_reg, regno, mode, where)
+     int insert_reg, regno, where;
+     char mode;
+{
+  int new, old;
+
+  if (insert_reg)
+    regno = the_insn.regs[regno];
+
+  new = the_insn.nops;
+  for (old = new - 1; old >= where; --old, --new)
+    {
+      the_insn.prefix[new] = the_insn.prefix[old];
+      the_insn.opexp[new] = the_insn.opexp[old];
+      the_insn.ops[new] = the_insn.ops[old];
+      the_insn.regs[new] = the_insn.regs[old];
+      the_insn.matches_v[new] = the_insn.matches_v[old];
+      the_insn.matches_6[new] = the_insn.matches_6[old];
+      the_insn.matches_k[new] = the_insn.matches_k[old];
+      the_insn.pcrel[new] = the_insn.pcrel[old];
+      the_insn.is_odd[new] = the_insn.is_odd[old];
+      the_insn.bitpos[new] = the_insn.bitpos[old];
+    }
+
+  the_insn.prefix[where] = PREFIX_NONE;
+  the_insn.bitpos[where] = 0;
+  the_insn.ops[where] = mode;
+  memset ((char *) &the_insn.opexp[where], 0, sizeof (expressionS));
+  if (insert_reg)
+    {
+      the_insn.regs[where] = regno;
+      the_insn.matches_v[where] = 0;
+      the_insn.matches_6[where] = 0;
+      the_insn.matches_k[where] = 0;
+      the_insn.pcrel[where] = 0;
+      the_insn.is_odd[where] = 0;
+    }
+  else
+    {
+      the_insn.regs[where] = 0;
+      the_insn.matches_v[where] = !(regno & 1);
+      the_insn.matches_6[where] = !(regno & 3);
+      the_insn.matches_k[where] = !(regno & 3);
+      the_insn.pcrel[where] = 0;
+      the_insn.is_odd[where] = !(regno & 1);
+      VAL (where) = regno;
+    }
+  ++the_insn.nops;
+}
+
+/* If the_insn represents a valid 16-bit opcode, convert it to its
+   32-bit equivalent.  We only care about those opcodes that can't be
+   found automatically by find_opcode, plus those that are vital for
+   the relaxing pass (e.g. j, jeq and jne).  */
+
+static opcode_t *
+insn16_to_insn32 ()
+{
+  opcode_t *pop;
+  int i, op;
+  insn16_t *pinsn16;
+  char name[30];
+
+  /* 16-bit insns can't have prefixes.  */
+  if (the_insn.needs_prefix)
+    return (opcode_t *) 0;
+
+  /* Try to find a 16-bit opcode that matches the_insn.  */
+  pop = the_insn.code;
+  for (i = the_insn.code->insind; i <= the_insn.code->inslast; ++pop, ++i)
+    {
+      if ((pop->nr_operands != the_insn.nops)
+          || pop->len32 || !MATCHES_ISA (pop->isa))
+        continue;
+
+      for (op = 0; op < the_insn.nops; ++op)
+        {
+	  if (!strchr (pseudo_codes[(int) pop->args[op]], the_insn.ops[op]))
+	    break;
+	  if ((pop->args[op] == 'v') && !the_insn.matches_v[op])
+	    break;
+	  else if ((pop->args[op] == '6') && !the_insn.matches_6[op])
+	    break;
+	  else if ((pop->args[op] == 'k') && !the_insn.matches_k[op])
+	    break;
+	}
+      if (op == the_insn.nops)
+	break;
+    }
+
+  if (i > the_insn.code->inslast)
+    return (opcode_t *) 0;
+
+  /* Lookup the appropriate entry in insn16_table.  */
+  sprintf (name, "%s-%s", pop->name, pop->args);
+  if ((pinsn16 = (insn16_t *) str_hash_find (hash_insn16, name)) == NULL)
+    as_fatal (_("Internal error: couldn't find insn16 `%s'"), name);
+
+  if (pinsn16->neg_val1)
+    {
+      if (the_insn.ops[1] == 'U')
+        {
+	  as_bad (_("Can't convert to 32-bit insn: zconst8 operand unknown"));
+	  return (opcode_t *) 0;
+	}
+      VAL (1) = -VAL (1);
+      the_insn.ops[1] = '9';
+    }
+
+  /* Insert the necessary registers and/or constants.  */
+  if (pinsn16->nr_inserts >= 1)
+    insert_reg_or_const (pinsn16->reg_or_const1, pinsn16->regno_or_val1,
+		         pinsn16->op_type1, pinsn16->op_pos1);
+  if (pinsn16->nr_inserts == 2)
+    insert_reg_or_const (pinsn16->reg_or_const2, pinsn16->regno_or_val2,
+			 pinsn16->op_type2, pinsn16->op_pos2);
+
+  pop = pinsn16->new_code;
+  if (show_internals)
+    printf ("*** %s -> %s-%s (EXP)\n", name, pop->name, pop->args);
+#if EXT_LISTING
+  if (listing & LISTING_LISTING)
+    {
+      snprintf (EXT_BUF, _("Expanding %s -> %s-%s"),
+      		name, pop->name, pop->args);
+      ASM_NOTICE ();
+    }
+#endif /* EXT_LISTING  */
+
+  return pop;
+}
+
+/* Delete operand NR from the_insn.  */
+
+static void
+delete_operand (nr)
+     int nr;
+{
+  int new, old;
+
+  --the_insn.nops;
+  for (new = nr, old = nr + 1; new < the_insn.nops; ++new, ++old)
+    {
+      the_insn.prefix[new] = the_insn.prefix[old];
+      the_insn.opexp[new] = the_insn.opexp[old];
+      the_insn.ops[new] = the_insn.ops[old];
+      the_insn.regs[new] = the_insn.regs[old];
+      the_insn.matches_v[new] = the_insn.matches_v[old];
+      the_insn.matches_6[new] = the_insn.matches_6[old];
+      the_insn.matches_k[new] = the_insn.matches_k[old];
+      the_insn.pcrel[new] = the_insn.pcrel[old];
+      the_insn.is_odd[new] = the_insn.is_odd[old];
+      the_insn.bitpos[new] = the_insn.bitpos[old];
+    }
+}
+
+/* Try to optimize the_insn, i.e. try to convert it to a 16-bit
+   insn.  POP points to the 32-bit opcode that was found by
+   find_opcode, so we know that the_insn contains a valid insn.  */
+
+static opcode_t *
+optimize_insn (pop)
+     opcode_t *pop;
+{
+  insn32_t *pinsn32;
+  conv_t *palt;
+  int i, del_opnr;
+  char name[30];
+
+  sprintf (name, "%s-%s", pop->name, pop->args);
+  pinsn32 = (insn32_t *) str_hash_find (hash_insn32, name);
+  if (pinsn32 == NULL)
+    return pop;
+
+  for (i = 0; i < pinsn32->nr_alt; ++i)
+    {
+      palt = &pinsn32->alt[i];
+      del_opnr = -1;
+
+      switch (palt->test)
+        {
+	case 1:
+	  if (the_insn.regs[0] == the_insn.regs[1])
+	    del_opnr = 0;
+	  break;
+
+	case 2:
+	  if ((the_insn.regs[0] == the_insn.regs[1])
+	      && (the_insn.ops[2] != 'U')
+	      && strchr (pseudo_codes['4'], the_insn.ops[2]))
+	    del_opnr = 0;
+	  break;
+
+	case 3:
+	  if ((the_insn.regs[0] == 15) && (the_insn.regs[1] == 15)
+	      && (the_insn.ops[2] != 'U')
+	      && strchr (pseudo_codes['8'], the_insn.ops[2]))
+	    del_opnr = 0;
+	  break;
+
+	case 4:
+	  if ((the_insn.regs[0] == the_insn.regs[2])
+	      && (the_insn.regs[1] == 15))
+	    del_opnr = 2;
+	  break;
+
+	case 5:
+	  if ((the_insn.regs[0] == the_insn.regs[2])
+	      && (the_insn.regs[1] == 15)
+	      && (the_insn.ops[3] != 'U')
+	      && strchr (pseudo_codes['4'], the_insn.ops[3]))
+	    del_opnr = 2;
+	  break;
+
+	case 6:
+	  if ((the_insn.regs[0] == 15)
+	      && ((the_insn.ops[1] != 'U') && (VAL (1) == 0))
+	      && strchr (pseudo_codes['R'], the_insn.ops[2]))
+	    del_opnr = 1;
+	  break;
+
+	case 7:
+	  if (((the_insn.ops[1] != 'U') && (VAL (1) == 0))
+	      && strchr (pseudo_codes['m'], the_insn.ops[2]))
+	    del_opnr = 1;
+	  break;
+
+	case 8:
+	  if (((the_insn.ops[1] != 'U') && (VAL (1) == 1))
+	      && strchr (pseudo_codes['m'], the_insn.ops[2]))
+	    del_opnr = 1;
+	  break;
+
+	case 9:
+	  if ((the_insn.ops[2] != 'U') && (VAL (2) == 4))
+	    del_opnr = 2;
+	  break;
+
+	case 10:
+	  if ((the_insn.ops[2] != 'U') && (VAL (2) == 0))
+	    del_opnr = 2;
+	  break;
+
+	case 11:
+	  if ((the_insn.ops[2] != 'U') && (VAL (2) == 1))
+	    del_opnr = 2;
+	  break;
+
+	case 12:
+	  if ((the_insn.ops[2] != 'U') && (VAL (2) == 2))
+	    del_opnr = 2;
+	  break;
+
+	case 13:
+	  if ((the_insn.ops[1] != 'U') && (VAL (1) == 0))
+	    del_opnr = 1;
+	  break;
+
+	case 14:
+	  if ((the_insn.regs[0] == SP_REGNUM)
+	      && (the_insn.regs[1] == SP_REGNUM)
+	      && (the_insn.ops[2] != 'U')
+	      && ((VAL (2) >= -255) && (VAL (2) <= 0)))
+	    {
+	      VAL (2) = -VAL (2);
+	      del_opnr = 1;
+	    }
+	  break;
+
+	case 15:
+	  if ((the_insn.regs[0] == the_insn.regs[1])
+	      && ((the_insn.ops[2] != 'U') && (VAL (2) == 0)))
+	    {
+	      delete_operand (1);
+	      del_opnr = 2;
+	    }
+	  break;
+
+	case 16:
+	  if ((the_insn.regs[0] == the_insn.regs[3])
+	      && (the_insn.regs[1] == 15))
+	    del_opnr = 3;
+	  break;
+
+	case 17:
+	  if ((the_insn.ops[1] != 'U') && (VAL (1) == 4))
+	    del_opnr = 1;
+	  break;
+
+	case 18:
+	  if ((the_insn.ops[1] != 'U') && (VAL (1) == 0))
+	    del_opnr = 1;
+	  break;
+
+	case 19:
+	  if ((the_insn.ops[1] != 'U') && (VAL (1) == 1))
+	    del_opnr = 1;
+	  break;
+
+	case 20:
+	  if ((the_insn.ops[1] != 'U') && (VAL (1) == 2))
+	    del_opnr = 1;
+	  break;
+
+	case 21:
+	  if ((the_insn.ops[1] != 'U')
+	      && (VAL (1) >= 0) && (VAL (1) < 16))
+	    {
+	      /* No need to delete an operand, just set new opcode.  */
+	      pop = palt->new_code;
+	      if (show_internals)
+	        printf ("*** %s -> %s-%s (OPT)\n", name, pop->name, pop->args);
+#if EXT_LISTING
+	      if (listing & LISTING_LISTING)
+	        {
+		  snprintf (EXT_BUF, _("Optimizing %s -> %s-%s"),
+		  	    name, pop->name, pop->args);
+		  ASM_NOTICE ();
+		}
+#endif /* EXT_LISTING  */
+	    }
+	  break;
+
+	case 22:
+	  if ((the_insn.regs[0] == the_insn.regs[1])
+	      && (the_insn.ops[2] != 'U')
+	      && (VAL (2) >= -8) && (VAL (2) < 8))
+	    del_opnr = 1;
+	  break;
+
+	default:
+	  as_fatal (_("Internal error: illegal test code %d"), palt->test);
+	  break;
+	}
+
+      if (del_opnr >= 0)
+        {
+          delete_operand (del_opnr);
+	  pop = palt->new_code;
+	  if (show_internals)
+	    printf ("*** %s -> %s-%s (OPT)\n", name, pop->name, pop->args);
+#if EXT_LISTING
+	  if (listing & LISTING_LISTING)
+	    {
+	      snprintf (EXT_BUF, _("Optimizing %s -> %s-%s"),
+		  	name, pop->name, pop->args);
+	      ASM_NOTICE ();
+	    }
+#endif /* EXT_LISTING  */
+	  break;
+	}
+    }
+
+  return pop;
+}
+
+/* This is called before the (preliminary) opcode is determined for
+   the_insn.  We use this to perform special 16-bit jump optimizations.  */
+
+static void
+optimize_16bit_jumps ()
+{
+  opcode_t *pop;
+
+  if ((the_insn.code->name[0] != 'j')
+      || (the_insn.nops != 3)
+      || (the_insn.ops[0] != 'i')
+      || (the_insn.ops[1] != '1')
+      || (VAL (1) != 0)
+      || !strchr (pseudo_codes['R'], the_insn.ops[2]))
+    return;
+
+  if (!strcmp (the_insn.code->name, "jeq"))
+    /* jeq %d15,0,m -> jz %d15,R  */
+    pop = (opcode_t *) str_hash_find (hash_ops, "jz");
+  else if (!strcmp (the_insn.code->name, "jne"))
+    /* jne %d15,0,m -> jnz %d15,R  */
+    pop = (opcode_t *) str_hash_find (hash_ops, "jnz");
+  else
+    return;
+
+  if (pop == NULL)
+    return; /* Famous last words: "Can't happen"...  */
+
+  if (show_internals)
+    {
+      const char *no = the_insn.code->name, *nn = pop->name;
+      const char *ao = the_insn.code->args, *an = pop->args;
+
+      printf ("*** %s-%s -> %s-%s (OPT)\n", no, ao, nn, an);
+    }
+#if EXT_LISTING
+  if (listing & LISTING_LISTING)
+    {
+      snprintf (EXT_BUF, _("Optimizing %s-%s -> %s-%s"),
+	  	the_insn.code->name, the_insn.code->args,
+		pop->name, pop->args);
+      ASM_NOTICE ();
+    }
+#endif /* EXT_LISTING  */
+
+  delete_operand (1);
+  the_insn.code = pop;
+}
+
+/* Find an opcode that matches the_insn's opcode/operands.  */
+
+static opcode_t *
+find_opcode ()
+{
+  opcode_t *pop;
+  int i, op, nops;
+
+  if (the_insn.needs_prefix || big_insns_only)
+    use_insn32 = 1;
+  else if (big_insns)
+    use_insn32 = !use_insn16;
+
+  if (!use_insn32 && optimize_next)
+    optimize_16bit_jumps ();
+
+  pop = the_insn.code;
+  nops = the_insn.nops;
+
+  for (i = the_insn.code->insind; i <= the_insn.code->inslast; ++pop, ++i)
+    {
+      if ((pop->nr_operands != nops)
+          || !MATCHES_ISA (pop->isa)
+          || (use_insn32 && !pop->len32)
+          || (use_insn16 && pop->len32))
+        continue;
+
+      for (op = 0; op < nops; ++op)
+        {
+          if (!strchr (pseudo_codes[(int) pop->args[op]], the_insn.ops[op])
+              || ((pop->args[op] == 'v') && !the_insn.matches_v[op])
+              || ((pop->args[op] == '6') && !the_insn.matches_6[op])
+	      || ((pop->args[op] == 'k') && !the_insn.matches_k[op]))
+            break;
+
+	  /* Unless explicitly requested by a .code16 pseudo-opcode,
+	     don't accept a 16-bit insn if a non-PC-relative operand
+	     is unknown.  This reduces the relaxation pass to 16-bit
+	     PC-relative insns, which is a Good Thing[tm].  */
+	  if (!pop->len32 && (the_insn.ops[op] == 'U'))
+	    if (!use_insn16 && !strchr ("mxrRoO", pop->args[op]))
+	      break;
+	}
+
+      if (op == nops)
+	{
+	  if (!optimize_next || use_insn32 || !pop->len32)
+	    return pop;
+	  else
+	    return optimize_insn (pop);
+	}
+    }
+
+  /* We couldn't find a valid opcode so far, which could mean that
+     the user requested a 32-bit version of a 16-bit-only opcode,
+     or that a valid 16-bit insn has an unknown, non-PC-relative
+     operand.  If so, convert it to a 32-bit insn, or fail otherwise.  */
+
+  return insn16_to_insn32 ();
+}
+
+/* Print the contents of the_insn.  Used for debugging.  */
+
+static void
+print_the_insn ()
+{
+  int i;
+
+  printf ("%lx ", the_insn.opc_address);
+  printf ("<%s ", the_insn.code->name);
+  i = the_insn.code->len32 ? 32 : 16;
+  printf ("%s%d ", fmt_name[the_insn.code->format], i);
+  printf ("\"%s\"> ", the_insn.code->args);
+  if (the_insn.code->len32)
+    printf ("%08lx ", the_insn.opcode);
+  else
+    printf ("%04lx ", the_insn.opcode);
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      switch (the_insn.prefix[i])
+        {
+	case PREFIX_NONE:
+	  if (the_insn.bitpos[i])
+	    printf ("bpos:");
+	  break;
+
+	case PREFIX_HI:
+	  printf ("hi:");
+	  break;
+
+	case PREFIX_LO:
+	  printf ("lo:");
+	  break;
+
+	case PREFIX_SM:
+	  printf ("sm:");
+	  break;
+
+	case PREFIX_UP:
+	  printf ("up:");
+	  break;
+
+	case PREFIX_GOT:
+	  printf ("got:");
+	  break;
+
+	case PREFIX_GOTHI:
+	  printf ("gothi:");
+	  break;
+
+	case PREFIX_GOTLO:
+	  printf ("gotlo:");
+	  break;
+
+	case PREFIX_GOTUP:
+	  printf ("gotup:");
+	  break;
+
+	case PREFIX_GOTOFF:
+	  printf ("gotoff:");
+	  break;
+
+	case PREFIX_GOTOFFHI:
+	  printf ("gotoffhi:");
+	  break;
+
+	case PREFIX_GOTOFFLO:
+	  printf ("gotofflo:");
+	  break;
+
+	case PREFIX_GOTOFFUP:
+	  printf ("gotoffup:");
+	  break;
+
+	case PREFIX_GOTPC:
+	  printf ("gotpc:");
+	  break;
+
+	case PREFIX_GOTPCHI:
+	  printf ("gotpchi:");
+	  break;
+
+	case PREFIX_GOTPCLO:
+	  printf ("gotpclo:");
+	  break;
+
+	case PREFIX_GOTPCUP:
+	  printf ("gotpcup:");
+	  break;
+
+	case PREFIX_PLT:
+	  printf ("plt:");
+	  break;
+
+	case PREFIX_BITPOS:
+	  /* Already handled in PREFIX_NONE.  */
+	  break;
+	}
+
+      switch (the_insn.ops[i])
+        {
+	case 'd':
+	  printf ("d%d", the_insn.regs[i]);
+	  break;
+
+	case 'g':
+	  printf ("d%dl", the_insn.regs[i]);
+	  break;
+
+	case 'G':
+	  printf ("d%du", the_insn.regs[i]);
+	  break;
+
+	case '-':
+	  printf ("d%dll", the_insn.regs[i]);
+	  break;
+
+	case '+':
+	  printf ("d%duu", the_insn.regs[i]);
+	  break;
+
+	case 'l':
+	  printf ("d%dlu", the_insn.regs[i]);
+	  break;
+
+	case 'L':
+	  printf ("d%dul", the_insn.regs[i]);
+	  break;
+
+	case 'D':
+	  printf ("E%d", the_insn.regs[i]);
+	  break;
+
+	case 'i':
+	  printf ("d15");
+	  break;
+
+	case 'a':
+	  printf ("a%d", the_insn.regs[i]);
+	  break;
+
+	case 'A':
+	  printf ("A%d", the_insn.regs[i]);
+	  break;
+
+	case 'I':
+	  printf ("a15");
+	  break;
+
+	case 'P':
+	  printf ("sp");
+	  break;
+
+	case 'c':
+	  printf ("core reg");
+	  break;
+
+	case '1':
+	case '2':
+	case '3':
+	case 'f':
+	case '5':
+	case 'v':
+	case '6':
+	case '8':
+	case 'n':
+	case 'k':
+	case 'W':
+	case 'm':
+	case 'x':
+	case 'M':
+	case 't':
+	case 'T':
+	  printf ("%lu=0x%08lx", VAL (i), VAL (i));
+	  break;
+
+	case '4':
+	case 'F':
+	case '9':
+	case '0':
+	case 'w':
+	case 'r':
+	case 'R':
+	case 'o':
+	case 'O':
+	  printf ("%ld=0x%08lx", VAL (i), VAL (i));
+	  break;
+
+	case 'U':
+	  printf ("symbol(%s)", S_GET_NAME (the_insn.opexp[i].X_add_symbol));
+	  break;
+
+	case '@':
+	  printf ("[a%d]", the_insn.regs[i]);
+	  break;
+
+	case '&':
+	  printf ("[sp]");
+	  break;
+
+	case '<':
+	  printf ("[+a%d]", the_insn.regs[i]);
+	  break;
+
+	case '>':
+	  printf ("[a%d+]", the_insn.regs[i]);
+	  break;
+
+	case '*':
+	  printf ("[a%d+c]", the_insn.regs[i]);
+	  break;
+
+	case '#':
+	  printf ("[a%d+r]", the_insn.regs[i]);
+	  break;
+
+	case '?':
+	  printf ("[a%d+i]", the_insn.regs[i]);
+	  break;
+
+	case 'S':
+	  printf ("[a15]");
+	  break;
+	}
+
+      printf ("(%c)", the_insn.ops[i]);
+      if (the_insn.pcrel[i])
+        printf("(PCREL)");
+      if (i < (the_insn.nops - 1))
+        printf (", ");
+    }
+  printf ("\n");
+}
+
+/* Produce binary code for the_insn according to its format.
+   There are almost 40 instruction formats (each with up to
+   five operand fields), and each one has its own encoding
+   function.  Operation "Code Desert" starts here.  :-)  */
+
+/* Encode 18-bit absolute addresses (ABS and ABSB formats).  */
+
+static int
+insert_abs18 (code, i)
+     unsigned long *code;
+     int i;
+{
+  unsigned long val = VAL (i);
+
+  if (val & 0x0fffc000)
+    {
+      as_bad (_("Illegal 18-bit absolute address 0x%08lx"), val);
+      return 0;
+    }
+  *code |= ((val & 0x3f) << 16);
+  *code |= ((val & 0x3c0) << 22);
+  *code |= ((val & 0x3c00) << 12);
+  *code |= ((val & 0xf0000000) >> 16);
+  return 1;
+}
+
+static void
+encode_abs ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_ABS_NONE:
+	  continue;
+
+	case FMT_ABS_OFF18:
+	  CHECK_RELOC (i);
+	  if (!insert_abs18 (code, i))
+	    return;
+	  break;
+
+	case FMT_ABS_S1_D:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_absb ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_ABSB_NONE:
+	  continue;
+	
+	case FMT_ABSB_OFF18:
+	  CHECK_RELOC (i);
+	  if (!insert_abs18 (code, i))
+	    return;
+	  break;
+	
+	case FMT_ABSB_B:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 1) << 11);
+	  break;
+
+	case FMT_ABSB_BPOS3:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 7) << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_b ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+  unsigned long val;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_B_NONE:
+	  continue;
+	
+	case FMT_B_DISP24:
+	  CHECK_RELOC (i);
+	  val = VAL (i);
+	  if (val & 1)
+	    {
+	      as_bad (_("Offset or absolute address 0x%lx is not even"), val);
+	      return;
+	    }
+	  if (the_insn.code->args[i] == 'O')
+	    val >>= 1;
+	  else if (the_insn.code->args[i] == 'T')
+	    {
+	      if (val & 0x0fe00001)
+	        {
+		  as_bad (_("Illegal absolute address 0x%lx"), val);
+		  return;
+		}
+	      val >>= 1;
+	      val |= ((val & 0x78000000) >> 7);
+	    }
+	  *code |= ((val & 0xffff) << 16);
+	  *code |= ((val & 0xff0000) >> 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_bit ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_BIT_NONE:
+	  continue;
+	
+	case FMT_BIT_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+	
+	case FMT_BIT_P2:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0x1f) << 23);
+	  break;
+
+	case FMT_BIT_P1:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0x1f) << 16);
+	  break;
+
+	case FMT_BIT_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_BIT_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_bo ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_BO_NONE:
+	  continue;
+	
+	case FMT_BO_OFF10:
+	  if (the_insn.prefix[i] != PREFIX_NONE)
+	    {
+	      as_bad (_("Illegal prefix for absolute offset"));
+	      return;
+	    }
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0x3f) << 16);
+	  *code |= ((VAL (i) & 0x3c0) << 22);
+	  break;
+	
+	case FMT_BO_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_BO_S1_D:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_bol ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode, val = 0;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_BOL_NONE:
+	  continue;
+	
+	case FMT_BOL_OFF16:
+	  CHECK_RELOC (i);
+	  switch (the_insn.prefix[i])
+	    {
+	    case PREFIX_NONE:
+	      val = VAL (i);
+	      break;
+
+	    case PREFIX_LO:
+	      val = (VAL (i) & 0xffff);
+	      break;
+
+	    default:
+	      as_bad (_("Illegal prefix for absolute offset"));
+	      return;
+	    }
+	  *code |= ((val & 0x3f) << 16);
+	  *code |= ((val & 0x3c0) << 22);
+	  *code |= ((val & 0xfc00) << 12);
+	  break;
+
+	case FMT_BOL_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_BOL_S1_D:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_brc ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_BRC_NONE:
+	  continue;
+	
+	case FMT_BRC_DISP15:
+	  CHECK_RELOC (i);
+	  if (VAL (i) & 1)
+	    {
+	      as_bad (_("Offset 0x%lx is not even"), VAL (i));
+	      return;
+	    }
+	  *code |= (((VAL (i) >> 1) & 0x7fff) << 16);
+	  break;
+
+	case FMT_BRC_CONST4:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0xf) << 12);
+	  break;
+
+	case FMT_BRC_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_brn ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_BRN_NONE:
+	  continue;
+	
+	case FMT_BRN_DISP15:
+	  CHECK_RELOC (i);
+	  if (VAL (i) & 1)
+	    {
+	      as_bad (_("Offset 0x%lx is not even"), VAL (i));
+	      return;
+	    }
+	  *code |= (((VAL (i) >> 1) & 0x7fff) << 16);
+	  break;
+	
+	case FMT_BRN_N:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0xf) << 12);
+	  *code |= ((VAL (i) & 0x10) << 3);
+	  break;
+
+	case FMT_BRN_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_brr ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_BRR_NONE:
+	  continue;
+	
+	case FMT_BRR_DISP15:
+	  CHECK_RELOC (i);
+	  if (VAL (i) & 1)
+	    {
+	      as_bad (_("Offset 0x%lx is not even"), VAL (i));
+	      return;
+	    }
+	  *code |= (((VAL (i) >> 1) & 0x7fff) << 16);
+	  break;
+	
+	case FMT_BRR_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_BRR_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rc ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RC_NONE:
+	  continue;
+	
+	case FMT_RC_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RC_CONST9:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0x1ff) << 12);
+	  break;
+
+	case FMT_RC_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rcpw ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RCPW_NONE:
+	  continue;
+	
+	case FMT_RCPW_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RCPW_P:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0x1f) << 23);
+	  break;
+
+	case FMT_RCPW_W:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0x1f) << 16);
+	  break;
+
+	case FMT_RCPW_CONST4:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0xf) << 12);
+	  break;
+
+	case FMT_RCPW_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rcr ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RCR_NONE:
+	  continue;
+	
+	case FMT_RCR_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RCR_S3:
+	  *code |= (the_insn.regs[i] << 24);
+	  break;
+
+	case FMT_RCR_CONST9:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0x1ff) << 12);
+	  break;
+
+	case FMT_RCR_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rcrr ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RCRR_NONE:
+	  continue;
+	
+	case FMT_RCRR_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RCRR_S3:
+	  *code |= (the_insn.regs[i] << 24);
+	  break;
+
+	case FMT_RCRR_CONST4:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0xf) << 12);
+	  break;
+
+	case FMT_RCRR_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rcrw ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RCRW_NONE:
+	  continue;
+	
+	case FMT_RCRW_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RCRW_S3:
+	  *code |= (the_insn.regs[i] << 24);
+	  break;
+
+	case FMT_RCRW_W:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0x1f) << 16);
+	  break;
+
+	case FMT_RCRW_CONST4:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0xf) << 12);
+	  break;
+
+	case FMT_RCRW_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rlc ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RLC_NONE:
+	  continue;
+	
+	case FMT_RLC_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RLC_CONST16:
+	  CHECK_RELOC (i);
+	  switch (the_insn.prefix[i])
+	    {
+	    case PREFIX_NONE:
+	    case PREFIX_LO:
+	      *code |= ((VAL (i) & 0xffff) << 12);
+	      break;
+
+	    case PREFIX_HI:  
+	      *code |= ((((VAL (i) + 0x8000) >> 16) & 0xffff) << 12);
+	      break;
+
+	    case PREFIX_UP:
+	      *code |= (((VAL (i) >> 16) & 0xffff) << 12);
+	      break;
+
+	    default:  
+	      as_bad (_("Illegal prefix for absolute value"));
+	      break;
+	    }  
+	  break;
+	
+	case FMT_RLC_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rr ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RR_NONE:
+	  continue;
+	
+	case FMT_RR_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RR_N:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 3) << 16);
+	  break;
+
+	case FMT_RR_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_RR_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rr1 ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RR1_NONE:
+	  continue;
+	
+	case FMT_RR1_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RR1_N:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 3) << 16);
+	  break;
+
+	case FMT_RR1_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_RR1_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rr2 ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc ATTRIBUTE_UNUSED;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RR2_NONE:
+	  continue;
+	
+	case FMT_RR2_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RR2_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_RR2_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rrpw ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RRPW_NONE:
+	  continue;
+	
+	case FMT_RRPW_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RRPW_P:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0x1f) << 23);
+	  break;
+
+	case FMT_RRPW_W:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0x1f) << 16);
+	  break;
+
+	case FMT_RRPW_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_RRPW_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rrr ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RRR_NONE:
+	  continue;
+	
+	case FMT_RRR_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RRR_S3:
+	  *code |= (the_insn.regs[i] << 24);
+	  break;
+
+	case FMT_RRR_N:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 3) << 16);
+	  break;
+
+	case FMT_RRR_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_RRR_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rrr1 ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RRR1_NONE:
+	  continue;
+	
+	case FMT_RRR1_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RRR1_S3:
+	  *code |= (the_insn.regs[i] << 24);
+	  break;
+
+	case FMT_RRR1_N:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 3) << 16);
+	  break;
+
+	case FMT_RRR1_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_RRR1_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rrr2 ()
+{
+  int i;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RRR2_NONE:
+	  continue;
+	
+	case FMT_RRR2_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RRR2_S3:
+	  *code |= (the_insn.regs[i] << 24);
+	  break;
+
+	case FMT_RRR2_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_RRR2_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rrrr ()
+{
+  int i;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RRRR_NONE:
+	  continue;
+	
+	case FMT_RRRR_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RRRR_S3:
+	  *code |= (the_insn.regs[i] << 24);
+	  break;
+
+	case FMT_RRRR_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_RRRR_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_rrrw ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_RRRW_NONE:
+	  continue;
+	
+	case FMT_RRRW_D:
+	  *code |= (the_insn.regs[i] << 28);
+	  break;
+
+	case FMT_RRRW_S3:
+	  *code |= (the_insn.regs[i] << 24);
+	  break;
+
+	case FMT_RRRW_W:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0x1f) << 16);
+	  break;
+
+	case FMT_RRRW_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_RRRW_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_sys ()
+{
+  int i;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SYS_NONE:
+	  continue;
+	
+	case FMT_SYS_S1_D:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_sb ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SB_NONE:
+	  continue;
+
+	case FMT_SB_DISP8:
+	  CHECK_RELOC (i);
+	  if (VAL (i) & 1)
+	    {
+	      as_bad (_("Offset 0x%lx is not even"), VAL (i));
+	      return;
+	    }
+	  *code |= (((VAL (i) >> 1) & 0xff) << 8);
+	  break;
+
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_sbc ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SBC_NONE:
+	  continue;
+	
+	case FMT_SBC_CONST4:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0xf) << 12);
+	  break;
+
+	case FMT_SBC_DISP4:
+	  CHECK_RELOC (i);
+	  if (VAL (i) & 1)
+	    {
+	      as_bad (_("Offset 0x%lx is not even"), VAL (i));
+	      return;
+	    }
+	  *code |= (((VAL (i) >> 1) & 0xf) << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_sbr ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SBR_NONE:
+	  continue;
+	
+	case FMT_SBR_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+	
+	case FMT_SBR_DISP4:
+	  CHECK_RELOC (i);
+	  if (VAL (i) & 1)
+	    {
+	      as_bad (_("Offset 0x%lx is not even"), VAL (i));
+	      return;
+	    }
+	  *code |= (((VAL (i) >> 1) & 0xf) << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_sbrn ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SBRN_NONE:
+	  continue;
+	
+	case FMT_SBRN_N:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0xf) << 12);
+	  if (the_insn.code->args[i] == '5')
+	    *code |= ((VAL (i) & 0x10) << 3);
+	  break;
+
+	case FMT_SBRN_DISP4:
+	  CHECK_RELOC (i);
+	  if (VAL (i) & 1)
+	    {
+	      as_bad (_("Offset 0x%lx is not even"), VAL (i));
+	      return;
+	    }
+	  *code |= (((VAL (i) >> 1) & 0xf) << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_sc ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SC_NONE:
+	  continue;
+	
+	case FMT_SC_CONST8:
+	  CHECK_RELOC (i);
+	  if (the_insn.code->args[i] == 'k')
+	    *code |= (((VAL (i) >> 2) & 0xff) << 8);
+	  else
+	    *code |= ((VAL (i) & 0xff) << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_slr ()
+{
+  int i;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SLR_NONE:
+	  continue;
+	
+	case FMT_SLR_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_SLR_D:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_slro ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SLRO_NONE:
+	  continue;
+	
+	case FMT_SLRO_OFF4:
+	  CHECK_RELOC (i);
+	  if (the_insn.code->args[i] == 'v')
+	    {
+	      if (VAL (i) & 1)
+	        {
+	          as_bad (_("Offset %d is not even"), (int) VAL (i));
+		  return;
+	        }
+	      *code |= (((VAL (i) >> 1) & 0xf) << 12);
+	    }
+	  else if (the_insn.code->args[i] == '6')
+	    {
+	      if (VAL (i) & 3)
+	        {
+		  as_bad (_("Offset %d is not a multiple of 4"), (int) VAL (i));
+		  return;
+		}
+	      *code |= (((VAL (i) >> 2) & 0xf) << 12);
+	    }
+	  else
+	    *code |= ((VAL (i) & 0xf) << 12);
+	  break;
+	
+	case FMT_SLRO_D:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_sr ()
+{
+  int i;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SR_NONE:
+	  continue;
+	
+	case FMT_SR_S1_D:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_src ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SRC_NONE:
+	  continue;
+	
+	case FMT_SRC_CONST4:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 0xf) << 12);
+	  break;
+
+	case FMT_SRC_S1_D:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_sro ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SRO_NONE:
+	  continue;
+	
+	case FMT_SRO_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_SRO_OFF4:
+	  CHECK_RELOC (i);
+	  if (the_insn.code->args[i] == 'v')
+	    {
+	      if (VAL (i) & 1)
+	        {
+	          as_bad (_("Offset %d is not even"), (int) VAL (i));
+		  return;
+	        }
+	      *code |= (((VAL (i) >> 1) & 0xf) << 8);
+	    }
+	  else if (the_insn.code->args[i] == '6')
+	    {
+	      if (VAL (i) & 3)
+	        {
+		  as_bad (_("Offset %d is not a multiple of 4"), (int) VAL (i));
+		  return;
+		}
+	      *code |= (((VAL (i) >> 2) & 0xf) << 8);
+	    }
+	  else
+	    *code |= ((VAL (i) & 0xf) << 8);
+	  break;
+	  
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_srr ()
+{
+  int i;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SRR_NONE:
+	  continue;
+	
+	case FMT_SRR_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_SRR_S1_D:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_srrs ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SRRS_NONE:
+	  continue;
+	
+	case FMT_SRRS_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_SRRS_S1_D:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+
+	case FMT_SRRS_N:
+	  CHECK_RELOC (i);
+	  *code |= ((VAL (i) & 3) << 6);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_ssr ()
+{
+  int i;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SSR_NONE:
+	  continue;
+	
+	case FMT_SSR_S2:
+	  *code |= (the_insn.regs[i] << 12);
+	  break;
+
+	case FMT_SSR_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+static void
+encode_ssro ()
+{
+  int i;
+  enum bfd_reloc_code_real reloc;
+  unsigned long *code = &the_insn.opcode;
+
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] == 'U')
+        continue;
+
+      switch (the_insn.code->fields[i])
+        {
+	case FMT_SSRO_NONE:
+	  continue;
+	
+	case FMT_SSRO_OFF4:
+	  CHECK_RELOC (i);
+	  if (the_insn.code->args[i] == 'v')
+	    {
+	      if (VAL (i) & 1)
+	        {
+	          as_bad (_("Offset %d is not even"), (int) VAL (i));
+		  return;
+	        }
+	      *code |= (((VAL (i) >> 1) & 0xf) << 12);
+	    }
+	  else if (the_insn.code->args[i] == '6')
+	    {
+	      if (VAL (i) & 3)
+	        {
+		  as_bad (_("Offset %d is not a multiple of 4"), (int) VAL (i));
+		  return;
+		}
+	      *code |= (((VAL (i) >> 2) & 0xf) << 12);
+	    }
+	  else
+	    *code |= ((VAL (i) & 0xf) << 12);
+	  break;
+
+	case FMT_SSRO_S1:
+	  *code |= (the_insn.regs[i] << 8);
+	  break;
+	
+	default:
+	  as_fatal (_("Illegal insn field '%c'"), the_insn.code->fields[i]);
+	}
+    }
+}
+
+/* Return the relocation type for operand OPNR of the_insn.  This
+   also catches cases where a prefix was specified, but either the
+   operand may not be prefixed at all, or the given prefix is not
+   allowed for this particular operand.  */
+
+static enum bfd_reloc_code_real
+find_relocation (opnr)
+     int opnr;
+{
+  int pfx_allowed = 0;
+  char place = the_insn.code->fields[opnr];
+  char type = the_insn.code->args[opnr];
+  enum bfd_reloc_code_real reloc = NO_RELOC;
+
+  switch (the_insn.code->format)
+    {
+    case TRICORE_FMT_ABS:
+      if (place == FMT_ABS_OFF18)
+        reloc = BFD_RELOC_TRICORE_18ABS;
+      break;
+
+    case TRICORE_FMT_ABSB:
+      if (place == FMT_ABSB_OFF18)
+        reloc = BFD_RELOC_TRICORE_18ABS;
+      else if (place == FMT_ABSB_B)
+        reloc = BFD_RELOC_TRICORE_1BIT;
+      else if (place == FMT_ABSB_BPOS3)
+        reloc = BFD_RELOC_TRICORE_3POS;
+      break;
+
+    case TRICORE_FMT_B:
+      if (place == FMT_B_DISP24)
+        {
+          if (type == 'T')
+            reloc = BFD_RELOC_TRICORE_24ABS;
+          else if (type == 'O')
+	    {
+	      if (the_insn.prefix[opnr] == PREFIX_PLT)
+                {
+	          pfx_allowed = 1;
+	          reloc = BFD_RELOC_TRICORE_PLT;
+	        }	
+	      else if (the_insn.is_call)
+	        reloc = BFD_RELOC_TRICORE_24CALL;
+	      else
+                reloc = BFD_RELOC_TRICORE_24REL;
+	    }
+	}
+      break;
+
+    case TRICORE_FMT_BIT:
+      if (place == FMT_BIT_P1)
+        reloc = BFD_RELOC_TRICORE_5POS;
+      else if (place == FMT_BIT_P2)
+        reloc = BFD_RELOC_TRICORE_5POS2;
+      break;
+
+    case TRICORE_FMT_BO:
+      if (place == FMT_BO_OFF10)
+        {
+          if (the_insn.prefix[opnr] == PREFIX_SM)
+            {
+	      pfx_allowed = 1;
+	      reloc = BFD_RELOC_TRICORE_10SM;
+	    }  
+	  else  
+	    reloc = BFD_RELOC_TRICORE_10OFF;
+        }
+      break;
+
+    case TRICORE_FMT_BOL:
+      if (place == FMT_BOL_OFF16)
+	{
+	  pfx_allowed = 1;
+          switch (the_insn.prefix[opnr])
+	    {
+	    case PREFIX_SM:
+	      reloc = BFD_RELOC_TRICORE_16SM;
+	      break;
+
+	    case PREFIX_LO:
+	      reloc = BFD_RELOC_TRICORE_LO2;
+	      break;
+
+	    case PREFIX_GOT:
+	      reloc = BFD_RELOC_TRICORE_GOT2;
+	      break;
+
+	    case PREFIX_GOTLO:
+	      reloc = BFD_RELOC_TRICORE_GOTLO2;
+	      break;
+
+	    case PREFIX_GOTOFF:
+	      reloc = BFD_RELOC_TRICORE_GOTOFF2;
+	      break;
+
+	    case PREFIX_GOTOFFLO:
+	      reloc = BFD_RELOC_TRICORE_GOTOFFLO2;
+	      break;
+
+	    case PREFIX_GOTPC:
+	      reloc = BFD_RELOC_TRICORE_GOTPC2;
+	      break;
+
+	    case PREFIX_GOTPCLO:
+	      reloc = BFD_RELOC_TRICORE_GOTPCLO2;
+	      break;
+
+	    default:  
+	      reloc = BFD_RELOC_TRICORE_16OFF;
+	      pfx_allowed = 0;
+	      break;
+	    }
+	}    
+      break;
+
+    case TRICORE_FMT_BRC:
+      if (place == FMT_BRC_DISP15)
+        reloc = BFD_RELOC_TRICORE_15REL;
+      else if (place == FMT_BRC_CONST4)
+        {
+          if (type == '4')
+	    reloc = BFD_RELOC_TRICORE_BRCC;
+	  else if (type == 'f')
+	    reloc = BFD_RELOC_TRICORE_BRCZ;
+        }
+      break;
+
+    case TRICORE_FMT_BRN:
+      if (place == FMT_BRN_DISP15)
+        reloc = BFD_RELOC_TRICORE_15REL;
+      else if (place == FMT_BRN_N)
+        reloc = BFD_RELOC_TRICORE_BRNN;
+      break;
+
+    case TRICORE_FMT_BRR:
+      if (place == FMT_BRR_DISP15)
+        reloc = BFD_RELOC_TRICORE_15REL;
+      break;
+
+    case TRICORE_FMT_RC:
+      if (place == FMT_RC_CONST9)
+        {
+          if (type == '9')
+	    reloc = BFD_RELOC_TRICORE_9SCONST;
+	  else if (type == 'n')
+	    reloc = BFD_RELOC_TRICORE_9ZCONST;
+        }
+      break;
+
+    case TRICORE_FMT_RCPW:
+      if (place == FMT_RCPW_P)
+        reloc = BFD_RELOC_TRICORE_5POS2;
+      else if (place == FMT_RCPW_W)
+        reloc = BFD_RELOC_TRICORE_5POS;
+      else if (place == FMT_RCPW_CONST4)
+        reloc = BFD_RELOC_TRICORE_BRCZ;
+      break;
+
+    case TRICORE_FMT_RCR:
+      if (place == FMT_RCR_CONST9)
+        {
+          if (type == '9')
+	    reloc = BFD_RELOC_TRICORE_9SCONST;
+	  else if (type == 'n')
+	    reloc = BFD_RELOC_TRICORE_9ZCONST;
+	}    
+      break;
+
+    case TRICORE_FMT_RCRR:
+      if (place == FMT_RCRR_CONST4)
+        reloc = BFD_RELOC_TRICORE_BRCZ;
+      break;
+
+    case TRICORE_FMT_RCRW:
+      if (place == FMT_RCRW_W)
+        reloc = BFD_RELOC_TRICORE_5POS;
+      else if (place == FMT_RCRW_CONST4)
+        reloc = BFD_RELOC_TRICORE_BRCZ;
+      break;
+
+    case TRICORE_FMT_RLC:
+      if (place == FMT_RLC_CONST16)
+	{
+          pfx_allowed = 1;
+	  switch (the_insn.prefix[opnr])
+	    {
+	    case PREFIX_HI:
+	      reloc = BFD_RELOC_TRICORE_HIADJ;
+	      break;
+
+	    case PREFIX_LO:
+	      reloc = BFD_RELOC_TRICORE_LO;
+	      break;
+
+	    case PREFIX_SM:
+	      reloc = BFD_RELOC_TRICORE_16SM2;
+	      break;
+
+	    case PREFIX_UP:
+	      reloc = BFD_RELOC_TRICORE_HI;
+	      break;
+
+	    case PREFIX_GOT:
+	      reloc = BFD_RELOC_TRICORE_GOT;
+	      break;
+
+	    case PREFIX_GOTHI:
+	      reloc = BFD_RELOC_TRICORE_GOTHI;
+	      break;
+
+	    case PREFIX_GOTLO:
+	      reloc = BFD_RELOC_TRICORE_GOTLO;
+	      break;
+
+	    case PREFIX_GOTUP:
+	      reloc = BFD_RELOC_TRICORE_GOTUP;
+	      break;
+
+	    case PREFIX_GOTOFF:
+	      reloc = BFD_RELOC_TRICORE_GOTOFF;
+	      break;
+
+	    case PREFIX_GOTOFFHI:
+	      reloc = BFD_RELOC_TRICORE_GOTOFFHI;
+	      break;
+
+	    case PREFIX_GOTOFFLO:
+	      reloc = BFD_RELOC_TRICORE_GOTOFFLO;
+	      break;
+
+	    case PREFIX_GOTOFFUP:
+	      reloc = BFD_RELOC_TRICORE_GOTOFFUP;
+	      break;
+
+	    case PREFIX_GOTPC:
+	      reloc = BFD_RELOC_TRICORE_GOTPC;
+	      break;
+
+	    case PREFIX_GOTPCHI:
+	      reloc = BFD_RELOC_TRICORE_GOTPCHI;
+	      break;
+
+	    case PREFIX_GOTPCLO:
+	      reloc = BFD_RELOC_TRICORE_GOTPCLO;
+	      break;
+
+	    case PREFIX_GOTPCUP:
+	      reloc = BFD_RELOC_TRICORE_GOTPCUP;
+	      break;
+
+	    case PREFIX_PLT:
+	      as_bad (_("Prefix plt: not allowed here"));
+	      break;
+
+	    default:
+	      pfx_allowed = 0;
+              if (type == 'w')
+	        reloc = BFD_RELOC_TRICORE_16CONST;
+	      else
+	        reloc = BFD_RELOC_TRICORE_LO;
+	      break;
+	    }  
+	}
+      break;
+
+    case TRICORE_FMT_RR:
+      if (place == FMT_RR_N)
+        reloc = BFD_RELOC_TRICORE_RRN;
+      break;
+
+    case TRICORE_FMT_RR1:
+      if (place == FMT_RR1_N)
+        reloc = BFD_RELOC_TRICORE_RRN;
+      break;
+
+    case TRICORE_FMT_RR2:
+      /* No relocateable fields.  */
+      break;
+
+    case TRICORE_FMT_RRPW:
+      if (place == FMT_RRPW_P)
+        reloc = BFD_RELOC_TRICORE_5POS2;
+      else if (place == FMT_RRPW_W)
+        reloc = BFD_RELOC_TRICORE_5POS;
+      break;
+
+    case TRICORE_FMT_RRR:
+      if (place == FMT_RRR_N)
+        reloc = BFD_RELOC_TRICORE_RRN;
+      break;
+
+    case TRICORE_FMT_RRR1:
+      if (place == FMT_RRR1_N)
+        reloc = BFD_RELOC_TRICORE_RRN;
+      break;
+
+    case TRICORE_FMT_RRR2:
+      /* No relocateable fields.  */
+      break;
+
+    case TRICORE_FMT_RRRR:
+      /* No relocateable fields.  */
+      break;
+
+    case TRICORE_FMT_RRRW:
+      if (place == FMT_RRRW_W)
+        reloc = BFD_RELOC_TRICORE_5POS;
+      break;
+
+    case TRICORE_FMT_SYS:
+      /* No relocateable fields.  */
+      break;
+
+    case TRICORE_FMT_SB:
+      if (place == FMT_SB_DISP8)
+        reloc = BFD_RELOC_TRICORE_8REL;
+      break;
+
+    case TRICORE_FMT_SBC:
+      if (place == FMT_SBC_CONST4)
+        reloc = BFD_RELOC_TRICORE_4CONST;
+      else if (place == FMT_SBC_DISP4)
+	{
+	  if (type == 'm')
+            reloc = BFD_RELOC_TRICORE_4REL;
+	  else
+	    reloc = BFD_RELOC_TRICORE_5REL;
+	}    
+      break;
+
+    case TRICORE_FMT_SBR:
+      if (place == FMT_SBR_DISP4)
+        {
+	  if (the_insn.is_loop)
+            reloc = BFD_RELOC_TRICORE_4REL2;
+	  else if (type == 'm')
+            reloc = BFD_RELOC_TRICORE_4REL;
+	  else  
+            reloc = BFD_RELOC_TRICORE_5REL;
+        }
+      break;
+
+    case TRICORE_FMT_SBRN:
+      if (place == FMT_SBRN_N)
+        {
+          if (type == 'f')
+            reloc = BFD_RELOC_TRICORE_4POS;
+	  else
+            reloc = BFD_RELOC_TRICORE_5POS3;
+	}    
+      else if (place == FMT_SBRN_DISP4)
+        reloc = BFD_RELOC_TRICORE_4REL;
+      break;
+
+    case TRICORE_FMT_SC:
+      if (place == FMT_SC_CONST8)
+        {
+          if (type == 'k')
+            reloc = BFD_RELOC_TRICORE_8CONST2;
+	  else
+            reloc = BFD_RELOC_TRICORE_8CONST;
+        }
+      break;
+
+    case TRICORE_FMT_SLR:
+      /* No relocateable fields.  */
+      break;
+
+    case TRICORE_FMT_SLRO:
+      if (place == FMT_SLRO_OFF4)
+        {
+          if (type == 'f')
+	    reloc = BFD_RELOC_TRICORE_42OFF;
+	  else if (type == 'v')
+	    reloc = BFD_RELOC_TRICORE_42OFF2;
+	  else if (type == '6')
+	    reloc = BFD_RELOC_TRICORE_42OFF4;
+	}    
+      break;
+
+    case TRICORE_FMT_SR:
+      /* No relocateable fields.  */
+      break;
+
+    case TRICORE_FMT_SRC:
+      if (place == FMT_SRC_CONST4)
+        {
+          if (type == '4')
+	    reloc = BFD_RELOC_TRICORE_4CONST;
+	  else if (type == 'f')
+	    reloc = BFD_RELOC_TRICORE_4OFF;
+        }
+      break;
+
+    case TRICORE_FMT_SRO:
+      if (place == FMT_SRO_OFF4)
+        {
+          if (type == 'f')
+	    reloc = BFD_RELOC_TRICORE_42OFF;
+	  else if (type == 'v')
+	    reloc = BFD_RELOC_TRICORE_42OFF2;
+	  else if (type == '6')
+	    reloc = BFD_RELOC_TRICORE_42OFF4;
+	}    
+      break;
+
+    case TRICORE_FMT_SRR:
+      /* No relocateable fields.  */
+      break;
+
+    case TRICORE_FMT_SRRS:
+      if (place == FMT_SRRS_N)
+        reloc = BFD_RELOC_TRICORE_2OFF;
+      break;
+
+    case TRICORE_FMT_SSR:
+      /* No relocateable fields.  */
+      break;
+
+    case TRICORE_FMT_SSRO:
+      if (place == FMT_SSRO_OFF4)
+        {
+          if (type == 'f')
+	    reloc = BFD_RELOC_TRICORE_4OFF;
+	  else if (type == 'v')
+	    reloc = BFD_RELOC_TRICORE_4OFF2;
+	  else if (type == '6')
+	    reloc = BFD_RELOC_TRICORE_4OFF4;
+	}    
+      break;
+
+    default:
+      as_fatal (_("Internal error: illegal instruction format %d\n"),
+		the_insn.code->format);
+    }
+
+  if (reloc == NO_RELOC)
+    as_fatal (_("No reloc found for operand %d\n"), opnr);
+
+  if (!pfx_allowed && (the_insn.prefix[opnr] != PREFIX_NONE))
+    {
+      as_bad (_("Illegal prefix for operand %d\n"), opnr);
+      return NO_RELOC;
+    }
+
+  return reloc;
+}
+
+/* If a TriCore insn could be successfully parsed and encoded
+   (hooray!), we finally come here to celebrate the frag hack.
+   Party on, insn!  Resistance is futile -- you'll be emitted!  */
+
+static void
+emit_code ()
+{
+  int i, oplen = the_insn.code->len32 ? 4 : 2;
+  enum bfd_reloc_code_real reloc;
+  char *pfrag;
+  int dont_relax, add_bytes; /* Extra k3wl description of this function.  */
+  relax_substateT state;
+
+  /* Make sure the current frag is large enough to hold this
+     insn, even if it is subject to relaxation.  This is
+     necessary because we always call frag_more for the fix
+     part and frag_var for the variable part.  frag_var will
+     start a new frag if there's not enough room for the
+     variable part, so it could happen that the insn's fix
+     and variable parts live in different frags.  Uh-oh...  */
+  frag_grow (MAX_RELAXED_INSN_SIZE);
+
+  /* Handle CPU.048 workaround, if so requested.  */
+  if (workaround_cpu48)
+    {
+      static segT current_seg = (segT) 0;
+      static subsegT current_subseg = (subsegT) 0;
+      static int workaround_cpu48_pending = 0;
+      static int addressregno = 0;
+      static int double_addressreg = 0;
+
+      if (workaround_cpu48_pending)
+        {
+	  if ((current_seg == now_seg) && (current_subseg == now_subseg))
+	    {
+	      const char *name = the_insn.code->name;
+
+	      if ((!strcmp (name, "ji")
+	           || !strcmp (name, "jli")
+		   || !strcmp (name, "calli"))
+		  && ((the_insn.regs[0] == addressregno)
+		      || (double_addressreg
+		          ? (the_insn.regs[0] == (addressregno + 1))
+		          : 0)))
+		{
+		  if (show_internals)
+		    printf ("*** Inserting NOP (workaround "
+		    	    "for CPU_TC.048 bug).\n");
+#if EXT_LISTING
+		  ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround "
+		      			   "for bug CPU_TC.048"));
+#endif
+
+		  if (use_insn32)
+		    {
+		      pfrag = frag_more (4);
+		      md_number_to_chars (pfrag, 0x0d, 4);
+		    }
+		  else
+		    {
+		      pfrag = frag_more (2);
+		      md_number_to_chars (pfrag, 0x00, 2);
+		    }
+
+		  frag_grow (MAX_RELAXED_INSN_SIZE);
+	          workaround_cpu48_pending = 0;
+		}
+	      else
+	        {
+	          workaround_cpu48_pending = 0;
+		  goto recheck_cpu48;
+		}
+	    }
+	}
+      else
+        {
+	  const char *name;
+
+ recheck_cpu48:
+	  name = the_insn.code->name;
+	  if ((name[0] == 'l') && (name[1] == 'd') && (name[2] == '.')
+	      && (!strcmp (name, "ld.a") || !strcmp (name, "ld.da")))
+	    {
+	      workaround_cpu48_pending = 1;
+	      current_seg = now_seg;
+	      current_subseg = now_subseg;
+	      addressregno = the_insn.regs[0];
+	      double_addressreg = (name[3] == 'd');
+	    }
+	}
+    }
+
+  /* Handle CPU.050 workaround, if so requested.  */
+  if (workaround_cpu50)
+    {
+      static segT current_seg = (segT) 0;
+      static subsegT current_subseg = (subsegT) 0;
+      static int workaround_cpu50_pending = 0;
+
+      if (workaround_cpu50_pending)
+        {
+	  if ((current_seg == now_seg) && (current_subseg == now_subseg))
+	    {
+	      const char *name = the_insn.code->name;
+
+	      if ((name[0] == 'l') && (name[1] == 'd') && (name[2] == '.'))
+		{
+		  if (show_internals)
+		    printf ("*** Inserting NOP (workaround "
+		    	    "for CPU_TC.050 bug).\n");
+#if EXT_LISTING
+		  ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround "
+		      			   "for bug CPU_TC.050"));
+#endif
+
+		  if (use_insn32)
+		    {
+		      pfrag = frag_more (4);
+		      md_number_to_chars (pfrag, 0x0d, 4);
+		    }
+		  else
+		    {
+		      pfrag = frag_more (2);
+		      md_number_to_chars (pfrag, 0x00, 2);
+		    }
+
+		  frag_grow (MAX_RELAXED_INSN_SIZE);
+	          workaround_cpu50_pending = 0;
+		}
+	      else
+	        {
+	          workaround_cpu50_pending = 0;
+		  goto recheck_cpu50;
+		}
+	    }
+	}
+      else
+        {
+	  const char *name;
+
+ recheck_cpu50:
+	  name = the_insn.code->name;
+	  if (((name[0] == 'd') && (name[1] == 'v')
+	       && (!strcmp (name, "dvadj")
+	           || !strcmp (name, "dvstep")
+		   || !strcmp (name, "dvstep.u")))
+	      || ((name[0] == 'm') && (name[1] == 'a')
+	          && (!strcmp (name, "madd")
+		      || !strcmp (name, "madds")
+		      || !strcmp (name, "madds.u")))
+	      || ((name[0] == 'm') && (name[1] == 's')
+	          && (!strcmp (name, "msub")
+		      || !strcmp (name, "msubs")
+		      || !strcmp (name, "msubs.u")))
+	      || ((name[0] == 'm') && (name[1] == 'u')
+	          && (!strcmp (name, "mul")
+		      || !strcmp (name, "muls")
+		      || !strcmp (name, "muls.u"))))
+	    {
+	      workaround_cpu50_pending = 1;
+	      current_seg = now_seg;
+	      current_subseg = now_subseg;
+	    }
+	}
+    }
+
+  /* Handle CPU.060 workaround, if so requested.  */
+  if (workaround_cpu60)
+    {
+      static segT current_seg = (segT) 0;
+      static subsegT current_subseg = (subsegT) 0;
+      static int workaround_cpu60_pending = 0;
+      static int addressregno = 0;
+      static int double_addressreg = 0;
+
+      if (workaround_cpu60_pending)
+        {
+	  if ((current_seg == now_seg) && (current_subseg == now_subseg))
+	    {
+	      const char *name = the_insn.code->name;
+
+	      if ((name[0] == 'l') && (name[1] == 'd') && (name[2] == '.')
+	          && ((name[3] == 'd') || (name[3] == 'w'))
+		  && (name[4] == '\0')
+		  && (the_insn.nops >= 2)
+		  && (the_insn.code->args[1] != 't')
+		  && ((the_insn.regs[1] == addressregno)
+		      || (double_addressreg
+		          ? (the_insn.regs[1] == (addressregno + 1))
+		          : 0)))
+		{
+		  if (show_internals)
+		    printf ("*** Inserting NOP (workaround "
+		    	    "for CPU_TC.060 bug).\n");
+#if EXT_LISTING
+		  ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround "
+		      			   "for bug CPU_TC.060"));
+#endif
+		  if (use_insn32)
+		    {
+		      pfrag = frag_more (4);
+		      md_number_to_chars (pfrag, 0x0d, 4);
+		    }
+		  else
+		    {
+		      pfrag = frag_more (2);
+		      md_number_to_chars (pfrag, 0x00, 2);
+		    }
+
+		  frag_grow (MAX_RELAXED_INSN_SIZE);
+	          workaround_cpu60_pending = 0;
+		}
+	      else
+	        {
+	          workaround_cpu60_pending = 0;
+		  goto recheck_cpu60;
+		}
+	    }
+	}
+      else
+        {
+	  const char *name;
+
+ recheck_cpu60:
+	  name = the_insn.code->name;
+	  if ((name[0] == 'l') && (name[1] == 'd') && (name[2] == '.')
+	      && (!strcmp (name, "ld.a") || !strcmp (name, "ld.da")))
+	    {
+	      workaround_cpu60_pending = 1;
+	      current_seg = now_seg;
+	      current_subseg = now_subseg;
+	      addressregno = the_insn.regs[0];
+	      double_addressreg = (name[3] == 'd');
+	    }
+	}
+    }
+
+  /* Handle CPU.070 workaround, if so requested.  */
+  if (workaround_cpu70)
+    {
+      static segT current_seg = (segT) 0;
+      static subsegT current_subseg = (subsegT) 0;
+      static int workaround_cpu70_pending = 0;
+      static int addressreg = 0;
+
+      if (workaround_cpu70_pending)
+        {
+	  if ((current_seg == now_seg) && (current_subseg == now_subseg))
+	    {
+	      const char *name = the_insn.code->name;
+
+	      if (!strncmp (name, "loop", 4))
+	        {
+		  if (show_internals)
+		    printf ("*** Inserting %s (workaround "
+		    	    "for CPU_TC.070 bug).\n",
+			    addressreg ? "NOP" : "2 NOPs");
+#if EXT_LISTING
+		  ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround "
+		      			   "for bug CPU_TC.070"));
+#endif
+
+		  if (use_insn32)
+		    {
+		      if (addressreg)
+		        {
+			  pfrag = frag_more (4);
+		          md_number_to_chars (pfrag, 0x0d, 4);
+			}
+		      else
+		        {
+			  pfrag = frag_more (8);
+		          md_number_to_chars (pfrag, 0x0d, 4);
+		          md_number_to_chars (pfrag + 4, 0x0d, 4);
+			}
+		    }
+		  else
+		    {
+		      pfrag = frag_more (addressreg ? 2 : 4);
+		      md_number_to_chars (pfrag, 0x00, addressreg ? 2 : 4);
+		    }
+
+		  frag_grow (MAX_RELAXED_INSN_SIZE);
+	          workaround_cpu70_pending = 0;
+		}
+	      else
+	        {
+	          workaround_cpu70_pending = 0;
+		  goto recheck_cpu70;
+		}
+	    }
+	}
+      else
+        {
+	  const char *name;
+
+ recheck_cpu70:
+	  name = the_insn.code->name;
+          if ((name[0] == 'j') && (name[1] != '\0')
+	      && (the_insn.code->nr_operands > 1)
+	      && (strpbrk (the_insn.code->args, "mxrRoOMtT") != NULL))
+	    {
+	      size_t ilen = strlen (name);
+
+	      workaround_cpu70_pending = 1;
+	      current_seg = now_seg;
+	      current_subseg = now_subseg;
+	      addressreg = ((ilen > 2)
+	      		    && (name[ilen - 2] == '.')
+			    && (name[ilen - 1] == 'a'));
+	    }
+	}
+    }
+  /* Handle CPU.072 workaround, if so requested.  */
+  if (workaround_cpu72)
+    {
+      static segT current_seg = (segT) 0;
+      static subsegT current_subseg = (subsegT) 0;
+      static int workaround_cpu72_pending = 0;
+      static int addressregno = 0;
+      static int double_addressreg = 0;
+
+      if (workaround_cpu72_pending)
+        {
+	  if ((current_seg == now_seg) && (current_subseg == now_subseg))
+	    {
+	      if (the_insn.is_loop
+		  && ((the_insn.regs[0] == addressregno)
+		      || (double_addressreg
+		          ? (the_insn.regs[0] == (addressregno + 1))
+		          : 0)))
+		{
+		  if (show_internals)
+		    printf ("*** Inserting NOP (workaround "
+		    	    "for CPU_TC.072 bug).\n");
+#if EXT_LISTING
+		  ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround "
+		      			   "for bug CPU_TC.072"));
+#endif
+
+		  if (use_insn32)
+		    {
+		      pfrag = frag_more (4);
+		      md_number_to_chars (pfrag, 0x0d, 4);
+		    }
+		  else
+		    {
+		      pfrag = frag_more (2);
+		      md_number_to_chars (pfrag, 0x00, 2);
+		    }
+
+		  frag_grow (MAX_RELAXED_INSN_SIZE);
+	          workaround_cpu72_pending = 0;
+		}
+	      else
+	        {
+	          workaround_cpu72_pending = 0;
+		  goto recheck_cpu72;
+		}
+	    }
+	}
+      else
+        {
+	  const char *name;
+
+ recheck_cpu72:
+	  name = the_insn.code->name;
+	  if ((name[0] == 'l') && (name[1] == 'd') && (name[2] == '.')
+	      && (!strcmp (name, "ld.a") || !strcmp (name, "ld.da")))
+	    {
+	      workaround_cpu72_pending = 1;
+	      current_seg = now_seg;
+	      current_subseg = now_subseg;
+	      addressregno = the_insn.regs[0];
+	      double_addressreg = (name[3] == 'd');
+	    }
+	}
+    }
+
+  /* Handle CPU.082 workaround, if so requested.  */
+  if (workaround_cpu82)
+    {
+      static segT current_seg = (segT) 0;
+      static subsegT current_subseg = (subsegT) 0;
+      static int workaround_cpu82_pending = 0;
+
+      if (workaround_cpu82_pending)
+        {
+	  if ((current_seg == now_seg) && (current_subseg == now_subseg))
+	    {
+	      const char *name = the_insn.code->name;
+
+	      if ((name[0] == 'l') && (name[1] == 'd') && (name[2] == '.'))
+		{
+		  if (show_internals)
+		    printf ("*** Inserting NOP (workaround "
+		    	    "for CPU_TC.082 bug).\n");
+#if EXT_LISTING
+		  ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround "
+		      			   "for bug CPU_TC.082"));
+#endif
+
+		  if (use_insn32)
+		    {
+		      pfrag = frag_more (4);
+		      md_number_to_chars (pfrag, 0x0d, 4);
+		    }
+		  else
+		    {
+		      pfrag = frag_more (2);
+		      md_number_to_chars (pfrag, 0x00, 2);
+		    }
+
+		  frag_grow (MAX_RELAXED_INSN_SIZE);
+	          workaround_cpu82_pending = 0;
+		}
+	      else
+	        {
+	          workaround_cpu82_pending = 0;
+		  goto recheck_cpu82;
+		}
+	    }
+	}
+      else
+        {
+	  const char *name;
+
+ recheck_cpu82:
+	  name = the_insn.code->name;
+	  if ((name[0] == 's') && (name[1] == 't')
+	      && (!strcmp (name, "stlcx") || !strcmp (name, "stucx")))
+	    {
+	      workaround_cpu82_pending = 1;
+	      current_seg = now_seg;
+	      current_subseg = now_subseg;
+	    }
+	}
+    }
+
+  /* Handle CPU.094 workaround, if so requested.  */
+  if (workaround_cpu94)
+    {
+      static segT current_seg = (segT) 0;
+      static subsegT current_subseg = (subsegT) 0;
+      static int workaround_cpu94_pending = 0;
+
+      if (workaround_cpu94_pending)
+        {
+	  if ((current_seg == now_seg) && (current_subseg == now_subseg))
+	    {
+	      const char *name = the_insn.code->name;
+
+	      if (!strncmp (name, "call", 4)
+			|| !strncmp(name,"syscall",7)
+			|| !strncmp(name,"ret",3)
+			|| !strncmp(name,"rfe",3))
+	        {
+		  if (show_internals)
+		    printf ("*** Inserting %s (workaround "
+		    	    "for CPU_TC.094 bug).\n", "NOP");
+#if EXT_LISTING
+		  ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround "
+		      			   "for bug CPU_TC.094"));
+#endif
+
+		  if (use_insn32)
+		    {
+			  pfrag = frag_more (4);
+		          md_number_to_chars (pfrag, 0x0d, 4);
+		    }
+		  else
+		    {
+		      pfrag = frag_more (2);
+		      md_number_to_chars (pfrag, 0x00, 2);
+		    }
+
+		  frag_grow (MAX_RELAXED_INSN_SIZE);
+	          workaround_cpu94_pending = 0;
+		}
+	      else
+	        {
+	          workaround_cpu94_pending = 0;
+		  goto recheck_cpu94;
+		}
+	    }
+	}
+      else
+        {
+	  const char *name;
+
+ recheck_cpu94:
+	  name = the_insn.code->name;
+          if ((name[0] == 'j') && (name[1] != '\0')
+	      && (the_insn.code->nr_operands > 1)
+			/* check only IP jump instructions which use data registers */
+	      && (strpbrk (the_insn.code->args, "di") != NULL))
+	    {
+	      // size_t ilen = strlen (name);
+
+	      workaround_cpu94_pending = 1;
+	      current_seg = now_seg;
+	      current_subseg = now_subseg;
+	    }
+	}
+    }
+
+  /* Handle CPU.095 workaround, if so requested.  */
+  if (workaround_cpu95)
+    {
+      static segT current_seg = (segT) 0;
+      static subsegT current_subseg = (subsegT) 0;
+      static int workaround_cpu95_pending = 0;
+
+      if (workaround_cpu95_pending)
+        {
+	  if ((current_seg == now_seg) && (current_subseg == now_subseg))
+	    {
+	      const char *name = the_insn.code->name;
+
+	      if (!strncmp (name, "addsc", 5)
+			|| !strncmp(name,"mov.a",5)
+			|| !strncmp(name,"mtcr",4))
+	        {
+		  if (show_internals)
+		    printf ("*** Inserting %s (workaround "
+		    	    "for CPU_TC.095 bug).\n", "NOP");
+#if EXT_LISTING
+		  ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround "
+		      			   "for bug CPU_TC.095"));
+#endif
+
+		  if (use_insn32)
+		    {
+			  pfrag = frag_more (4);
+		          md_number_to_chars (pfrag, 0x0d, 4);
+		    }
+		  else
+		    {
+		      pfrag = frag_more (2);
+		      md_number_to_chars (pfrag, 0x00, 2);
+		    }
+
+		  frag_grow (MAX_RELAXED_INSN_SIZE);
+	          workaround_cpu95_pending = 0;
+		}
+	      else
+	        {
+	          workaround_cpu95_pending = 0;
+		  goto recheck_cpu95;
+		}
+	    }
+	}
+      else
+        {
+	  const char *name;
+
+ recheck_cpu95:
+	  name = the_insn.code->name;
+        if ((name[0] == 's') && (name[1] == 'a') && (name[2] == 't'))
+	    {
+	      //size_t ilen = strlen (name);
+
+	      workaround_cpu95_pending = 1;
+	      current_seg = now_seg;
+	      current_subseg = now_subseg;
+	    }
+	}
+    }
+
+
+
+  /* Handle DMI.012 workaround, if so requested.  Boy, this one's nasty!  */
+  if (workaround_dmi12)
+    {
+      static segT current_seg = (segT) 0;
+      static subsegT current_subseg = (subsegT) 0;
+      static int workaround_dmi12_2ab_pending = 0;
+      static int workaround_dmi12_2c_pending = 0;
+      static int workaround_dmi12_2d_pending = 0;
+      static int workaround_dmi12_2e_pending = 0;
+      static int addressregno = -1;
+      static int double_addressreg = 0;
+      static int dataregno = -1;
+      static int double_datareg = 0;
+#if EXT_LISTING
+      static fragS *pending_dmi12_2e_frag = (fragS *) NULL;
+#endif
+
+      /* If the current insn is a NOP, it needs special treatment wrt.
+         (possibly pending) DMI12 workarounds -- see comment below.  */
+      if (!strcmp (the_insn.code->name, "nop")
+          && (workaround_dmi12_2ab_pending
+	      || workaround_dmi12_2c_pending
+	      || workaround_dmi12_2d_pending
+	      || workaround_dmi12_2e_pending)
+          && ((current_seg == now_seg) && (current_subseg == now_subseg)))
+        {
+	  /* The insn we're going to emit right now is a NOP, which is a
+	     "dual-pipeline" insn, meaning it stalls both, TriCore's integer
+	     (I) and load/store (LS) pipelines.  This means we can safely
+	     reset all potentially pending DMI12 workarounds, because no
+	     instruction sequence affected by this cache bug can be started
+	     with a NOP, and even if such a sequence is pending, a NOP insn
+	     will immediately "disarm" it.  This is even true for case 2.c
+	     where an address register, after being loaded, must not be used
+	     within the next two insns to load data from memory, unless the
+	     insn following the initial load insn stalls the LS pipeline: if
+	     the current NOP is the first insn after the initial load, it'll
+	     stall the LS pipeline, so even a possibly following load insn
+	     won't trigger the bug; and if this NOP is the second insn after
+	     the initial load, it would also terminate the critical sequence
+	     by merely not being a potentially "dangerous" load insn.  */
+
+ reset_dmi12:
+	  workaround_dmi12_2ab_pending = 0;
+	  workaround_dmi12_2c_pending = 0;
+	  workaround_dmi12_2d_pending = 0;
+	  workaround_dmi12_2e_pending = 0;
+	  addressregno = -1;
+	  double_addressreg = 0;
+	  dataregno = -1;
+	  double_datareg = 0;
+	  goto recheck_dmi12;
+	}
+
+      /* Do we have to insert a NOP instruction due to a previous "store"
+         instruction within the same (sub-) section?  */
+      if (workaround_dmi12_2e_pending
+          && ((current_seg == now_seg) && (current_subseg == now_subseg)))
+        {
+	  /* Workaround for bug DMI_TC.012, case 2.e, part 1: the previous
+	     insn was a "store" instruction, so we have to insert a NOP insn
+	     before emitting the current insn.  */
+	  if (show_internals)
+	    printf ("*** Inserting NOP (workaround for DMI_TC.012 "
+	            "bug, case 2.e (\"store\")).\n");
+#if EXT_LISTING
+	  /* Attach the notice to the frag that belongs to the instruction
+	     which started the faulting instruction sequence (see below).  */
+          ext_listing_frag = pending_dmi12_2e_frag;
+	  ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround for "
+	  			   "bug DMI_TC.012, case 2.e (\"store\")"));
+	  ext_listing_frag = pending_dmi12_2e_frag = (fragS *) NULL;
+#endif
+
+	  if (use_insn32)
+	    {
+	      pfrag = frag_more (4);
+	      md_number_to_chars (pfrag, 0x0d, 4);
+	    }
+	  else
+	    {
+	      pfrag = frag_more (2);
+	      md_number_to_chars (pfrag, 0x00, 2);
+	    }
+
+	  frag_grow (MAX_RELAXED_INSN_SIZE);
+
+	  /* Now that we've inserted a NOP, we can safely reset all possibly
+	     pending DMI12 workarounds (see the comment for "NOP" above for
+	     details).  Note, however, that we can't simply jump to the
+	     "reset_dmi12" label above, because the current insn might be
+	     some "load" instruction -- in which case we must even insert
+	     insert another NOP, but this is handled by the code below!  */
+	  workaround_dmi12_2ab_pending = 0;
+	  workaround_dmi12_2c_pending = 0;
+	  workaround_dmi12_2d_pending = 0;
+	  workaround_dmi12_2e_pending = 0;
+	  addressregno = -1;
+	  double_addressreg = 0;
+	  dataregno = -1;
+	  double_datareg = 0;
+	}
+
+      /* It's a shame that there's no easier way to identify the following
+         insns, but then again, this is only necessary to implement some
+	 workaround, so it's not really okay, but at least acceptable.  */
+      if (!strncmp (the_insn.code->name, "ld.", 3)
+	  || !strcmp (the_insn.code->name, "call")
+	  || !strcmp (the_insn.code->name, "calla")
+	  || !strcmp (the_insn.code->name, "calli")
+	  || !strcmp (the_insn.code->name, "ret")
+	  || !strcmp (the_insn.code->name, "ldlcx")
+	  || !strcmp (the_insn.code->name, "lducx")
+	  || !strcmp (the_insn.code->name, "ldmst")
+	  || !strcmp (the_insn.code->name, "swap.w")
+	  || !strcmp (the_insn.code->name, "st.t")
+	  || !strcmp (the_insn.code->name, "rfe")
+	  || !strcmp (the_insn.code->name, "bisr")
+	  || !strcmp (the_insn.code->name, "svlcx")
+	  || !strcmp (the_insn.code->name, "rslcx")
+	  || !strncmp (the_insn.code->name, "cachea.", 7))
+	{
+	  /* Workaround for bug DMI_TC.012, case 2.e, part 2: the current
+	     insn qualifies as a "load" instruction (according to the
+	     DMI12 bug and workaround description, aka. Errata Sheet), so
+	     we have to insert a NOP instruction before emitting the current
+	     insn.  And after that, we can also safely reset all possibly
+	     pending DMI12 workarounds for the reasons already explained
+	     above.  Note: case 2.e eclipses case 2.c, but the code for 2.c
+	     was already implemented, tested and released at the time case
+	     2.e was even reported, so it's still there for documentation
+	     purposes, or "just in case"...  ;-)  */
+	  if (show_internals)
+	    printf ("*** Inserting NOP (workaround for DMI_TC.012 "
+	            "bug, case 2.e (\"load\")).\n");
+#if EXT_LISTING
+	  ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround for "
+	  			   "bug DMI_TC.012, case 2.e (\"load\")"));
+#endif
+
+	  if (use_insn32)
+	    {
+	      pfrag = frag_more (4);
+	      md_number_to_chars (pfrag, 0x0d, 4);
+	    }
+	  else
+	    {
+	      pfrag = frag_more (2);
+	      md_number_to_chars (pfrag, 0x00, 2);
+	    }
+
+	  frag_grow (MAX_RELAXED_INSN_SIZE);
+
+	  /* Now that we've inserted a NOP, we can safely reset all possibly
+	     pending DMI12 workarounds (see the comment for "NOP" above for
+	     details).  */
+	  goto reset_dmi12;
+	}
+
+      /* Is there another instruction sequence pending that might trigger
+         some DMI12 bug?  */
+      if (workaround_dmi12_2ab_pending
+          || workaround_dmi12_2c_pending
+          || workaround_dmi12_2d_pending)
+        {
+	  if ((current_seg == now_seg) && (current_subseg == now_subseg))
+	    {
+	      const char *name = the_insn.code->name;
+
+	      if (!strncmp (name, "ld.", 3)
+	      	  || !strcmp (name, "st.t")
+		  || !strcmp (name, "ldmst")
+		  || !strcmp (name, "swap.w")
+		  || !strcmp (name, "ldlcx")
+		  || !strcmp (name, "lducx")
+	      	  || !strncmp (name, "cachea.", 7))
+	        {
+		  if (workaround_dmi12_2ab_pending)
+		    {
+		      if (show_internals)
+		    	printf ("*** Inserting NOP (workaround "
+		    	    	"for DMI_TC.012 bug, cases 2.a/b).\n");
+
+#if EXT_LISTING
+		      ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround "
+		      			       "for bug DMI_TC.012, cases "
+					       "2.a/b"));
+#endif
+
+		      if (use_insn32)
+		    	{
+		      	  pfrag = frag_more (4);
+		      	  md_number_to_chars (pfrag, 0x0d, 4);
+		    	}
+		      else
+		    	{
+		      	  pfrag = frag_more (2);
+		      	  md_number_to_chars (pfrag, 0x00, 2);
+		    	}
+
+		      frag_grow (MAX_RELAXED_INSN_SIZE);
+		      workaround_dmi12_2ab_pending = 0;
+		      workaround_dmi12_2c_pending = 0;
+		      workaround_dmi12_2d_pending = 0;
+		      workaround_dmi12_2e_pending = 0;
+		      addressregno = -1;
+		      double_addressreg = 0;
+		      dataregno = -1;
+		      double_datareg = 0;
+		      goto recheck_dmi12;
+		    }
+		  workaround_dmi12_2ab_pending = 0;
+
+	          if (workaround_dmi12_2d_pending
+		      && ((!strncmp (name, "ld.", 3)
+		           && (strchr ("diD", the_insn.code->args[0]) != NULL)
+			   && ((the_insn.regs[0] == dataregno)
+			       || (double_datareg
+			           ? (the_insn.regs[0] == (dataregno + 1))
+				   : 0)))
+			  || (!strcmp (name, "ldmst")
+			      && ((the_insn.regs[the_insn.nops - 1]
+			           == dataregno)
+			          || ((the_insn.regs[the_insn.nops - 1] + 1)
+				      == dataregno)))
+			  || (!strcmp (name, "swap.w")
+			      && ((the_insn.regs[the_insn.nops - 1]
+			           == dataregno)
+			          || (double_datareg
+				      ? (the_insn.regs[the_insn.nops - 1]
+				         == (dataregno + 1))
+				      : 0)))
+			  || (!strcmp (name, "ldlcx") && (dataregno < 8))
+			  || (!strcmp (name, "lducx") && (dataregno > 7))))
+	            {
+		      /* If the previous insn was an arithmetic insn and
+		         used a data register as its target operand, and
+			 the current insn is a "load" insn that uses the very
+			 same data register as its target operand, we need
+			 to insert a "nop".  This won't happen in real apps,
+			 though, as it doesn't make any sense to overwrite
+			 a data register that has just been used to compute
+			 some result.  A compiler might produce such code,
+			 but only if the source code itself doesn't make
+			 much sense, and if optimizations are turned off.  */
+		      if (show_internals)
+		    	printf ("*** Inserting NOP (workaround "
+		    	    	"for DMI_TC.012 bug, case 2.d).\n");
+#if EXT_LISTING
+		      ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround "
+		      			       "for bug DMI_TC.012, case 2.d"));
+#endif
+
+		      if (use_insn32)
+		    	{
+		      	  pfrag = frag_more (4);
+		      	  md_number_to_chars (pfrag, 0x0d, 4);
+		    	}
+		      else
+		    	{
+		      	  pfrag = frag_more (2);
+		      	  md_number_to_chars (pfrag, 0x00, 2);
+		    	}
+
+		      frag_grow (MAX_RELAXED_INSN_SIZE);
+		      workaround_dmi12_2c_pending = 0;
+		      addressregno = -1;
+		      double_addressreg = 0;
+		      workaround_dmi12_2d_pending = 0;
+		      dataregno = -1;
+		      double_datareg = 0;
+		      workaround_dmi12_2e_pending = 0;
+		      goto recheck_dmi12;
+		    }
+	          workaround_dmi12_2d_pending = 0;
+		  dataregno = -1;
+		  double_datareg = 0;
+
+	      	  if (workaround_dmi12_2c_pending)
+		    {
+		      /* The previous insn was either "ld.a" or "ld.da", so
+		         we have to insert a "nop" in case the current insn
+		         uses the just-loaded address register(s) to access
+			 one of its source operands.  */
+	              if ((the_insn.code->nr_operands > 1)
+		  	  && strchr ("@&<>*#S", the_insn.code->args[1])
+		  	  && ((the_insn.regs[1] == addressregno)
+		      	      || (double_addressreg
+		          	  ? (the_insn.regs[1] == (addressregno + 1))
+		          	  : 0)))
+			{
+		  	  if (show_internals)
+		    	    printf ("*** Inserting NOP (workaround "
+		    	    	    "for DMI_TC.012 bug, case 2.c).\n");
+
+#if EXT_LISTING
+		          ASM_NOTICE_WORKAROUND (_("inserting NOP as a "
+			  			   "workaround for bug "
+						   "DMI_TC.012, case 2.c"));
+#endif
+
+		  	  if (use_insn32)
+		    	    {
+		      	      pfrag = frag_more (4);
+		      	      md_number_to_chars (pfrag, 0x0d, 4);
+		    	    }
+		  	  else
+		    	    {
+		      	      pfrag = frag_more (2);
+		      	      md_number_to_chars (pfrag, 0x00, 2);
+		    	    }
+
+		  	  frag_grow (MAX_RELAXED_INSN_SIZE);
+			}
+		      else if (workaround_dmi12_2c_pending == 2)
+		        {
+		          /* The previous insn was "ld.[d]a", and the
+		             current insn doesn't use the just loaded
+		             address register to read some operand.
+		             Unfortunately, if the current insn is some
+		             integer pipeline insn and the next insn
+		             uses the address register loaded by the
+		             previous insn, then the previous and the
+		             next insn will still be executed in parallel,
+		             which may trigger the cache bug.  Since we
+		             cannot easily know the next insn at this point
+		             in time, we extend the pending workaround to
+		             also include the next insn.  */
+			  workaround_dmi12_2c_pending = 1;
+			  goto recheck_dmi12;
+			}
+
+		      workaround_dmi12_2c_pending = 0;
+		      addressregno = -1;
+		      double_addressreg = 0;
+		    }
+
+		  goto recheck_dmi12;
+		}
+	      else
+	        {
+	          if (workaround_dmi12_2c_pending)
+		    {
+		      if ((workaround_dmi12_2c_pending -= 1) == 0)
+		        {
+			  addressregno = -1;
+		          double_addressreg = 0;
+			}
+		    }
+		  workaround_dmi12_2ab_pending = 0;
+		  workaround_dmi12_2d_pending = 0;
+		  goto recheck_dmi12;
+		}
+	    }
+	}
+      else
+        {
+	  const char *name;
+
+ recheck_dmi12:
+ 	  name = the_insn.code->name;
+	  /* All insns using TriCore's integer pipeline and which use
+	     a data register as their target (which excludes all jump
+	     insns) may trigger case 2d of the DMI12 cache bug.  */
+	  if ((the_insn.opcode & 2)
+	      && (the_insn.code->nr_operands > 1)
+	      && (strchr ("diD", the_insn.code->args[0]) != NULL)
+	      && !((name[0] == 'j')
+	           && (strpbrk (the_insn.code->args, "mxrRoOMtT") != NULL)))
+	    {
+	      workaround_dmi12_2d_pending = 1;
+	      dataregno = the_insn.regs[0];
+	      double_datareg = (the_insn.code->args[0] == 'D');
+	      current_seg = now_seg;
+	      current_subseg = now_subseg;
+	    }
+
+	  /* All store instructions must be followed by a NOP, as requested
+	     by case 2e of the DMI12 cache bug workaround description; this
+	     NOP will be emitted right before the next instruction that
+	     goes into the current segment and subsegment.  Note that the
+	     second part of the 2e workaround, where load instructions must
+	     be preceded by a NOP insns, is already handled above.  */
+	  if (!strncmp (name, "st.", 3)
+	      || !strcmp (name, "stlcx")
+	      || !strcmp (name, "stucx"))
+	    {
+	      workaround_dmi12_2e_pending = 1;
+	      current_seg = now_seg;
+	      current_subseg = now_subseg;
+#if EXT_LISTING
+	      /* Remember the frag that starts a critical insn sequence, so
+	         we can attach an appropriate message to it in case it
+		 actually requires a workaround (see above for details).  */
+              pending_dmi12_2e_frag = frag_now;
+#endif
+	    }
+
+	  /* Conditional jumps may trigger case 2b of the DMI12 cache bug,
+	     and various other insns may trigger case 2a (as described in
+	     the relevant Errata Sheet).  Since both cases require the same
+	     set of insns following them in order to potentially cause
+	     problems, we're combining them in a single "2ab" case.  */
+	  if (((name[0] == 'j') && (name[1] != '\0')
+	       && (the_insn.code->nr_operands > 1)
+	       && (strpbrk (the_insn.code->args, "mxrRoOMtT") != NULL))
+	      || (!strncmp (name, "madd", 4) && strcmp (name, "madd.h"))
+	      || (!strncmp (name, "msub", 4) && strcmp (name, "msub.h"))
+	      || (!strncmp (name, "mul", 3) && strcmp (name, "mul.h"))
+	      || !strncmp (name, "dvstep", 6)
+	      || !strncmp (name, "fto", 3)
+	      || !strcmp (name, "add.f")
+	      || !strcmp (name, "sub.f")
+	      || !strcmp (name, "div.f")
+	      || !strcmp (name, "itof")
+	      || !strcmp (name, "q31tof")
+	      || !strcmp (name, "utof"))
+	    {
+	      workaround_dmi12_2ab_pending = 1;
+	      current_seg = now_seg;
+	      current_subseg = now_subseg;
+	    }
+	  else if (!strcmp (name, "ld.a") || !strcmp (name, "ld.da"))
+	    {
+	      /* These insns may trigger case 2c of the DMI12 cache bug.
+	         Note that case 2e (see above) supersedes this case.  */
+	      workaround_dmi12_2c_pending = 2;
+	      addressregno = the_insn.regs[0];
+	      double_addressreg = (name[3] == 'd');
+	      current_seg = now_seg;
+	      current_subseg = now_subseg;
+	    }
+	}
+    }
+
+  /* Allocate frag memory to hold the opcode.  */
+  pfrag = frag_more (oplen);
+
+  /* Emit the instruction code.  */
+  md_number_to_chars (pfrag, the_insn.opcode, oplen);
+
+  /* Emit DWARF2 line debug info (if requested).  */
+  dwarf2_emit_insn (oplen);
+
+  /* Emit fixups and relaxation infos if necessary.  */
+  dont_relax = use_insn16 || (the_insn.code->format == TRICORE_FMT_B);
+  for (i = 0; i < the_insn.nops; ++i)
+    {
+      if (the_insn.ops[i] != 'U')
+        continue;
+
+      CHECK_RELOC (i);
+      if (dont_relax || !the_insn.pcrel[i])
+        {
+	  if (the_insn.bitpos[i])
+	    {
+	      fix_new_exp (frag_now, (pfrag - frag_now->fr_literal), 0,
+	      		   &the_insn.opexp[i], the_insn.pcrel[i],
+			   BFD_RELOC_TRICORE_BITPOS);
+	      if (show_internals)
+	        printf ("*** fix_new_exp (%d, BFD_RELOC_TRICORE_BITPOS)\n", i);
+	    }
+          fix_new_exp (frag_now, (pfrag - frag_now->fr_literal), 0,
+	               &the_insn.opexp[i], the_insn.pcrel[i], reloc);
+          if (show_internals)
+    	    printf ("*** fix_new_exp (%d, %s)\n", i, GET_RELOC_NAME (reloc));
+	  continue;
+	}
+
+      /* This is a PC-relative jump/call insn; prepare it for relaxing.  */
+      switch (the_insn.code->format)
+	{
+	case TRICORE_FMT_SB:
+	  if (the_insn.code->nr_operands == 1)
+	    state = RELAX_SB2;
+	  else
+	    state = RELAX_SB;
+	  break;
+
+	case TRICORE_FMT_SBR:
+	  if (the_insn.is_loop)
+	    state = RELAX_LOOP;
+	  else if (the_insn.code->args[i] == 'x')
+	    state = RELAX_SBR2;
+	  else  
+	    state = RELAX_SBR;
+	  break;
+
+	case TRICORE_FMT_SBC:
+	  if (the_insn.code->args[i] == 'x')
+	    state = RELAX_SBC2;
+	  else  
+	    state = RELAX_SBC;
+	  break;
+
+	case TRICORE_FMT_SBRN:
+	  state = RELAX_SBRN;
+	  break;
+
+	case TRICORE_FMT_BRN:
+	  state = RELAX_BRN;
+	  break;
+
+	case TRICORE_FMT_BRR:
+	case TRICORE_FMT_BRC:
+	  if (the_insn.is_loop)
+	    {
+	      if (use_insn32 || big_insns || big_insns_only)
+	        state = RELAX_BLOOP2;
+	      else
+	        state = RELAX_BLOOP;
+	    }
+	  else if (!strcmp (the_insn.code->name, "jned")
+	      || !strcmp (the_insn.code->name, "jnei"))
+	    {
+	      if (use_insn32 || big_insns || big_insns_only)
+	        state = RELAX_JNEX2;
+	      else
+	        state = RELAX_JNEX;
+	    }
+	  else if (!strcmp (the_insn.code->name, "loopu"))
+	    state = RELAX_LOOPU;
+	  else
+	    state = RELAX_BRX;
+	  break;
+
+	default:
+	  as_fatal (_("Internal error: attempt to relax format <%s> "
+	  	      "in emit_code"),
+	      	    fmt_name[the_insn.code->format]);
+	  break;
+	}
+
+      /* We already have allocated space in the current frag to hold
+         this insn's opcode (this was done by calling frag_more above).
+	 Now we call frag_var to reserve space for add_bytes more
+	 bytes in case the insn needs being expanded.  */
+      add_bytes = MAX_RELAXED_INSN_SIZE - oplen;
+      (void) frag_var (rs_machine_dependent, add_bytes, add_bytes, state,
+		       the_insn.opexp[i].X_add_symbol, VAL (i), pfrag);
+      if (show_internals)
+    	printf ("*** frag_var (%d, add_bytes=%d)\n", i, add_bytes);
+    }
+
+  /* Remember the address where the opcode is stored (for debugging).  */
+  the_insn.opc_address = (unsigned long) pfrag;
+}
+
+/* This is called for each rs_machine_dependent frag (pointed to by
+   FRAGP), right before SEGMENT is relaxed.  Any symbol that is
+   still undefined will not become defined, so we need to switch to
+   the biggest variant of this insn.  Return the estimated length in
+   bytes by which this frag must grow to reach its destination.  */
+
+int
+md_estimate_size_before_relax (fragP, segment)
+     register fragS *fragP;
+     register segT segment;
+{
+  if (show_internals)
+    printf ("*** md_estimate_size_before_relax (%lx): ", OPC_ADDR (fragP));
+
+  if ((fragP->fr_symbol != (symbolS *) 0)
+      && ((S_GET_SEGMENT (fragP->fr_symbol) == segment)
+          || (S_GET_SEGMENT (fragP->fr_symbol) == absolute_section))
+      && S_IS_DEFINED (fragP->fr_symbol)
+      && !S_IS_EXTERNAL (fragP->fr_symbol)
+      && !S_IS_WEAK (fragP->fr_symbol))
+    {
+      /* If a symbol is defined and lives in the same segment as the
+         insn that references it (or in the absolute segment), then
+	 relax_segment will automatically find out if the displacement
+	 fits in the original insn, or if this insn needs being
+	 expanded (which is eventually done in md_convert_frag).  */
+      if (show_internals)
+        {
+	  if (md_relax_table[fragP->fr_subtype].rlx_length)
+	    printf ("+ %d bytes (-> state %d)\n",
+	  	    md_relax_table[fragP->fr_subtype].rlx_length,
+		    fragP->fr_subtype);
+	  else if (fragP->fr_subtype == (tricore_relax_loopu_state + 1))
+	    printf ("loopu -> j\n");
+	  else
+            printf ("currently keeping state %d\n", fragP->fr_subtype);
+	}
+    }
+  else
+    {
+      relax_substateT old_state, state;
+      const relax_typeS *type;
+
+      /* The symbol lives in a different segment (or is global or weak,
+         so it can be overridden by a non-SO/non-weak definition), which
+	 means that it can't be reached by a single "short" insn in all
+	 cases.  Only a relaxing linker could find this out, but then this
+	 function would be unnecessary and never be called, because we
+	 would never call frag_var, and pass all PC-relative fixups as
+	 relocations to the linker.  The only reasonable thing to do here
+	 is to switch to the last valid entry in md_relax_table for this
+	 relaxation type.  */
+      old_state = state = fragP->fr_subtype;
+      type = md_relax_table + old_state;
+      while (type->rlx_more)
+        {
+	  state = type->rlx_more;
+          type = md_relax_table + state;
+	}
+      fragP->fr_subtype = state;
+      if (show_internals)
+        {
+	  if (state != old_state)
+	    printf ("+ %d bytes (-> max. state %d)\n",
+	  	    type->rlx_length, state);
+	  else
+	    printf ("[+ %d bytes] (max. state %d kept)\n",
+	    	    type->rlx_length, state);
+	}
+    }
+
+  return md_relax_table[fragP->fr_subtype].rlx_length;
+}
+
+/* This is called for each rs_machine_dependent frag (pointed to by
+   FRAGP), right after SEGMENT is relaxed.  If necessary, convert
+   the insn so that it can reach its target.  Set the final size of
+   this frag, and reset its variable part (FRAGP->fr_var).  Note that
+   the value of FRAGP->fr_symbol might be undefined, so we can't
+   use it to determine the target address; we emit fixups instead.  */
+
+void
+md_convert_frag (abfd, segment, fragP)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     segT segment ATTRIBUTE_UNUSED;
+     register fragS *fragP;
+{
+  char *buf = fragP->fr_opcode, bytecode;
+  int convert_insn = 0, pcrel = 1, regno;
+  char optype, regtype, *opc16 = NULL, *opc_name = NULL;
+  enum bfd_reloc_code_real reloc = BFD_RELOC_TRICORE_NONE;
+  offsetT fix_where = fragP->fr_fix - 2;
+  opcode_t *code;
+  fixS *new_fix;
+
+  if (show_internals)
+    printf ("*** md_convert_frag (%lx): ", OPC_ADDR (fragP));
+
+#if EXT_LISTING
+  if (listing & LISTING_LISTING)
+    ext_listing_frag = fragP;
+#endif
+
+  switch (fragP->fr_subtype)
+    {
+    case RELAX_SB:
+    case RELAX_SB2:
+      reloc = BFD_RELOC_TRICORE_8REL;
+      break;
+
+    case RELAX_LOOP:
+      reloc = BFD_RELOC_TRICORE_4REL2;
+      break;
+
+    case RELAX_SBR:
+    case RELAX_SBC:
+    case RELAX_SBRN:
+      reloc = BFD_RELOC_TRICORE_4REL;
+      break;
+
+    case RELAX_SBR2:
+    case RELAX_SBC2:
+      reloc = BFD_RELOC_TRICORE_5REL;
+      break;
+
+    case RELAX_BRX:
+    case RELAX_BRN:
+    case RELAX_JNEX:
+    case RELAX_JNEX2:
+    case RELAX_BLOOP:
+    case RELAX_BLOOP2:
+    case RELAX_LOOPU:
+      fix_where -= 2;
+      reloc = BFD_RELOC_TRICORE_15REL;
+      break;
+
+    case RELAX_JC:
+      reloc = BFD_RELOC_TRICORE_PCPREL6;
+      break;
+
+    case RELAX_JL:
+      reloc = BFD_RELOC_TRICORE_PCPREL10;
+      break;
+
+    case RELAX_SB + 1:
+    case RELAX_SB2 + 1:
+    case RELAX_LOOP + 1:
+    case RELAX_SBR + 1:
+    case RELAX_SBC + 1:
+    case RELAX_SBR2 + 1:
+    case RELAX_SBC2 + 1:
+    case RELAX_SBRN + 1:
+      convert_insn = 1;
+      break; 
+
+    case RELAX_BRX + 1:
+    case RELAX_BRN + 1:
+    case RELAX_JNEX + 1:
+    case RELAX_JNEX2 + 1:
+    case RELAX_BLOOP + 1:
+    case RELAX_BLOOP2 + 1:
+    case RELAX_LOOPU + 1:
+      fix_where -= 2;
+      reloc = BFD_RELOC_TRICORE_24REL;
+      convert_insn = 2;
+      break;
+
+    case RELAX_JC + 1:
+    case RELAX_JL + 1:
+      fix_where += 2;
+      reloc = BFD_RELOC_TRICORE_PCPTEXT;
+      convert_insn = 3;
+      pcrel = 0;
+      break; 
+
+    case RELAX_SB + 2:
+    case RELAX_SBC + 2:
+    case RELAX_SBC2 + 2:
+    case RELAX_SBR + 2:
+    case RELAX_SBR2 + 2:
+    case RELAX_SBRN + 2:
+    case RELAX_LOOP + 2:
+      reloc = BFD_RELOC_TRICORE_24REL;
+      convert_insn = 4;
+      break;
+
+    default:
+      as_fatal (_("Internal error: illegal relax type %d"), fragP->fr_subtype);
+      break;
+    }
+
+  if (convert_insn == 0)
+    {
+      /* There is obviously no reason to convert the insn, so all
+         we need to do is to generate a fixup for the symbol.  */
+      if (show_internals)
+        printf ("keeping original insn\n");
+    }
+  else if (convert_insn == 1)
+    {
+      /* Converting 16-bit to 32-bit TriCore-insns isn't fun at all:
+         it's not enough to just toggle a bit (or to replace the opcode)
+         and appending the displacement, because 32-bit insns not only
+         have different opcodes, but also different numbers and different
+         (though upward-compatible) kinds of operands.  Even the names
+         of 16-bit and 32-bit insns can be different.  What a mess...
+         But, hey -- Don't Panic!  We can easily re-use the 16->32-bit
+         insn conversion functions (and a few others that are helpful in
+         this regard), so all we have to do is to reconstruct the_insn,
+         and then call the appropriate functions to do the real work.  */
+      if (show_internals)
+        printf ("converting 16-bit to 32-bit insn\n");
+
+      memset ((char *) &the_insn, 0, sizeof (the_insn));
+      if (S_GET_SEGMENT (fragP->fr_symbol) == undefined_section)
+        optype = 'U';
+      else
+        optype = 'X';
+
+      switch (fragP->fr_subtype)
+        {
+        case RELAX_SB + 1:		/* Convert insns of type SB.  */
+        case RELAX_SB2 + 1:
+          bytecode = *buf & tricore_opmask[TRICORE_FMT_SB];
+          if (optype != 'U')
+            optype = 'R';
+          if (bytecode == tricore_insn_j_R)
+            {
+	      opc_name = (char *)"j";
+              opc16 = (char *)"j-R";
+	    }
+          else if (bytecode == tricore_insn_call_R)
+            {
+	      opc_name = (char *)"call";
+	      opc16 = (char *)"call-R";
+	    }
+          else if (bytecode == tricore_insn_jnz_iR)
+            {
+	      opc_name = (char *)"jnz";
+              opc16 = (char *)"jnz-iR";
+	      the_insn.regs[0] = 15;
+	      the_insn.ops[0] = 'i';
+	      the_insn.nops = 1;
+	    }
+          else if (bytecode == tricore_insn_jz_iR)
+            {
+	      opc_name = (char *)"jz";
+              opc16 = (char *)"jz-iR";
+	      the_insn.regs[0] = 15;
+	      the_insn.ops[0] = 'i';
+	      the_insn.nops = 1;
+	    }
+          else
+            {
+              as_fatal (_("Internal error: unknown SB opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+          break;
+
+        case RELAX_LOOP + 1:		/* Convert loop insns (SBR).  */
+          bytecode = *buf & tricore_opmask[TRICORE_FMT_SBR];
+          if (optype != 'U')
+            optype = 'r';
+          if (bytecode == tricore_insn_loop_ar)
+            {
+	      opc_name = (char *)"loop";
+	      opc16 = (char *)"loop-ar";
+	      the_insn.regs[0] = ((buf[1] >> 4) & 0xf);
+	      the_insn.ops[0] = 'a';
+	      the_insn.nops = 1;
+	      the_insn.is_loop = 1;
+	    }
+          else
+            {
+              as_fatal (_("Internal error: unknown loop insn 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+          break;
+
+        case RELAX_SBR + 1:		/* Convert insns of type SBR.  */
+          bytecode = *buf & tricore_opmask[TRICORE_FMT_SBR];
+          if (optype != 'U')
+            optype = 'm';
+          regno = ((buf[1] >> 4) & 0xf);
+          regtype = 'd';
+          if (bytecode == tricore_insn_jeq_idm)
+            {
+	      opc_name = (char *)"jeq";
+              opc16 = (char *)"jeq-idm";
+	      the_insn.regs[0] = 15;
+              the_insn.ops[0] = 'i';
+	      the_insn.nops = 1;
+	    }
+          else if (bytecode == tricore_insn_jne_idm)
+            {
+	      opc_name = (char *)"jne";
+              opc16 = (char *)"jne-idm";
+	      the_insn.regs[0] = 15;
+              the_insn.ops[0] = 'i';
+	      the_insn.nops = 1;
+	    }
+          else if (bytecode == tricore_insn_jgez_dm)
+            {
+	      opc_name = (char *)"jgez";
+	      opc16 = (char *)"jgez-dm";
+	    }
+          else if (bytecode == tricore_insn_jgtz_dm)
+            {
+	      opc_name = (char *)"jgtz";
+	      opc16 = (char *)"jgtz-dm";
+	    }
+          else if (bytecode == tricore_insn_jlez_dm)
+            {
+	      opc_name = (char *)"jlez";
+	      opc16 = (char *)"jlez-dm";
+	    }
+          else if (bytecode == tricore_insn_jltz_dm)
+            {
+	      opc_name = (char *)"jltz";
+	      opc16 = (char *)"jltz-dm";
+	    }
+          else if (bytecode == tricore_insn_jnz_dm)
+            {
+	      opc_name = (char *)"jnz";
+	      opc16 = (char *)"jnz-dm";
+	    }
+          else if (bytecode == tricore_insn_jnza_am)
+            {
+	      opc_name = (char *)"jnz.a";
+	      opc16 = (char *)"jnz.a-am";
+	      regtype = 'a';
+	    }
+          else if (bytecode == tricore_insn_jz_dm)
+            {
+	      opc_name = (char *)"jz";
+	      opc16 = (char *)"jz-dm";
+	    }
+          else if (bytecode == tricore_insn_jza_am)
+            {
+	      opc_name = (char *)"jz.a";
+	      opc16 = (char *)"jz.a-am";
+	      regtype = 'a';
+	    }
+          else
+            {
+              as_fatal (_("Internal error: unknown SBR opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+          the_insn.regs[the_insn.nops] = regno;
+          the_insn.ops[the_insn.nops] = regtype;
+          ++the_insn.nops;
+          break;
+
+        case RELAX_SBR2 + 1:		/* Convert insns of type SBR2.  */
+          bytecode = *buf & tricore_opmask[TRICORE_FMT_SBR];
+          if (optype != 'U')
+            optype = 'x';
+          regno = ((buf[1] >> 4) & 0xf);
+          regtype = 'd';
+          if (bytecode == tricore_insn_jeq_idx)
+            {
+	      opc_name = (char *)"jeq";
+              opc16 = (char *)"jeq-idx";
+	      the_insn.regs[0] = 15;
+              the_insn.ops[0] = 'i';
+	      the_insn.nops = 1;
+	    }
+          else if (bytecode == tricore_insn_jne_idx)
+            {
+	      opc_name = (char *)"jne";
+              opc16 = (char *)"jne-idx";
+	      the_insn.regs[0] = 15;
+              the_insn.ops[0] = 'i';
+	      the_insn.nops = 1;
+	    }
+          else
+            {
+              as_fatal (_("Internal error: unknown SBR2 opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+          the_insn.regs[the_insn.nops] = regno;
+          the_insn.ops[the_insn.nops] = regtype;
+          ++the_insn.nops;
+          break;
+
+        case RELAX_SBC + 1:		/* Convert insns of type SBC.  */
+          bytecode = *buf & tricore_opmask[TRICORE_FMT_SBC];
+          if (optype != 'U')
+            optype = 'm';
+          the_insn.regs[0] = 15;
+          the_insn.ops[0] = 'i';
+          VAL (1) = ((buf[1] >> 4) & 0xf);
+          /* Sign-extend if necessary.  */
+          if (VAL (1) & 0x8)
+            VAL (1) |= ~0xf;
+          the_insn.ops[1] = '4';
+          the_insn.nops = 2;
+          if (bytecode == tricore_insn_jeq_i4m)
+	    {
+	      opc_name = (char *)"jeq";
+              opc16 = (char *)"jeq-i4m";
+	    }
+          else if (bytecode == tricore_insn_jne_i4m)
+            {
+	      opc_name = (char *)"jne";
+              opc16 = (char *)"jne-i4m";
+	    }
+          else
+            {
+              as_fatal (_("Internal error: unknown SBC opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+          break;
+
+        case RELAX_SBC2 + 1:		/* Convert insns of type SBC2.  */
+          bytecode = *buf & tricore_opmask[TRICORE_FMT_SBC];
+          if (optype != 'U')
+            optype = 'x';
+          the_insn.regs[0] = 15;
+          the_insn.ops[0] = 'i';
+          VAL (1) = ((buf[1] >> 4) & 0xf);
+          /* Sign-extend if necessary.  */
+          if (VAL (1) & 0x8)
+            VAL (1) |= ~0xf;
+          the_insn.ops[1] = '4';
+          the_insn.nops = 2;
+          if (bytecode == tricore_insn_jeq_i4x)
+	    {
+	      opc_name = (char *)"jeq";
+              opc16 = (char *)"jeq-i4x";
+	    }
+          else if (bytecode == tricore_insn_jne_i4x)
+            {
+	      opc_name = (char *)"jne";
+              opc16 = (char *)"jne-i4x";
+	    }
+          else
+            {
+              as_fatal (_("Internal error: unknown SBC2 opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+          break;
+
+        case RELAX_SBRN + 1:		/* Convert insns of type SBRN.  */
+          bytecode = *buf & tricore_opmask[TRICORE_FMT_SBRN];
+          if (optype != 'U')
+            optype = 'm';
+          the_insn.regs[0] = 15;
+          the_insn.ops[0] = 'i';
+          VAL (1) = ((buf[1] >> 4) & 0x0f);
+          if (current_isa == TRICORE_V1_1)
+            {
+              VAL (1) |= ((buf[0] & 0x80) >> 3);
+              the_insn.ops[1] = '5';
+	    }
+          else
+            the_insn.ops[1] = 'f';
+          the_insn.nops = 2;
+          if (bytecode == tricore_insn_jnzt_i5m)
+            {
+	      opc_name = (char *)"jnz.t";
+              opc16 = (char *)"jnz.t-i5m";
+	    }
+          else if (bytecode == tricore_insn_jnzt_ifm)
+            {
+	      opc_name = (char *)"jnz.t";
+              opc16 = (char *)"jnz.t-ifm";
+	    }
+          else if (bytecode == tricore_insn_jzt_i5m)
+            {
+	      opc_name = (char *)"jz.t";
+              opc16 = (char *)"jz.t-i5m";
+	    }
+          else if (bytecode == tricore_insn_jzt_ifm)
+	    {
+	      opc_name = (char *)"jz.t";
+              opc16 = (char *)"jz.t-ifm";
+	    }
+          else
+            {
+              as_fatal (_("Internal error: unknown SBRN opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+          break;
+        }
+
+      /* Complete the_insn.  */
+      the_insn.opexp[the_insn.nops].X_add_symbol = fragP->fr_symbol;
+      the_insn.opexp[the_insn.nops].X_add_number = fragP->fr_offset;
+      the_insn.opexp[the_insn.nops].X_op = O_symbol;
+      the_insn.pcrel[the_insn.nops] = 1;
+      the_insn.ops[the_insn.nops] = optype;
+      the_insn.opc_address = (unsigned long) buf;
+      ++the_insn.nops;
+
+      /* Find the first opcode whose name is opc_name.  */
+      code = (opcode_t *) str_hash_find (hash_ops, opc_name);
+      if (code == (opcode_t *) 0)
+        {
+          as_fatal (_("Internal error: couldn't lookup `%s'"), opc_name);
+          return;
+        }
+      the_insn.code = code;
+
+      /* Find its 32-bit equivalent.  */
+      code = insn16_to_insn32 ();
+      if (code == (opcode_t *) 0)
+        {
+          as_fatal (_("Internal error: couldn't convert `%s'"), opc16);
+          return;
+        }
+      the_insn.code = code;
+      the_insn.opcode = code->opcode;
+
+      /* Find the relocation type.  */
+      CHECK_RELOC (the_insn.nops - 1);
+
+      /* Encode the new insn.  */
+      encode[code->format] ();
+      if (show_internals)
+        print_the_insn ();
+
+      /* Emit the new opcode.  */
+      md_number_to_chars (buf, the_insn.opcode, 4);
+    }
+  else if (convert_insn == 2)
+    {
+      unsigned long opmask, opcode = 0, jump_insn = tricore_insn_j_O;
+
+      /* Expand 32-bit instructions; this is done by inverting the condition
+         code (if any) of the instruction and inserting a jump instruction.  */
+      if (show_internals)
+        printf ("expanding 32-bit insn\n");
+
+#if EXT_LISTING
+      if (listing & LISTING_LISTING)
+        {
+          snprintf (EXT_BUF, _("Inverting condition code, adding \"j\" insn"));
+          ASM_NOTICE ();
+	}
+#endif /* EXT_LISTING  */
+
+      switch (fragP->fr_subtype)
+        {
+        case RELAX_BRX + 1:
+	  opmask = tricore_opmask[TRICORE_FMT_BRR];
+          bytecode = *buf & opmask;
+	  if ((bytecode == tricore_insn_jge_ddo)
+	      || (bytecode == tricore_insn_jgeu_ddo))
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jlt_ddo & opmask);
+	      if (tricore_insn_jlt_ddo != tricore_insn_jltu_ddo)
+	        {
+		  as_fatal (_("Internal error: jlt_ddo != jltu_ddo"));
+		  return;
+		}
+	    }
+	  else if ((bytecode == tricore_insn_jge_d4o)
+	  	   || (bytecode == tricore_insn_jgeu_dfo))
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jlt_d4o & opmask);
+	      if (tricore_insn_jlt_d4o != tricore_insn_jltu_dfo)
+	        {
+		  as_fatal (_("Internal error: jlt_d4o != jltu_dfo"));
+		  return;
+		}
+	    }
+	  else if ((bytecode == tricore_insn_jlt_ddo)
+	  	   || (bytecode == tricore_insn_jltu_ddo))
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jge_ddo & opmask);
+	      if (tricore_insn_jge_ddo != tricore_insn_jgeu_ddo)
+	        {
+		  as_fatal (_("Internal error: jge_ddo != jgeu_ddo"));
+		  return;
+		}
+	    }
+	  else if ((bytecode == tricore_insn_jlt_d4o)
+	  	   || (bytecode == tricore_insn_jltu_dfo))
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jge_d4o & opmask);
+	      if (tricore_insn_jge_d4o != tricore_insn_jgeu_dfo)
+	        {
+		  as_fatal (_("Internal error: jge_d4o != jgeu_dfo"));
+		  return;
+		}
+	    }
+	  else if ((bytecode == tricore_insn_jeq_ddo)
+	  	   || (bytecode == tricore_insn_jne_ddo)
+	  	   || (bytecode == tricore_insn_jeq_d4o)
+	  	   || (bytecode == tricore_insn_jne_d4o)
+		   || (bytecode == tricore_insn_jeqa_aao)
+		   || (bytecode == tricore_insn_jnea_aao)
+		   || (bytecode == tricore_insn_jza_ao)
+		   || (bytecode == tricore_insn_jnza_ao))
+	    {
+	      buf[3] ^= 0x80;
+	    }
+	  else
+	    {
+	      as_fatal (_("Internal error: unknown BRX opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+	  buf[2] = 0x04;
+	  md_number_to_chars (buf + 4, jump_insn, 4);
+	  fix_where += 4;
+	  break;
+
+	case RELAX_BRN + 1:
+	  opmask = tricore_opmask[TRICORE_FMT_BRN];
+	  bytecode = *buf & opmask;
+	  if ((bytecode == tricore_insn_jzt_d5o)
+	      || (bytecode == tricore_insn_jnzt_d5o))
+	    {
+	      buf[2] = 0x04;
+	      buf[3] ^= 0x80;
+	      md_number_to_chars (buf + 4, jump_insn, 4);
+	      fix_where += 4;
+	    }
+	  else
+	    {
+	      as_fatal (_("Internal error: unknown BRN opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+	  break;
+
+	case RELAX_JNEX + 1:
+	  opmask = tricore_opmask[TRICORE_FMT_BRR];
+	  bytecode = *buf & opmask;
+	  if ((bytecode == tricore_insn_jnei_ddo)
+	      || (bytecode == tricore_insn_jnei_d4o)
+	      || (bytecode == tricore_insn_jned_ddo)
+	      || (bytecode == tricore_insn_jned_d4o))
+	    {
+	      buf[2] = 0x03;
+	      opcode = tricore_insn_j_R | 0x0300;
+	      md_number_to_chars (buf + 4, opcode, 2);
+	      md_number_to_chars (buf + 6, jump_insn, 4);
+	      fix_where += 6;
+	    }
+	  else
+	    {
+	      as_fatal (_("Internal error: unknown BRN opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+	  break;
+
+	case RELAX_JNEX2 + 1:
+	  opmask = tricore_opmask[TRICORE_FMT_BRR];
+	  bytecode = *buf & opmask;
+	  if ((bytecode == tricore_insn_jnei_ddo)
+	      || (bytecode == tricore_insn_jnei_d4o)
+	      || (bytecode == tricore_insn_jned_ddo)
+	      || (bytecode == tricore_insn_jned_d4o))
+	    {
+	      buf[2] = 0x04;
+	      opcode = jump_insn | 0x40000;
+	      md_number_to_chars (buf + 4, opcode, 4);
+	      md_number_to_chars (buf + 8, jump_insn, 4);
+	      fix_where += 8;
+	    }
+	  else
+	    {
+	      as_fatal (_("Internal error: unknown BRN opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+	  break;
+
+	case RELAX_BLOOP + 1:
+	  buf[2] = 0x03;
+	  opcode = tricore_insn_j_R | 0x0300;
+	  md_number_to_chars (buf + 4, opcode, 2);
+	  md_number_to_chars (buf + 6, jump_insn, 4);
+	  fix_where += 6;
+	  break;
+
+	case RELAX_BLOOP2 + 1:
+	  buf[2] = 0x04;
+	  opcode = jump_insn | 0x40000;
+	  md_number_to_chars (buf + 4, opcode, 4);
+	  md_number_to_chars (buf + 8, jump_insn, 4);
+	  fix_where += 8;
+	  break;
+
+	case RELAX_LOOPU + 1:
+	  md_number_to_chars (buf, jump_insn, 4);
+	  break;
+	}
+    }
+  else if (convert_insn == 3)
+    {
+      unsigned long opcode = 0;
+
+      /* Convert PCP's jc and jl insns to a jc.a insn.  */
+      if (show_internals)
+        printf ("converting jc/jl to jc.a insn (PCP)\n");
+
+#if EXT_LISTING
+      if (listing & LISTING_LISTING)
+        {
+          snprintf (EXT_BUF, _("Converting \"jc\"/\"jl\" to \"jc.a\" insn"));
+          ASM_NOTICE ();
+	}
+#endif /* EXT_LISTING  */
+
+      opcode = bfd_getl16 (buf);
+      opcode = (opcode & 0xf3ff) | 0x0800;
+      md_number_to_chars (buf, opcode, 4);
+    }
+  else if (convert_insn == 4)
+    {
+      unsigned long opmask, opcode = 0, jump_insn = tricore_insn_j_O;
+
+      /* Expand 16-bit instructions; this is done by inverting the condition
+         code (if any) of the instruction and inserting a jump instruction.  */
+      if (show_internals)
+        printf ("expanding 16-bit insn\n");
+
+#if EXT_LISTING
+      if (listing & LISTING_LISTING)
+        {
+          snprintf (EXT_BUF, _("Inverting condition code, adding \"j\" insn"));
+          ASM_NOTICE ();
+	}
+#endif /* EXT_LISTING  */
+
+      switch (fragP->fr_subtype)
+        {
+        case RELAX_SB + 2:
+	  opmask = tricore_opmask[TRICORE_FMT_SB];
+          bytecode = *buf & opmask;
+	  if (bytecode == tricore_insn_jnz_iR)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jz_iR & opmask);
+	    }
+	  else if (bytecode == tricore_insn_jz_iR)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jnz_iR & opmask);
+	    }
+	  else
+	    {
+	      as_fatal (_("Internal error: unknown SB opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+	  buf[1] = 0x03;
+	  md_number_to_chars (buf + 2, jump_insn, 4);
+	  fix_where += 2;
+	  break;
+
+	case RELAX_SBC + 2:
+	case RELAX_SBC2 + 2:
+	  opmask = tricore_opmask[TRICORE_FMT_SBC];
+          bytecode = *buf & opmask;
+	  if ((bytecode == tricore_insn_jeq_i4m)
+	      || (bytecode == tricore_insn_jeq_i4x))
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jne_i4m & opmask);
+	    }
+	  else if ((bytecode == tricore_insn_jne_i4m)
+	  	   || (bytecode == tricore_insn_jne_i4x))
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jeq_i4m & opmask);
+	    }
+	  else
+	    {
+	      as_fatal (_("Internal error: unknown SBC opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+	  buf[1] &= 0xf0;
+	  buf[1] |= 0x03;
+	  md_number_to_chars (buf + 2, jump_insn, 4);
+	  fix_where += 2;
+	  break;
+
+	case RELAX_SBR + 2:
+	case RELAX_SBR2 + 2:
+	  opmask = tricore_opmask[TRICORE_FMT_SBR];
+          bytecode = *buf & opmask;
+	  if ((bytecode == tricore_insn_jeq_idm)
+	      || (bytecode == tricore_insn_jeq_idx))
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jne_idm & opmask);
+	    }
+	  else if ((bytecode == tricore_insn_jne_idm)
+	  	   || (bytecode == tricore_insn_jne_idx))
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jeq_idm & opmask);
+	    }
+	  else if (bytecode == tricore_insn_jgez_dm)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jltz_dm & opmask);
+	    }
+	  else if (bytecode == tricore_insn_jltz_dm)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jgez_dm & opmask);
+	    }
+	  else if (bytecode == tricore_insn_jgtz_dm)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jlez_dm & opmask);
+	    }
+	  else if (bytecode == tricore_insn_jlez_dm)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jgtz_dm & opmask);
+	    }
+	  else if (bytecode == tricore_insn_jnz_dm)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jz_dm & opmask);
+	    }
+	  else if (bytecode == tricore_insn_jz_dm)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jnz_dm & opmask);
+	    }
+	  else if (bytecode == tricore_insn_jnza_am)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jza_am & opmask);
+	    }
+	  else if (bytecode == tricore_insn_jza_am)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jnza_am & opmask);
+	    }
+	  else
+	    {
+	      as_fatal (_("Internal error: unknown SBR opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+	  buf[1] &= 0xf0;
+	  buf[1] |= 0x03;
+	  md_number_to_chars (buf + 2, jump_insn, 4);
+	  fix_where += 2;
+	  break;
+
+        case RELAX_SBRN + 2:
+	  opmask = tricore_opmask[TRICORE_FMT_SBRN];
+          bytecode = *buf & opmask;
+	  if (bytecode == tricore_insn_jnzt_ifm)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jzt_ifm & opmask);
+	    }
+	  else if (bytecode == tricore_insn_jzt_ifm)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jnzt_ifm & opmask);
+	    }
+	  else if (bytecode == tricore_insn_jnzt_i5m)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jzt_i5m & opmask);
+	    }
+	  else if (bytecode == tricore_insn_jzt_i5m)
+	    {
+	      *buf &= ~opmask;
+	      *buf |= (tricore_insn_jnzt_i5m & opmask);
+	    }
+	  else
+	    {
+	      as_fatal (_("Internal error: unknown SBRN opcode 0x%02x"),
+	      		bytecode);
+	      return;
+	    }
+	  buf[1] &= 0xf0;
+	  buf[1] |= 0x03;
+	  md_number_to_chars (buf + 2, jump_insn, 4);
+	  fix_where += 2;
+	  break;
+
+        case RELAX_LOOP + 2:
+	  opcode = tricore_insn_loop_ao;
+	  opcode |= (0x30000 | ((buf[1] & 0xf0) << 8));
+	  md_number_to_chars (buf, opcode, 4);
+	  opcode = tricore_insn_j_R | 0x0300;
+	  md_number_to_chars (buf + 4, opcode, 2);
+	  md_number_to_chars (buf + 6, jump_insn, 4);
+	  fix_where += 6;
+	  break;
+        }
+    }
+  else
+    {
+      as_fatal (_("Internal error: convert_insn = %d"), convert_insn);
+      return;
+    }
+
+  /* Set the frag's new fixed size, reset its variable size, and emit a
+     fixup for the symbol, which will either be resolved in md_apply_fix3,
+     or converted to a relocation in tc_gen_reloc.  */
+  fragP->fr_fix += md_relax_table[fragP->fr_subtype].rlx_length;
+  fragP->fr_var = 0;
+  new_fix = fix_new (fragP, fix_where, 0, fragP->fr_symbol,
+		     fragP->fr_offset, pcrel, reloc);
+  new_fix->fx_file = fragP->fr_file;
+  new_fix->fx_line = fragP->fr_line;
+  if (show_internals)
+    printf ("*** fix_new (%s, %ld)\n", GET_RELOC_NAME (reloc), fix_where);
+}
+
+/* Check whether a fixup for a PCP instruction can be resolved; if so, the
+   opcode will be patched appropriately and the fixup will be removed
+   afterwards, otherwise it'll be turned into a relocation by tc_gen_reloc.  */
+
+static void
+md_pcp_apply_fix (fixS * fixP, valueT *valP, enum bfd_reloc_code_real reloc, char *buf)
+{
+  unsigned long code = 0;
+  long val;
+#define BAD as_bad_where
+#define WHERE fixP->fx_file, fixP->fx_line
+
+  if (show_internals)
+    printf ("*** md_pcp_apply_fix (%lx, %s#%d, %s)\n", (valueT) buf,
+    	    fixP->fx_file, fixP->fx_line, GET_RELOC_NAME (reloc));
+
+  if (fixP->fx_addsy)
+    {
+      if (fixP->fx_pcrel
+	  && (S_GET_SEGMENT (fixP->fx_addsy) == absolute_section))
+	val = fixP->fx_offset + S_GET_VALUE (fixP->fx_addsy);
+      else
+	{
+	  /* Relocation needed; remember *valP.  */
+	  fixP->fx_addnumber = *valP;
+	  return;
+	}
+    }
+  else
+    val = *valP;
+
+  code = bfd_getl16 (buf);
+
+  switch (reloc)
+    {
+    case BFD_RELOC_TRICORE_PCPHI:
+      code = ((val >> 16) & 0xffff);
+      break;
+
+    case BFD_RELOC_TRICORE_PCPLO:
+      code = (val & 0xffff);
+      break;
+
+    case BFD_RELOC_TRICORE_PCPPAGE:
+      if (val & 0x3)
+        {
+          BAD (WHERE, _("PRAM target address is not word-aligned"));
+	  break;
+	}
+      if (val & 0xff)
+	as_warn (_("PRAM address (0x%08lx) should be "
+		   "aligned to a 256-byte boundary"),
+		 val);
+      code |= (val & 0xff00);
+      break;
+
+    case BFD_RELOC_TRICORE_PCPOFF:
+      if (val & 0x3)
+        {
+          BAD (WHERE, _("PRAM target address (0x%08lx) is not word-aligned"),
+	       val);
+	  break;
+	}
+      code |= ((val >> 2) & 0x3f);
+      break;
+
+    case BFD_RELOC_TRICORE_PCPTEXT:
+      if ((val < 0) || (val > 65535))
+        BAD (WHERE, _("PCP code address 0x%08lx out of range [0..65535]"), val);
+      else
+        code |= val;
+      break;
+
+    case BFD_RELOC_TRICORE_PCPREL10:
+      if (val & 1)
+        {
+          BAD (WHERE, _("Displacement %ld is not even"), val);
+	  break;
+	}
+      val >>= 1;
+      if ((val < -512) || (val > 511))
+        BAD (WHERE, _("Displacement %ld out of range [-512..511]"), val);
+      else
+        code |= (val & 0x3ff);
+      break;
+
+    case BFD_RELOC_TRICORE_PCPREL6:
+      if (val & 1)
+        {
+          BAD (WHERE, _("Displacement %ld is not even"), val);
+	  break;
+	}
+      val >>= 1;
+      if ((val < -32) || (val > 31))
+        BAD (WHERE, _("Displacement %ld out of range [-32..31]"), val);
+      else
+        code |= (val & 0x3f);
+      break;
+
+    default:
+      BAD (WHERE, _("Internal error: unimplemented PCP relocation %d"), reloc);
+      break;
+    }
+
+  /* Write back the fixed-up insn.  */
+  md_number_to_chars ((char *)buf, code, 2);
+  fixP->fx_done = 1;
+
+  if (show_internals)
+    printf ("*** new fixed opcode: 0x%04lx\n", code);
+
+#undef BAD
+#undef WHERE
+}
+
+/* Check whether a fixup for a TriCore instruction can be resolved; if so,
+   the opcode will be patched appropriately and the fixup will be removed
+   afterwards, otherwise it'll be turned into a relocation by tc_gen_reloc.  */
+
+void
+md_apply_fix (fixS *fixP, valueT *valP, segT segment ATTRIBUTE_UNUSED)
+{
+  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
+  unsigned long opcode;
+  enum bfd_reloc_code_real reloc = fixP->fx_r_type;
+  long val;
+  int len32;
+#define BAD as_bad_where
+#define WHERE fixP->fx_file, fixP->fx_line
+#define CHECK_DISPLACEMENT(off,min,max)					\
+  if ((off) & 1)							\
+    {									\
+      BAD (WHERE, _("Displacement 0x%08lx is not even"), (off));	\
+      break;								\
+    }									\
+  else if (((off) < (min)) || ((off) > (max)))				\
+    {									\
+      BAD (WHERE, _("Displacement 0x%08lx out of range"), (off));	\
+      break;								\
+    }
+
+  switch (reloc)
+    {
+    case BFD_RELOC_TRICORE_PCPHI:
+    case BFD_RELOC_TRICORE_PCPLO:
+    case BFD_RELOC_TRICORE_PCPPAGE:
+    case BFD_RELOC_TRICORE_PCPOFF:
+    case BFD_RELOC_TRICORE_PCPTEXT:
+    case BFD_RELOC_TRICORE_PCPREL6:
+    case BFD_RELOC_TRICORE_PCPREL10:
+      return md_pcp_apply_fix (fixP, valP, reloc, buf);
+
+    default:
+      break;  /* TriCore relocations are handled below.  */
+    }
+
+  //if (show_internals)
+  //  printf ("*** md_apply_fix3 (%lx, %s#%d, %s)\n", (valueT) buf,
+  //          fixP->fx_file, fixP->fx_line, GET_RELOC_NAME (reloc));
+
+  if (fixP->fx_addsy)
+    {
+      if (fixP->fx_pcrel
+          && (S_GET_SEGMENT (fixP->fx_addsy) == absolute_section))
+	{
+	  /* This happens if we have something like:
+	        call gaga
+	        .set gaga,42
+	     In this case, the relocation value is that of
+	     the symbol plus the optional offset, and the luser
+	     who committed this sequence is, well, gaga.  :-)  */
+	  val = fixP->fx_offset + S_GET_VALUE (fixP->fx_addsy);
+	}
+      else if (fixP->fx_subsy
+      	       && (S_GET_SEGMENT (fixP->fx_subsy)
+	           == S_GET_SEGMENT (fixP->fx_addsy))
+	       && SEG_NORMAL (S_GET_SEGMENT (fixP->fx_addsy)))
+	{
+	  /* This happens when differences between two labels within
+	     the same section (usually some text section) are
+	     computed, and the "add" symbol is global -- in which case
+	     tricore_force_relocation() will have returned 1 and thus
+	     prevented write.c:fixup_segment() from resolving this
+	     fixup.  However, fixup_segment() has already computed the
+	     final value in *valP, so we can safely use this value and
+	     immediately resolve the fixup instead of forcing a reloc.  */
+	  val = *valP;
+	}
+      else
+        {
+          /* Relocation needed; remember *valP.  */
+          fixP->fx_addnumber = *valP;
+
+	  /* If this is a relocation against an absolute symbol,
+	     we must subtract the symbol's value from fx_addnumber.  */
+	  if (S_GET_SEGMENT (fixP->fx_addsy) == absolute_section)
+	    fixP->fx_addnumber -= S_GET_VALUE (fixP->fx_addsy);
+
+	  /* Turn absolute data relocations into pc-relative ones.  */
+          if (fixP->fx_pcrel)
+	    {
+	      switch (reloc)
+	        {
+		case BFD_RELOC_8:
+		case BFD_RELOC_TRICORE_8ABS:
+                  fixP->fx_r_type = BFD_RELOC_8_PCREL;
+		  break;
+
+                case BFD_RELOC_16:
+		case BFD_RELOC_TRICORE_16ABS:
+                  fixP->fx_r_type = BFD_RELOC_16_PCREL;
+		  break;
+
+	        case BFD_RELOC_32:
+		case BFD_RELOC_TRICORE_32ABS:
+                  fixP->fx_r_type = BFD_RELOC_32_PCREL;
+		  break;
+
+		default:
+		  break;
+		}
+	    }
+          return;
+	}
+    }
+  else
+    val = *valP;
+
+  if (reloc == BFD_RELOC_TRICORE_BITPOS)
+    {
+      /* This fixup can be resolved, which means that there was an
+         operand like "bpos: foo", and "foo" eventually turned out to
+	 be an absolute symbol (defined by a statement like "foo=42").
+	 We can safely throw away this fixup, because the next fixup
+	 will be for the same instruction and against the same symbol,
+	 so it can also be resolved (and applied to this instruction,
+	 according to its relocation type).  */
+      fixP->fx_done = 1;
+      return;
+    }
+
+  /* Handle simple data relocations.  */
+  if (reloc == BFD_RELOC_8)
+    {
+      md_number_to_chars (buf, val, 1);
+      fixP->fx_done = 1;
+      return;
+    }
+  else if (reloc == BFD_RELOC_16)
+    {
+      md_number_to_chars (buf, val, 2);
+      fixP->fx_done = 1;
+      return;
+    }
+  else if (reloc == BFD_RELOC_32)
+    {
+      md_number_to_chars (buf, val, 4);
+      fixP->fx_done = 1;
+      return;
+    }
+
+  /* VTABLE relocations must be handled by the linker.  */
+  if ((reloc == BFD_RELOC_VTABLE_ENTRY) || (reloc == BFD_RELOC_VTABLE_INHERIT))
+    {
+      fixP->fx_done = 0;
+      return;
+    }
+
+  /* It's a fixup/relocation against an instruction.  */
+  opcode = 0;
+  len32 = (*buf & 1);
+  if (len32)
+    opcode = bfd_getl32 (buf);
+  else
+    opcode = bfd_getl16 (buf);
+
+  switch (reloc)
+    {
+    case BFD_RELOC_TRICORE_24REL:
+      CHECK_DISPLACEMENT (val, -16777216, 16777214);
+      val >>= 1;
+      opcode |= ((val & 0xffff) << 16);
+      opcode |= ((val & 0xff0000) >> 8);
+      break;
+
+    case BFD_RELOC_TRICORE_24ABS:
+      if (val & 0x0fe00001)
+        {
+          BAD (WHERE, _("Illegal 24-bit absolute address 0x%08lx"), val);
+	  break;
+	}
+      val >>= 1;
+      val |= ((val & 0x78000000) >> 7);
+      opcode |= ((val & 0xffff) << 16);
+      opcode |= ((val & 0xff0000) >> 8);
+      break;
+
+    case BFD_RELOC_TRICORE_18ABS:
+      if (val & 0x0fffc000)
+        {
+	  BAD (WHERE, _("Illegal 18-bit absolute address 0x%08lx"), val);
+	  break;
+	}
+      opcode |= ((val & 0x3f) << 16);
+      opcode |= ((val & 0x3c0) << 22);
+      opcode |= ((val & 0x3c00) << 12);
+      opcode |= ((val & 0xf0000000) >> 16);
+      break;
+
+    case BFD_RELOC_TRICORE_HI:
+      opcode |= (((val >> 16) & 0xffff) << 12);
+      break;
+
+    case BFD_RELOC_TRICORE_HIADJ:
+      opcode |= ((((val + 0x8000) >> 16) & 0xffff) << 12);
+      break;
+
+    case BFD_RELOC_TRICORE_LO:
+      opcode |= ((val & 0xffff) << 12);
+      break;
+
+    case BFD_RELOC_TRICORE_LO2:
+      opcode |= ((val & 0x3f) << 16);
+      opcode |= ((val & 0x3c0) << 22);
+      opcode |= ((val & 0xfc00) << 12);
+      break;
+
+    case BFD_RELOC_TRICORE_16SM:
+    case BFD_RELOC_TRICORE_10SM:
+    case BFD_RELOC_TRICORE_16SM2:
+      BAD (WHERE, _("Illegal prefix (sm:) for constant offset"));
+      break;
+
+    case BFD_RELOC_TRICORE_16CONST:
+      if ((val < -32768) || (val > 32767))
+        {
+	  BAD (WHERE, _("16-bit signed value overflow (0x%08lx)"), val);
+	  break;
+	}
+      opcode |= ((val & 0xffff) << 12);
+      break;
+
+    case BFD_RELOC_TRICORE_15REL:
+      CHECK_DISPLACEMENT (val, -32768, 32766);
+      opcode |= (((val >> 1) & 0x7fff) << 16);
+      break;
+
+    case BFD_RELOC_TRICORE_9ZCONST:
+      if (val & ~511)
+        {
+	  BAD (WHERE, _("9-bit unsigned value overflow (0x%08lx)"), val);
+	  break;
+	}
+      opcode |= (val << 12);
+      break;
+
+    case BFD_RELOC_TRICORE_9SCONST:
+      if ((val < -256) || (val > 255))
+        {
+	  BAD (WHERE, _("9-bit signed value overflow (%ld)"), val);
+	  break;
+	}
+      opcode |= ((val & 0x1ff) << 12);
+      break;
+
+    case BFD_RELOC_TRICORE_8REL:
+      CHECK_DISPLACEMENT (val, -256, 254);
+      val >>= 1;
+      opcode |= ((val & 0xff) << 8);
+      break;
+
+    case BFD_RELOC_TRICORE_8CONST:
+      if (val & ~255)
+        {
+          BAD (WHERE, _("8-bit unsigned value overflow (0x%08lx)"), val);
+	  break;
+	}
+      opcode |= (val << 8);
+      break;
+
+    case BFD_RELOC_TRICORE_10OFF:
+      if ((val < -512) || (val > 511))
+        {
+          BAD (WHERE, _("10-bit signed offset overflow (%ld)"), val);
+	  break;
+	}
+      opcode |= ((val & 0x3f) << 16);
+      opcode |= ((val & 0x3c0) << 22);
+      break;
+
+    case BFD_RELOC_TRICORE_16OFF:
+      if ((val < -32768) || (val > 32767))
+        {
+          BAD (WHERE, _("16-bit signed offset overflow (%ld)"), val);
+	  break;
+	}
+      opcode |= ((val & 0x3f) << 16);
+      opcode |= ((val & 0x3c0) << 22);
+      opcode |= ((val & 0xfc00) << 12);
+      break;
+
+    case BFD_RELOC_TRICORE_1BIT:
+      if (val & ~1)
+        {
+	  BAD (WHERE, _("Invalid bit value (%ld)"), val);
+	  break;
+	}
+      opcode |= (val << 11);
+      break;
+
+    case BFD_RELOC_TRICORE_3POS:
+      if (val & ~7)
+        {
+	  BAD (WHERE, _("Invalid 3-bit bit position (%ld)"), val);
+	  break;
+	}
+      opcode |= (val << 8);
+      break;
+
+    case BFD_RELOC_TRICORE_5POS:
+      if (val & ~31)
+        {
+	  BAD (WHERE, _("Invalid 5-bit bit position (%ld)"), val);
+	  break;
+	}
+      opcode |= (val << 16);
+      break;
+
+    case BFD_RELOC_TRICORE_5POS2:
+      if (val & ~31)
+        {
+	  BAD (WHERE, _("Invalid 5-bit bit position (%ld)"), val);
+	  break;
+	}
+      opcode |= (val << 23);
+      break;
+
+    case BFD_RELOC_TRICORE_BRCC:
+      if ((val < -8) || (val > 7))
+	{
+	  BAD (WHERE, _("4-bit signed value overflow (%ld)"), val);
+	  break;
+	}
+      opcode |= ((val & 0xf) << 12);
+      break;
+
+    case BFD_RELOC_TRICORE_BRCZ:
+      if (val & ~15)
+	{
+	  BAD (WHERE, _("4-bit unsigned value overflow (0x%08lx)"), val);
+	  break;
+	}
+      opcode |= (val << 12);
+      break;
+
+    case BFD_RELOC_TRICORE_BRNN:
+      if (val & ~31)
+        {
+	  BAD (WHERE, _("Invalid 5-bit bit position (%ld)"), val);
+	  break;
+	}
+      opcode |= ((val & 0xf) << 12);
+      opcode |= ((val & 0x10) << 3);
+      break;
+
+    case BFD_RELOC_TRICORE_RRN:
+      if (val & ~3)
+        {
+	  BAD (WHERE, _("2-bit unsigned value overflow (0x%08lx)"), val);
+	  break;
+	}
+      opcode |= (val << 16);
+      break;
+
+    case BFD_RELOC_TRICORE_4CONST:
+      if ((val < -8) || (val > 7))
+        {
+	  BAD (WHERE, _("4-bit signed value overflow (%ld)"), val);
+	  break;
+	}
+      opcode |= ((val & 0xf) << 12);
+      break;
+
+    case BFD_RELOC_TRICORE_4REL:
+      CHECK_DISPLACEMENT (val, 0, 30);
+      val >>= 1;
+      opcode |= ((val & 0xf) << 8);
+      break;
+
+    case BFD_RELOC_TRICORE_4REL2:
+      CHECK_DISPLACEMENT (val, -32, -2);
+      val >>= 1;
+      opcode |= ((val & 0xf) << 8);
+      break;
+
+    case BFD_RELOC_TRICORE_5REL:
+      CHECK_DISPLACEMENT (val, 0, 62);
+      val >>= 1;
+      opcode &= ~0x0080;
+      opcode |= ((val & 0xf) << 8);
+      opcode |= ((val & 0x10) << 3);
+      break;
+
+    case BFD_RELOC_TRICORE_4POS:
+      if (val & ~15)
+        {
+	  BAD (WHERE, _("Invalid 4-bit bit position (%ld)"), val);
+	  break;
+	}
+      opcode |= ((val & 0xf) << 12);	
+      break;
+
+    case BFD_RELOC_TRICORE_5POS3:
+      if (val & ~31)
+        {
+	  BAD (WHERE, _("Invalid 5-bit bit position (%ld)"), val);
+	  break;
+	}
+      opcode |= ((val & 0xf) << 12);
+      opcode |= ((val & 0x10) << 3);
+      break;
+
+    case BFD_RELOC_TRICORE_4OFF:
+      if (val & ~15)
+        {
+          BAD (WHERE, _("4-bit unsigned offset overflow (0x%08lx)"), val);
+	  break;
+	}
+      opcode |= (val << 12);
+      break;
+
+    case BFD_RELOC_TRICORE_4OFF2:
+      if (val & ~31)
+        {
+          BAD (WHERE, _("5-bit unsigned offset overflow (0x%08lx)"), val);
+	  break;
+	}
+      else if (val & 1)
+        {
+          BAD (WHERE, _("5-bit unsigned offset is not even (0x%08lx)"), val);
+	  break;
+	}
+      opcode |= (val << 11);
+      break;
+
+    case BFD_RELOC_TRICORE_4OFF4:
+      if (val & ~63)
+        {
+          BAD (WHERE, _("6-bit unsigned offset overflow (0x%08lx)"), val);
+	  break;
+	}
+      else if (val & 3)
+        {
+          BAD (WHERE,
+	       _("6-bit unsigned offset is not a multiple of 4 (0x%08lx)"),
+	       val);
+	  break;
+	}
+      opcode |= (val << 10);
+      break;
+
+    case BFD_RELOC_TRICORE_42OFF:
+      if (val & ~15)
+        {
+          BAD (WHERE, _("4-bit unsigned offset overflow (0x%08lx)"), val);
+	  break;
+	}
+      opcode |= (val << 8);
+      break;
+
+    case BFD_RELOC_TRICORE_42OFF2:
+      if (val & ~31)
+        {
+          BAD (WHERE, _("5-bit unsigned offset overflow (0x%08lx)"), val);
+	  break;
+	}
+      else if (val & 1)
+        {
+          BAD (WHERE, _("5-bit unsigned offset is not even (0x%08lx)"), val);
+	  break;
+	}
+      opcode |= (val << 7);
+      break;
+
+    case BFD_RELOC_TRICORE_42OFF4:
+      if (val & ~63)
+        {
+          BAD (WHERE, _("6-bit unsigned offset overflow (0x%08lx)"), val);
+	  break;
+	}
+      else if (val & 3)
+        {
+          BAD (WHERE,
+	       _("6-bit unsigned offset is not a multiple of 4 (0x%08lx)"),
+	       val);
+	  break;
+	}
+      opcode |= (val << 6);
+      break;
+
+    case BFD_RELOC_TRICORE_2OFF:
+      if (val & ~3)
+        {
+          BAD (WHERE, _("2-bit unsigned value overflow (0x%08lx)"), val);
+	  break;
+	}
+      opcode |= (val << 6);
+      break;
+
+    case BFD_RELOC_TRICORE_8CONST2:
+      if (val & ~1023)
+        {
+	  BAD (WHERE, _("10-bit unsigned offset overflow (0x%08lx)"), val);
+	  break;
+	}
+      else if (val & 3)
+        {
+	  BAD (WHERE,
+	       _("10-bit unsigned offset is not a multiple of 4 (0x%08lx)"),
+	       val);
+	  break;
+	}
+      opcode |= (val << 6);
+      break;
+
+    case BFD_RELOC_TRICORE_GOT:
+    case BFD_RELOC_TRICORE_GOT2:
+    case BFD_RELOC_TRICORE_GOTHI:
+    case BFD_RELOC_TRICORE_GOTLO:
+    case BFD_RELOC_TRICORE_GOTLO2:
+    case BFD_RELOC_TRICORE_GOTUP:
+    case BFD_RELOC_TRICORE_GOTOFF:
+    case BFD_RELOC_TRICORE_GOTOFF2:
+    case BFD_RELOC_TRICORE_GOTOFFHI:
+    case BFD_RELOC_TRICORE_GOTOFFLO:
+    case BFD_RELOC_TRICORE_GOTOFFLO2:
+    case BFD_RELOC_TRICORE_GOTOFFUP:
+    case BFD_RELOC_TRICORE_GOTPC:
+    case BFD_RELOC_TRICORE_GOTPC2:
+    case BFD_RELOC_TRICORE_GOTPCHI:
+    case BFD_RELOC_TRICORE_GOTPCLO:
+    case BFD_RELOC_TRICORE_GOTPCLO2:
+    case BFD_RELOC_TRICORE_GOTPCUP:
+      BAD (WHERE, _("GOT-relocation not allowed for constants"));
+      break;
+
+    case BFD_RELOC_TRICORE_PLT:
+      BAD (WHERE, _("Illegal prefix (plt:) for constant offset"));
+      break;
+
+    default:
+      BAD (WHERE, _("Internal error: can't handle reloc %d"), reloc);
+      break;
+    }
+
+  /* Write back the fixed-up insn.  */
+  md_number_to_chars (buf, opcode, len32 ? 4 : 2);
+  fixP->fx_done = 1;
+
+  if (show_internals)
+    {
+      if (len32)
+        printf ("*** new fixed opcode: 0x%08lx\n", opcode);
+      else
+        printf ("*** new fixed opcode: 0x%04lx\n", opcode);
+    }
+
+#undef BAD
+#undef WHERE
+#undef CHECK_DISPLACEMENT
+}
+
+/* Translate the internal representation of a relocation info (pointed to
+   by FIXP) to the BFD target format; SECTION points to the section which
+   contains the relocation.  */
+
+arelent *
+tc_gen_reloc (section, fixP)
+     asection *section ATTRIBUTE_UNUSED;
+     fixS *fixP;
+{
+  arelent *reloc;
+  enum bfd_reloc_code_real code = fixP->fx_r_type;
+
+  if (show_internals)
+    {
+      char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
+
+      printf ("*** tc_gen_reloc (%lx, %s#%d, %s)\n", (valueT) buf,
+              fixP->fx_file, fixP->fx_line, GET_RELOC_NAME (code));
+    }
+
+  reloc = (arelent *) xmalloc (sizeof (arelent));
+  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixP->fx_addsy);
+  reloc->address = fixP->fx_frag->fr_address + fixP->fx_where;
+  reloc->addend = fixP->fx_addnumber;
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
+  if (!reloc->howto)
+    {
+      as_bad_where (fixP->fx_file, fixP->fx_line,
+      		    "Internal error: don't know howto reloc type %d", code);
+      return (arelent *) 0;
+    }
+
+  return reloc;
+}
+
+/* Helper function for tricore_sort_relocs: given any two relocations R1
+   and R2 for the same section, return -1 or 1, depending on whether R1
+   should appear before or after R2 in the final list of relocations for
+   this section.  Note that we must preserve the order in case of several
+   relocation entries for the same instruction (and thus the same address
+   within the section) because of "pseudo" relocs like R_TRICORE_BITPOS,
+   which must precede an "actual" reloc that effects an instruction fixup;
+   so if R1 and R2 address the same instruction, the one appearing first
+   in the list of fixups is considered "smaller" than the other one.  */
+
+static int
+compare_relocs (r1, r2)
+     const void *r1, *r2;
+{
+  const rel_entry *rel1 = r1, *rel2 = r2;
+  int retval = -1;
+
+  if ((rel1->reloc->address > rel2->reloc->address)
+      || ((rel1->reloc->address == rel2->reloc->address)
+          && (rel1->index > rel2->index)))
+    retval = 1;
+
+#ifdef REVERSE_SORT_RELOCS
+  return -retval;
+#else
+  return retval;
+#endif
+}
+
+/* RELOCS is an array containing N pointers to relocation entries for SECTION;
+   sort them in ascending (or descending, #ifdef REVERSE_SORT_RELOCS) order,
+   just in case some utility expects them to be sorted by addresses.  Usually,
+   this sorting is done automatically, because GAS emits relocations in the
+   same order as the fixups requested by calls to fix_new or fix_new_exp.  
+   However, this doesn't work here, because for relaxable instructions, we
+   cannot create fixups until we know the final instruction -- which is only
+   determined in md_convert_frag --, and since fixups for non-relaxable insns
+   will be created immediately in emit_code, the resulting relocs will appear
+   before the relocs for relaxable insns, thus breaking the "natural" order.  */
+
+void
+tricore_sort_relocs (section, relocs, n)
+     asection *section;
+     arelent **relocs;
+     unsigned int n;
+{
+  rel_entry *srelocs;
+  unsigned int i;
+
+  /* Since the "natural" sort order can only be spoiled by relaxable
+     instructions, we only need to consider actual code sections.  */
+  if (!(section->flags & SEC_CODE) || (n < 2))
+    return;
+
+  if (show_internals)
+    printf ("*** Sorting %u relocs for section \"%s\"\n", n, section->name);
+
+  /* If there are several relocs for the same instruction, their order
+     is significant (see compare_relocs above for an explanation), so
+     we need to remember their original position.  */
+  srelocs = (rel_entry *) xmalloc (n * sizeof (rel_entry));
+  for (i = 0; i < n; ++i)
+    {
+      srelocs[i].reloc = relocs[i];
+      srelocs[i].index = i;
+    }
+
+  /* Now sort the entries...  */
+  qsort (srelocs, n, sizeof (rel_entry), compare_relocs);
+
+  /* ...and put them back into the relocs array in their new order.  */
+  for (i = 0; i < n; ++i)
+    relocs[i] = srelocs[i].reloc;
+
+  free (srelocs);
+}
+
+/* Round up a section size to the appropriate boundary.  */
+
+valueT
+md_section_align (segment, size)
+     segT segment;
+     valueT size;
+{
+  unsigned int align = bfd_section_alignment(segment);
+
+  return ((size + (1 << align) - 1) & (~0U << align));
+}
+
+/* Exactly what point is a PC-relative offset relative to?  On the
+   TriCore, it's relative to the start address of the insn itself.
+   However, if the fixup references a symbol living in a different
+   section, we just return zero, as the linker (or more precisely,
+   the BFD function elf32-tricore.c:tricore_elf32_relocate_section)
+   will subtract the offset from the insn to the beginning of the
+   section from the relocation value.  That way, the r_addend value
+   of a reloc entry produced by the assembler actually contains the
+   fixup's fx_offset value, and not fx_offset - "seg_off (insn)".
+   For the PCP, however, the offset is always relative to the next insn.  */
+
+long
+md_pcrel_from_section(fixS* fixP, segT segment)
+{
+//  if (segment->flags & PCP_SEG)
+//    return fixP->fx_frag->fr_address + fixP->fx_where + 2;
+
+  if ((fixP->fx_subsy != (symbolS *) 0)
+      || ((fixP->fx_addsy != (symbolS *) 0)
+          && (((S_GET_SEGMENT (fixP->fx_addsy) == segment))
+              || (S_GET_SEGMENT (fixP->fx_addsy) == absolute_section))
+	  && S_IS_DEFINED (fixP->fx_addsy)
+	  && !S_IS_EXTERNAL (fixP->fx_addsy)
+	  && !S_IS_WEAK (fixP->fx_addsy)))
+    /* Return "seg_off (insn)", i.e., the start address of the insn
+       relative to the beginning of this segment.  */
+    return fixP->fx_frag->fr_address + fixP->fx_where;
+
+  return 0;
+}
+
+/* See if a fix can be adjusted (i.e., locally resolved by using the
+   offset relative to the beginning of the section in which a symbol
+   is defined).  */
+
+int
+tricore_fix_adjustable (fixP)
+     fixS *fixP;
+{
+  if (fixP->fx_addsy == NULL)
+    return 1;
+
+  /* Prevent all adjustments to global or weak symbols, or symbols in
+     merge sections.  */
+  if ((S_IS_EXTERNAL (fixP->fx_addsy)
+       || (S_IS_WEAK (fixP->fx_addsy))
+       || (S_GET_SEGMENT (fixP->fx_addsy)->flags & SEC_MERGE) != 0))
+    return 0;
+
+  /* We need the symbol name for the VTABLE entries.  */
+  if ((fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT)
+      || (fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY))
+    return 0;
+
+  /* GOT/PLT relocations can't be adjusted, either.  */
+  if ((fixP->fx_r_type == BFD_RELOC_TRICORE_GOT)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOT2)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTHI)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTLO)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTLO2)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTUP)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTOFF)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTOFF2)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTOFFHI)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTOFFLO)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTOFFLO2)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTOFFUP)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTPC)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTPC2)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTPCLO)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTPCLO2)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTPCHI)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_GOTPCUP)
+      || (fixP->fx_r_type == BFD_RELOC_TRICORE_PLT))
+    return 0;
+
+  return 1;
+}
+
+/* Emit relocations for references to VTABLE entries and global or
+   weak symbols.  */
+
+int
+tricore_force_relocation (fixP)
+     fixS *fixP;
+{
+  if ((fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT)
+      || (fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY))
+    return 1;
+
+  if ((fixP->fx_addsy != NULL)
+      && (S_IS_EXTERNAL (fixP->fx_addsy) || S_IS_WEAK (fixP->fx_addsy)))
+    return 1;
+
+  return 0;
+}
+
+/* Set the machine type in the header of a TriCore ELF file.  */
+
+void
+tricore_elf_final_processing ()
+{
+  elf_elfheader (stdoutput)->e_flags = current_isa;
+}
+
+/* Parse the PCP instruction starting at STR and fill pcp_insn.  */
+
+// static void
+// pcp_ip (const char* str)
+// {
+//   char *src, *dst, *equ, *pos, *cp;
+//   int numops = -1;
+//   size_t str_len;
+//   int indirect;
+//   const char *flags = " cnc cnt0 size st ec int ep dac rta rna eda sdb";
+//   const char *flops = ".c4 .n4  .f5  .g3.h3.i4 .j3.m4 .o4 .o4 .p4 .q4 ";
+
+//   if ((str_len = strlen (str)) >= insnline_len)
+//     {
+//       insnline_len = str_len + 1;
+//       insnline = xrealloc (insnline, insnline_len);
+//     }
+
+//   /* Make a lower-case-only copy of the input line.  */
+//   for (src = (char*) str, dst = insnline; *src; /* Empty.  */)
+//     if ((*src >= 'A') && (*src <= 'Z'))
+//       *dst++ = (*src++) - 'A' + 'a';
+//     else
+//       *dst++ = *src++;
+//   *dst = '\0';
+
+//   /* Lookup the instruction name.  */
+//   dst = strtok (insnline, ", ");
+
+//   if ((pcp_insn.code = (pcp_opcode_t *) str_hash_find (hash_pcp, insnline)) == NULL)
+//     {
+//       pcp_insn.error = _("Unknown PCP instruction");
+//       return;
+//     }
+
+//   /* Parse the operands.  */
+//   while ((dst = strtok (NULL, ", ")) != NULL)
+//     {
+//       if (++numops == MAX_PCPOPS)
+//         {
+// 	  pcp_insn.error = _("Too many operands");
+// 	  return;
+// 	}
+
+//       /* Check if indirection mode.  */
+//       indirect = 0;
+//       if (*dst == '[')
+//         { ++dst;
+// 	  indirect = 1;
+// 	}
+
+//       /* Check if it's a register.  */
+//       if ((*dst == 'r') && ((dst[1] >= '0') && (dst[1] <= '7')))
+//         {
+// 	  if (indirect && (dst[2] == ']'))
+// 	    {
+// 	      if (dst[3] == '\0')
+// 	        {
+// 		  pcp_insn.ops[numops] = 'R';
+// 		  PCPVAL (numops) = dst[1] - '0';
+// 		  continue;
+// 		}
+// 	      else
+// 	        {
+// 		  pcp_insn.error = _("Trailing chars after register indirect");
+// 		  return;
+// 		}
+// 	    }
+// 	  else if (!indirect && (dst[2] == '\0'))
+// 	    {
+// 	      pcp_insn.ops[numops] = 'r';
+// 	      PCPVAL (numops) = dst[1] - '0';
+// 	      continue;
+// 	    }
+// 	}
+
+//       /* Check if it's src{+-} or dst{+-}.  */
+//       if ((*dst == 's') && (dst[1] == 'r') && (dst[2] == 'c'))
+//         {
+// 	  if (dst[3] == '\0')
+// 	    {
+// 	      if (indirect)
+// 	        {
+// invalid_indmode:
+// 		  pcp_insn.error = _("Invalid indirect address mode");
+// 		  return;
+// 		}
+// 	      pcp_insn.ops[numops] = 's';
+// 	      PCPVAL (numops) = 0;
+// 	      continue;
+// 	    }
+// 	  else if ((dst[3] == ']') || (dst[4] == ']'))
+// 	    {
+// 	      if (indirect)
+// 	        goto invalid_indmode;
+// 	      else
+// 	        {
+// 		  pcp_insn.error = _("Illegal char ']' after SRC{+-}");
+// 		  return;
+// 		}
+// 	    }
+// 	  else if ((dst[3] == '+') && (dst[4] == '\0'))
+// 	    {
+// 	      if (indirect)
+// 	        goto invalid_indmode;
+
+// 	      pcp_insn.ops[numops] = 's';
+// 	      PCPVAL (numops) = 1;
+// 	      continue;
+// 	    }
+// 	  else if ((dst[3] == '-') && (dst[4] == '\0'))
+// 	    {
+// 	      if (indirect)
+// 	        goto invalid_indmode;
+
+// 	      pcp_insn.ops[numops] = 's';
+// 	      PCPVAL (numops) = 2;
+// 	      continue;
+// 	    }
+// 	}
+//       else if ((*dst == 'd') && (dst[1] == 's') && (dst[2] == 't'))
+//         {
+// 	  if (dst[3] == '\0')
+// 	    {
+// 	      if (indirect)
+// 	        goto invalid_indmode;
+
+// 	      pcp_insn.ops[numops] = 'd';
+// 	      PCPVAL (numops) = 0;
+// 	      continue;
+// 	    }
+// 	  else if ((dst[3] == ']') || (dst[4] == ']'))
+// 	    {
+// 	      if (indirect)
+// 	        goto invalid_indmode;
+// 	      else
+// 	        {
+// 		  pcp_insn.error = _("Illegal char ']' after DST{+-}");
+// 		  return;
+// 		}
+// 	    }
+// 	  else if ((dst[3] == '+') && (dst[4] == '\0'))
+// 	    {
+// 	      if (indirect)
+// 	        goto invalid_indmode;
+
+// 	      pcp_insn.ops[numops] = 'd';
+// 	      PCPVAL (numops) = 1;
+// 	      continue;
+// 	    }
+// 	  else if ((dst[3] == '-') && (dst[4] == '\0'))
+// 	    {
+// 	      if (indirect)
+// 	        goto invalid_indmode;
+
+// 	      pcp_insn.ops[numops] = 'd';
+// 	      PCPVAL (numops) = 2;
+// 	      continue;
+// 	    }
+// 	}
+
+//       /* Check if it's a condition code.  */
+//       if ((*dst == 'c') && (dst[1] == 'c') && (dst[2] == '_')
+//           && (dst[3] != '\0'))
+//         {
+// 	  if ((dst[4] == '\0') || (dst[4] == ']'))
+// 	    {
+// 	      if (dst[3] == 'z')
+// 	        {
+// 		  if (indirect || (dst[4] == ']'))
+// 		    goto invalid_indmode;
+
+// 		  pcp_insn.ops[numops] = 'a';
+// 		  PCPVAL (numops) = 1;
+// 		  continue;
+// 		}
+// 	      if (dst[3] == 'c')
+// 	        {
+// 		  if (indirect || (dst[4] == ']'))
+// 		    goto invalid_indmode;
+
+// 		  pcp_insn.ops[numops] = 'a';
+// 		  PCPVAL (numops) = 4;
+// 		  continue;
+// 		}
+// 	      if (dst[3] == 'v')
+// 	        {
+// 		  if (indirect || (dst[4] == ']'))
+// 		    goto invalid_indmode;
+
+// 		  pcp_insn.ops[numops] = 'a';
+// 		  PCPVAL (numops) = 3;
+// 		  continue;
+// 		}
+// 	      if (dst[3] == 'n')
+// 	        {
+// 		  if (indirect || (dst[4] == ']'))
+// 		    goto invalid_indmode;
+
+// 		  pcp_insn.ops[numops] = 'b';
+// 		  PCPVAL (numops) = 8;
+// 		  continue;
+// 		}
+// 	    }
+// 	  else if ((dst[5] == '\0') || (dst[5] == ']'))
+// 	    {
+// 	      if ((dst[3] == 'u') && (dst[4] == 'c'))
+// 	        {
+// 		  if (indirect || (dst[5] == ']'))
+// 		    goto invalid_indmode;
+
+// 		  pcp_insn.ops[numops] = 'a';
+// 		  PCPVAL (numops) = 0;
+// 		  continue;
+// 		}
+// 	      if (dst[3] == 'n')
+// 	        {
+// 	          if (dst[4] == 'z')
+// 		    {
+// 		      if (indirect || (dst[5] == ']'))
+// 		        goto invalid_indmode;
+
+// 		      pcp_insn.ops[numops] = 'a';
+// 		      PCPVAL (numops) = 2;
+// 		      continue;
+// 		    }
+// 	          if (dst[4] == 'c')
+// 		    {
+// 		      if (indirect || (dst[5] == ']'))
+// 		        goto invalid_indmode;
+
+// 		      pcp_insn.ops[numops] = 'b';
+// 		      PCPVAL (numops) = 11;
+// 		      continue;
+// 		    }
+// 	          if (dst[4] == 'n')
+// 		    {
+// 		      if (indirect || (dst[5] == ']'))
+// 		        goto invalid_indmode;
+
+// 		      pcp_insn.ops[numops] = 'b';
+// 		      PCPVAL (numops) = 9;
+// 		      continue;
+// 		    }
+// 	          if (dst[4] == 'v')
+// 		    {
+// 		      if (indirect || (dst[5] == ']'))
+// 		        goto invalid_indmode;
+
+// 		      pcp_insn.ops[numops] = 'b';
+// 		      PCPVAL (numops) = 10;
+// 		      continue;
+// 		    }
+// 		}
+// 	    }
+// 	  else if ((dst[6] == '\0') || (dst[6] == ']'))
+// 	    {
+// 	      if (dst[3] == 'u')
+// 	        {
+// 		  if ((dst[4] == 'l') && (dst[5] == 't'))
+// 		    {
+// 		      if (indirect || (dst[6] == ']'))
+// 		        goto invalid_indmode;
+
+// 		      pcp_insn.ops[numops] = 'a';
+// 		      PCPVAL (numops) = 4;
+// 		      continue;
+// 		    }
+// 		  if (dst[4] == 'g')
+// 		    {
+// 		      if (dst[5] == 't')
+// 		        {
+// 			  if (indirect || (dst[6] == ']'))
+// 			    goto invalid_indmode;
+
+// 			  pcp_insn.ops[numops] = 'a';
+// 			  PCPVAL (numops) = 5;
+// 			  continue;
+// 			}
+// 		      if (dst[5] == 'e')
+// 		        {
+// 			  if (indirect || (dst[6] == ']'))
+// 			    goto invalid_indmode;
+
+// 			  pcp_insn.ops[numops] = 'b';
+// 			  PCPVAL (numops) = 11;
+// 			  continue;
+// 			}
+// 		    }
+// 		}
+// 	      else if (dst[3] == 's')
+// 	        {
+// 		  if (dst[4] == 'l')
+// 		    {
+// 		      if (dst[5] == 't')
+// 		        {
+// 			  if (indirect || (dst[6] == ']'))
+// 			    goto invalid_indmode;
+
+// 			  pcp_insn.ops[numops] = 'a';
+// 			  PCPVAL (numops) = 6;
+// 			  continue;
+// 			}
+// 		      if (dst[5] == 'e')
+// 		        {
+// 			  if (indirect || (dst[6] == ']'))
+// 			    goto invalid_indmode;
+
+// 			  pcp_insn.ops[numops] = 'b';
+// 			  PCPVAL (numops) = 13;
+// 			  continue;
+// 			}
+// 		    }
+// 		  else if (dst[4] == 'g')
+// 		    {
+// 		      if (dst[5] == 't')
+// 		        {
+// 			  if (indirect || (dst[6] == ']'))
+// 			    goto invalid_indmode;
+
+// 			  pcp_insn.ops[numops] = 'a';
+// 			  PCPVAL (numops) = 7;
+// 			  continue;
+// 			}
+// 		      if (dst[5] == 'e')
+// 		        {
+// 			  if (indirect || (dst[6] == ']'))
+// 			    goto invalid_indmode;
+
+// 			  pcp_insn.ops[numops] = 'b';
+// 			  PCPVAL (numops) = 12;
+// 			  continue;
+// 			}
+// 		    }
+// 		}
+// 	      else if ((dst[3] == 'c') && (dst[4] == 'n'))
+// 	        {
+// 		  if (dst[5] == 'z')
+// 		    {
+// 		      if (indirect || (dst[6] == ']'))
+// 		        goto invalid_indmode;
+
+// 		      pcp_insn.ops[numops] = 'b';
+// 		      PCPVAL (numops) = 14;
+// 		      continue;
+// 		    }
+// 		  if (dst[5] == 'n')
+// 		    {
+// 		      if (indirect || (dst[6] == ']'))
+// 		        goto invalid_indmode;
+
+// 		      pcp_insn.ops[numops] = 'b';
+// 		      PCPVAL (numops) = 15;
+// 		      continue;
+// 		    }
+// 		}
+// 	    }
+// 	}
+
+//       /* Check if it's set or clr.  */
+//       if ((*dst == 's') && (dst[1] == 'e') && (dst[2] == 't'))
+//         {
+// 	  if (dst[3] == '\0')
+// 	    {
+// 	      if (indirect)
+// 	        goto invalid_indmode;
+
+// 	      pcp_insn.ops[numops] = 'k';
+// 	      PCPVAL (numops) = 1;
+// 	      continue;
+// 	    }
+// 	  else if (dst[3] == ']')
+// 	    {
+// 	      if (indirect)
+// 	        goto invalid_indmode;
+// 	      else
+// 	        {
+// 		  pcp_insn.error = _("Illegal char ']' after SET");
+// 		  return;
+// 		}
+// 	    }
+// 	}
+//       else if ((*dst == 'c') && (dst[1] == 'l') && (dst[2] == 'r'))
+//         {
+// 	  if (dst[3] == '\0')
+// 	    {
+// 	      if (indirect)
+// 	        goto invalid_indmode;
+
+// 	      pcp_insn.ops[numops] = 'l';
+// 	      PCPVAL (numops) = 0;
+// 	      continue;
+// 	    }
+// 	  else if (dst[3] == ']')
+// 	    {
+// 	      if (indirect)
+// 	        goto invalid_indmode;
+// 	      else
+// 	        {
+// 		  pcp_insn.error = _("Illegal char ']' after CLR");
+// 		  return;
+// 		}
+// 	    }
+// 	}
+
+//       /* Check if it's a flag=value pair.  */
+//       if ((dst[1] != '\0')
+//           && ((dst[2] == '=')
+// 	      || ((dst[2] != '\0')
+// 	          && ((dst[3] == '=')
+// 		      || ((dst[3] != '\0')
+// 		          && (dst[4] == '='))))))
+//         {
+// 	  if (dst[2] == '=')
+// 	    equ = &dst[2];
+// 	  else if (dst[3] == '=')
+// 	    equ = &dst[3];
+// 	  else
+// 	    equ = &dst[4];
+// 	  *equ = '\0';
+//           if (((pos = strstr (flags, dst)) != NULL) && (pos[-1] == ' '))
+//             {
+// 	      cp = (char *) &flops[(int) (pos - flags) - 1];
+// 	      if (*cp++ == '.')
+// 	        {
+// 	          if (indirect)
+// 	            goto invalid_indmode;
+
+// 	          pcp_insn.ops[numops] = *cp++;
+// 		  if (get_pcp_expression (str, equ + 1, numops, 0))
+// 		    continue;
+// 		  else
+// 		    return;
+// 	        }
+// 	    }
+// 	  *equ = '=';
+// 	}
+
+//       /* Check if it's a constant, a symbol or a complex expression.  */
+//       if (!get_pcp_expression (str, dst, numops, indirect))
+//         return;
+//     }
+
+//   /* This is because we started with numops = -1.  */
+//   pcp_insn.nops = ++numops;
+
+//   /* Convert "jc offset6,cc_uc" to "jl offset10".  */
+//   if (optimize_next
+//       && (numops == 2)
+//       && !strcmp (pcp_insn.code->name, "jc")
+//       && (((pcp_insn.ops[0] == 'a') && (PCPVAL (0) == 0))
+//           || ((pcp_insn.ops[1] == 'a') && (PCPVAL (1) == 0))))
+//     {
+//       if ((pcp_insn.code = (pcp_opcode_t *) str_hash_find (hash_pcp, "jl")) == NULL)
+//         {
+//           pcp_insn.error = _("Internal error: cannot lookup PCP insn \"jl\"");
+//           return;
+//         }
+//       pcp_insn.nops = 1;
+//       if (pcp_insn.ops[0] == 'a')
+//         {
+//   	  pcp_insn.ops[0] = pcp_insn.ops[1];
+// 	  pcp_insn.prefix[0] = pcp_insn.prefix[1];
+// 	  pcp_insn.opexp[0] = pcp_insn.opexp[1];
+// 	}
+
+//       if (show_internals)
+//         printf ("*** jc cc_uc,soff6 -> jl soff10 (OPT)\n");
+// #if EXT_LISTING
+//       if (listing & LISTING_LISTING)
+//         {
+//           snprintf (EXT_BUF, _("Optimizing jc cc_uc,soff6 -> jl soff10"));
+//           ASM_NOTICE ();
+//         }
+// #endif /* EXT_LISTING  */
+//     }
+// }
+
+/* Parse an expression for PCP operand OPNR starting at STR (SRC points
+   to the original input line).  If IND is non-zero, the expression must
+   be followed by "]\0", otherwise there must be no trailing chars.  If
+   no valid expression can be found, or if the numerical value of the
+   expression exceeds an operand-specific range, 0 is returned and
+   pcp_insn.error is set to an appropriate error message, otherwise 1 is
+   returned.  */
+
+// static int
+// get_pcp_expression (const char* src, char* str, int opnr, int ind)
+// {
+//   char *save_in, *save_oldpos;
+  
+//   /* Filter out prefixes.  */
+//   if (!strncmp (str, "dptr:", 5))
+//     {
+//       pcp_insn.prefix[opnr] = PCP_PREFIX_DPTR;
+//       str += 5;
+//     }
+//   else if (!strncmp (str, "doff:", 5))
+//     {
+//       pcp_insn.prefix[opnr] = PCP_PREFIX_DOFF;
+//       str += 5;
+//     }
+//   else if (!strncmp (str, "cptr:", 5))
+//     {
+//       pcp_insn.prefix[opnr] = PCP_PREFIX_CPTR;
+//       str += 5;
+//     }
+
+//   save_in = input_line_pointer;
+//   save_oldpos = input_line_pointer = (char *)src + (str - insnline);
+//   expression (&pcp_insn.opexp[opnr]);
+//   str += (input_line_pointer - save_oldpos);
+//   input_line_pointer = save_in;
+
+//   if (ind)
+//     {
+//       if (*str != ']')
+//         {
+// 	  pcp_insn.error = _("Missing ']'");
+// 	  return 0;
+// 	}
+//       if (str[1] != '\0')
+//         {
+// 	  pcp_insn.error = _("Trailing chars after indirect expression");
+// 	  return 0;
+// 	}
+//     }
+//   else if (*str != '\0')
+//     {
+//       pcp_insn.error = _("Trailing chars after expression");
+//       return 0;
+//     }
+
+//   if (pcp_insn.opexp[opnr].X_op == O_absent)
+//     {
+//       pcp_insn.error = _("Illegal expression");
+//       return 0;
+//     }
+
+//   if (pcp_insn.ops[opnr] != '\0')
+//     {
+//       offsetT val = PCPVAL (opnr);
+
+//       if (pcp_insn.opexp[opnr].X_op != O_constant)
+//         {
+// 	  pcp_insn.error = _("Non-constant expression");
+// 	  return 0;
+// 	}
+//       switch (pcp_insn.ops[opnr])
+//         {
+// 	case 'c':
+// 	  if ((val < 0) || (val > 2))
+// 	    {
+// 	      pcp_insn.error = _("CNC value out of range [0..2]");
+// 	      return 0;
+// 	    }
+// 	  break;
+
+// 	case 'f':
+// 	  if ((val != 8) && (val != 16) && (val != 32))
+// 	    {
+// 	      pcp_insn.error = _("Illegal SIZE value (must be 8, 16, or 32)");
+// 	      return 0;
+// 	    }
+// 	  else if (val == 8)
+// 	    PCPVAL (opnr) = 0;
+// 	  else if (val == 16)
+// 	    PCPVAL (opnr) = 1;
+// 	  else
+// 	    PCPVAL (opnr) = 2;
+// 	  break;
+
+// 	case 'g':
+// 	  if ((val != 0) && (val != 1))
+// 	    {
+// 	      pcp_insn.error = _("Illegal ST value (must be 0 or 1)");
+// 	      return 0;
+// 	    }
+// 	  break;
+
+// 	case 'h':
+// 	  if ((val != 0) && (val != 1))
+// 	    {
+// 	      pcp_insn.error = _("Illegal EC value (must be 0 or 1)");
+// 	      return 0;
+// 	    }
+// 	  break;
+
+// 	case 'i':
+// 	  if ((val != 0) && (val != 1))
+// 	    {
+// 	      pcp_insn.error = _("Illegal INT value (must be 0 or 1)");
+// 	      return 0;
+// 	    }
+// 	  break;
+
+// 	case 'j':
+// 	  if ((val != 0) && (val != 1))
+// 	    {
+// 	      pcp_insn.error = _("Illegal EP value (must be 0 or 1)");
+// 	      return 0;
+// 	    }
+// 	  break;
+
+// 	case 'm':
+// 	  if ((val != 0) && (val != 1))
+// 	    {
+// 	      pcp_insn.error = _("Illegal DAC value (must be 0 or 1)");
+// 	      return 0;
+// 	    }
+// 	  break;
+
+// 	case 'n':
+// 	  if (!strcmp (pcp_insn.code->name, "copy"))
+// 	    {
+// 	      if ((val < 1) || (val > 8))
+// 	        {
+// 	          pcp_insn.error = _("CNT0 value out of range [1..8] for COPY");
+// 	          return 0;
+// 		}
+// 	      else
+// 	        PCPVAL (opnr) = val & 0x7;
+// 	    }
+// 	  else if (!strcmp (pcp_insn.code->name, "bcopy"))
+// 	    {
+// 	      if ((val != 2) && (val != 4) && (val != 8))
+// 	        {
+// 		  pcp_insn.error = _("Illegal CNT0 value (must be 2, 4, or 8)");
+// 		  return 0;
+// 		}
+// 	      else if (val == 4)
+// 	        PCPVAL (opnr) = 3;
+// 	      else if (val == 8)
+// 	        PCPVAL (opnr) = 0;
+// 	    }
+// 	  else
+// 	    {
+// 	      pcp_insn.error = _("CNT0 only valid for [B]COPY instructions");
+// 	      return 0;
+// 	    }
+// 	  break;
+
+// 	case 'o':
+// 	  if ((val != 0) && (val != 1))
+// 	    {
+// 	      pcp_insn.error = _("Illegal RTA value (must be 0 or 1)");
+// 	      return 0;
+// 	    }
+// 	  break;
+
+// 	case 'p':
+// 	  if ((val != 0) && (val != 1))
+// 	    {
+// 	      pcp_insn.error = _("Illegal EDA value (must be 0 or 1)");
+// 	      return 0;
+// 	    }
+// 	  break;
+
+// 	case 'q':
+// 	  if ((val != 0) && (val != 1))
+// 	    {
+// 	      pcp_insn.error = _("Illegal SDB value (must be 0 or 1)");
+// 	      return 0;
+// 	    }
+// 	  break;
+// 	}
+//     }
+//   else
+//     {
+//       if (pcp_insn.opexp[opnr].X_op == O_constant)
+// 	pcp_insn.ops[opnr] = ind ? 'E' : 'e';
+//       else
+//         pcp_insn.ops[opnr] = ind ? 'U' : 'u';
+//     }
+
+//   return 1;
+// }
+
+/* Find an opcode that matches pcp_insn's opcode/operands.  */
+
+// static pcp_opcode_t *
+// find_pcp_opcode ()
+// {
+//   pcp_opcode_t *pop;
+//   int i, op, nops;
+//   char ops[MAX_PCPOPS + 1], *pos;
+
+//   pop = pcp_insn.code;
+//   nops = pcp_insn.nops;
+
+//   for (i = pcp_insn.code->insind; i <= pcp_insn.code->inslast; ++pop, ++i)
+//     {
+//       if (pop->nr_operands != nops)
+//         continue;
+
+//       if (pop->ooo)
+//         {
+// 	  for (op = 0; op < nops; ++op)
+// 	    ops[op] = pcp_insn.ops[op];
+// 	  ops[nops] = '\0';
+
+//           for (op = 0; op < nops; ++op)
+// 	    if (((pos = strchr (ops, pop->args[op])) == NULL)
+// 	        && !((pop->args[op] == 'e') && (pos = strchr (ops, 'u')))
+// 		&& !((pop->args[op] == 'E') && (pos = strchr (ops, 'U'))))
+// 	      break;
+// 	    else
+// 	      strcpy (pos, pos + 1);
+// 	}
+//       else
+//         {
+// 	  for (op = 0; op < nops; ++op)
+// 	    if ((pcp_insn.ops[op] != pop->args[op])
+// 	        && !((pop->args[op] == 'e') && (pcp_insn.ops[op] == 'u'))
+// 		&& !((pop->args[op] == 'E') && (pcp_insn.ops[op] == 'U')))
+// 	      break;
+// 	}
+
+//       if (op == nops)
+//         return pop;
+//     }
+
+//   /* We couldn't find a valid opcode.  */
+//   return (pcp_opcode_t *) NULL;
+// }
+
+/* Print the contents of pcp_insn.  Used for debugging.  */
+
+// static void
+// print_pcp_insn ()
+// {
+//   int i;
+
+//   printf ("<%s \"%s\"> ", pcp_insn.code->name, pcp_insn.code->args);
+//   if (pcp_insn.code->len32)
+//     printf ("0x%08lx ", pcp_insn.opcode);
+//   else
+//     printf ("0x%04lx ", pcp_insn.opcode);
+
+//   for (i = 0; i < pcp_insn.nops; ++i)
+//     {
+//       switch (pcp_insn.prefix[i])
+//         {
+// 	case PCP_PREFIX_NONE:
+// 	  break;
+
+// 	case PCP_PREFIX_DPTR:
+// 	  printf ("dptr:");
+// 	  break;
+
+// 	case PCP_PREFIX_DOFF:
+// 	  printf ("doff:");
+// 	  break;
+
+// 	case PCP_PREFIX_CPTR:
+// 	  printf ("cptr:");
+// 	  break;
+// 	}
+
+//       switch (pcp_insn.ops[i])
+//         {
+// 	case 'a':
+// 	  printf ("CONDCA (%ld, cc_%s)", PCPVAL (i), pcp_ccodes[PCPVAL (i)]);
+// 	  break;
+
+// 	case 'b':
+// 	  printf ("CONDCB (%ld, cc_%s)", PCPVAL (i), pcp_ccodes[PCPVAL (i)]);
+// 	  break;
+
+// 	case 'c':
+// 	  printf ("CNC=(%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'd':
+// 	  printf ("DST");
+// 	  if (PCPVAL (i) == 1)
+// 	    printf ("+");
+// 	  else if (PCPVAL (i) == 2)
+// 	    printf ("-");
+// 	  break;
+
+// 	case 'e':
+// 	  printf ("EXPR (%ld,0x%08lx)", PCPVAL (i), PCPVAL (i));
+// 	  break;
+
+// 	case 'E':
+// 	  printf ("[EXPR] (%ld,0x%08lx)", PCPVAL (i), PCPVAL (i));
+// 	  break;
+
+// 	case 'f':
+// 	  printf ("SIZE=(%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'g':
+// 	  printf ("ST=(%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'h':
+// 	  printf ("EC=(%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'i':
+// 	  printf ("INT=(%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'j':
+// 	  printf ("EP=(%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'k':
+// 	  printf ("SET (%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'l':
+// 	  printf ("CLR (%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'm':
+// 	  printf ("DAC=(%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'n':
+// 	  printf ("CNT0=(%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'o':
+// 	  printf ("RTA=(%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'p':
+// 	  printf ("EDA=(%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'q':
+// 	  printf ("SDB=(%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'r':
+// 	  printf ("REG (%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 'R':
+// 	  printf ("[REG] (%ld)", PCPVAL (i));
+// 	  break;
+
+// 	case 's':
+// 	  printf ("SRC");
+// 	  if (PCPVAL (i) == 1)
+// 	    printf ("+");
+// 	  else if (PCPVAL (i) == 2)
+// 	    printf ("-");
+// 	  break;
+
+// 	case 'u':
+// 	  printf ("UNDF (%s)", S_GET_NAME (pcp_insn.opexp[i].X_add_symbol));
+// 	  break;
+
+// 	case 'U':
+// 	  printf ("[UNDF] (%s)", S_GET_NAME (pcp_insn.opexp[i].X_add_symbol));
+// 	  break;
+// 	}
+      
+//       printf ("(%c)", pcp_insn.ops[i]);
+//       if (!strcmp (pcp_insn.code->name, "jl")
+//           || !strcmp (pcp_insn.code->name, "jc"))
+//         printf ("(PCREL)");
+//       if (i < (pcp_insn.nops - 1))
+//         printf (", ");
+//     }
+//   printf ("\n");
+// }
+
+/* Encode the PCP instruction contained in pcp_insn.  Return 1 on
+   error, or 0 on OK.  */
+
+// static int
+// pcp_encode ()
+// {
+//   int op;
+//   pcp_opcode_t *pop = pcp_insn.code;
+//   unsigned long *code = &pcp_insn.opcode;
+
+//   switch (pop->fmt_group)
+//     {
+//     case 0:
+//       for (op = 0; op < pcp_insn.nops; ++op)
+//         switch (pcp_insn.ops[op])
+// 	  {
+// 	  case 'd': /* DST{+-}  */
+// 	    *code |= (PCPVAL (op) << 9);
+// 	    break;
+
+// 	  case 's': /* SRC{+-}  */
+// 	    *code |= (PCPVAL (op) << 7);
+// 	    break;
+
+// 	  case 'c': /* CNC=  */
+// 	    *code |= (PCPVAL (op) << 5);
+// 	    break;
+
+// 	  case 'n': /* CNT0=  */
+// 	    *code |= (PCPVAL (op) << 2);
+// 	    break;
+
+// 	  case 'f': /* SIZE=  */
+// 	  case 'a': /* CONDCA  */
+// 	  case 'b': /* CONDCB  */
+// 	    *code |= PCPVAL (op);
+// 	    break;
+
+// 	  case 'g': /* ST=  */
+// 	    *code |= (PCPVAL (op) << 10);
+// 	    break;
+
+// 	  case 'i': /* INT=  */
+// 	    *code |= (PCPVAL (op) << 9);
+// 	    break;
+
+// 	  case 'j': /* EP=  */
+// 	    *code |= (PCPVAL (op) << 8);
+// 	    break;
+
+// 	  case 'h': /* EC=  */
+// 	    *code |= (PCPVAL (op) << 7);
+// 	    break;
+
+// 	  default:
+// 	    as_fatal (_("Internal error: operand #%d is unknown"), op);
+// 	    return 1;
+// 	  }
+//       break;
+
+//     case 1:
+//       *code |= ((PCPVAL (0) << 6) | (PCPVAL (1) << 3) | PCPVAL (2));
+//       break;
+
+//     case 2:
+//       if ((PCPVAL (0) == 7)
+//           && (!strcmp (pop->name, "mclr.pi") || !strcmp (pop->name, "mset.pi")))
+//         {
+// 	  as_bad (_("Register R7 not allowed for this instruction"));
+// 	  return 1;
+// 	}
+//       if ((pcp_insn.ops[1] == 'u') || (pcp_insn.ops[1] == 'U'))
+//         {
+// 	  /* This is catched elsewhere (in pcp_emit_code), as we now permit
+// 	     undefined operands for these insns and emit relocs for them.
+
+// 	  as_bad (_("Unknown offset; must be a constant between 0 and 63"));
+// 	  return 1;  */
+// 	}
+//       else if ((PCPVAL (1) < 0) || (PCPVAL (1) > 63))
+//         {
+// 	  as_bad (_("Offset %ld out of range [0..63]"), PCPVAL (1));
+// 	  return 1;
+// 	}
+//       *code |= ((PCPVAL (0) << 6) | PCPVAL (1));
+//       break;
+
+//     case 3:
+//       if (pcp_insn.ops[0] == 'r')
+//         *code |= ((PCPVAL (0) << 6) | (PCPVAL (1) << 3) | PCPVAL (2));
+//       else
+//         *code |= ((PCPVAL (1) << 6) | (PCPVAL (2) << 3) | PCPVAL (0));
+//       break;
+
+//     case 4:
+//       for (op = 0; op < pcp_insn.nops; ++op)
+//         switch (pcp_insn.ops[op])
+// 	  {
+// 	  case 'r': /* R0-R7  */
+// 	    *code |= (PCPVAL (op) << 6);
+// 	    break;
+
+// 	  case 'k': /* SET  */
+// 	  case 'l': /* CLR  */
+// 	    *code |= (PCPVAL (op) << 5);
+// 	    break;
+
+// 	  case 'e': /* const expr  */
+// 	    if (!strcmp (pop->name, "ldl.iu") || !strcmp (pop->name, "ldl.il"))
+// 	      break;  /* These are handled in pcp_emit code.  */
+// 	    if (!strcmp (pop->name, "shr")
+// 	        || !strcmp (pop->name, "shl")
+// 		|| !strcmp (pop->name, "rr")
+// 		|| !strcmp (pop->name, "rl"))
+// 	      {
+// 	        if ((PCPVAL (op) != 1) && (PCPVAL (op) != 2)
+// 		    && (PCPVAL (op) != 4) && (PCPVAL (op) != 8))
+// 		  {
+// 		    as_bad (_("Illegal constant %ld; must be 1, 2, 4, or 8"),
+// 		            PCPVAL (op));
+// 		    return 1;
+// 		  }
+// 	      }
+// 	    else if (!strcmp (pop->name, "set")
+// 	    	     || !strcmp (pop->name, "clr")
+// 		     || !strcmp (pop->name, "inb.i")
+// 		     || !strcmp (pop->name, "chkb")
+// 		     || !strcmp (pop->name, "exb")
+// 		     || !strcmp (pop->name, "exib"))
+// 	      {
+// 	        if ((PCPVAL (op) < 0) || (PCPVAL (op) > 31))
+// 		  {
+// 		    as_bad (_("Constant %ld out of range [0..31]"),
+// 		    	    PCPVAL (op));
+// 		    return 1;
+// 		  }
+// 	      }
+// 	    else if ((PCPVAL (op) < 0) || (PCPVAL (op) > 63))
+// 	      {
+// 	        as_bad (_("Constant %ld out of range [0..63]"), PCPVAL (op));
+// 		return 1;
+//               }
+// 	    *code |= PCPVAL (op);
+// 	    break;
+
+// 	  case 'u': /* unknown  */
+// 	    if (strcmp (pop->name, "ldl.iu") && strcmp (pop->name, "ldl.il"))
+// 	      {
+// 	        as_bad (_("Invalid expression; must be a constant"));
+// 		return 1;
+// 	      }
+// 	    break;
+
+// 	  default:
+// 	    as_fatal (_("Internal error: operand #%d is unknown"), op);
+// 	    return 1;
+// 	  }
+//       break;
+
+//     case 5:
+//       if (pcp_insn.ops[1] == 'u')
+//         {
+// 	  as_bad (_("Invalid expression; must be a constant"));
+// 	  return 1;
+// 	}
+//       if (!strcmp (pop->name, "set.f") || !strcmp (pop->name, "clr.f"))
+//         {
+// 	  if ((PCPVAL (1) < 0) || (PCPVAL (1) >= (8 << PCPVAL (2))))
+// 	    {
+// 	      as_bad (_("Constant %ld out of range [0..%d]"), PCPVAL (1),
+// 	      	      (8 << PCPVAL (2)) - 1);
+// 	      return 1;
+// 	    }
+// 	}
+//       else if ((PCPVAL (1) < 0) || (PCPVAL (1) > 31))
+//         {
+// 	  as_bad (_("Constant %ld out of range [0..31]"), PCPVAL (1));
+// 	  return 1;
+// 	}
+//       *code |= (PCPVAL (0) << 6);
+//       *code |= PCPVAL (1);
+//       *code |= (((PCPVAL (2) & 1) << 5) | ((PCPVAL (2) & 2) << 8));
+//       break;
+
+//     case 6:
+//       if ((PCPVAL (0) == 0) || (PCPVAL (0) == 7))
+//         {
+// 	  as_bad (_("R%ld must not be used as destination register"),
+// 	  	  PCPVAL (0));
+// 	  return 1;
+// 	}
+//       else if ((PCPVAL (1) == 0) || (PCPVAL (1) == 7))
+//         {
+// 	  as_bad (_("R%ld must not be used as source register"), PCPVAL (1));
+// 	  return 1;
+// 	}
+//       else if (PCPVAL (0) == PCPVAL (1))
+//         {
+// 	  as_bad (_("Source and destination registers must not be the same"));
+// 	  return 1;
+// 	}
+//       *code |= ((PCPVAL (0) << 6) | (PCPVAL (1) << 3));
+//       break;
+
+//     case 7:
+//       for (op = 0; op < pcp_insn.nops; ++op)
+//         switch (pcp_insn.ops[op])
+// 	  {
+// 	  case 'r': /* R0-R7  */
+// 	  case 'R': /* [R0]-[R7]  */
+// 	  case 'm': /* DAC=  */
+// 	    *code |= (PCPVAL (op) << 3);
+// 	    break;
+
+// 	  case 'a': /* CONDCA  */
+// 	  case 'b': /* CONDCB  */
+// 	    *code |= (PCPVAL (op) << 6);
+// 	    break;
+
+// 	  case 'o': /* RTA/RNA=  */
+// 	    *code |= (PCPVAL (op) << 2);
+// 	    break;
+
+// 	  case 'p': /* EDA=  */
+// 	    *code |= (PCPVAL (op) << 1);
+// 	    break;
+
+// 	  case 'q': /* SDB=  */
+// 	    *code |= PCPVAL (op);
+// 	    break;
+
+// 	  case 'e': /* expr  */
+// 	    if (!strcmp (pop->name, "jl"))
+// 	      {
+// 	        if ((PCPVAL (op) < -512) || (PCPVAL (op) > 511))
+// 		  {
+// 		    as_bad (_("Offset %ld out of range [-512..511]"),
+// 		    	    PCPVAL (op));
+// 		    return 1;
+// 		  }
+// 		*code |= (PCPVAL (op) & 0x3ff);
+// 	      }
+// 	    else if (!strcmp (pop->name, "jc"))
+// 	      {
+// 	        if ((PCPVAL (op) < -32) || (PCPVAL (op) > 31))
+// 		  {
+// 		    as_bad (_("Offset %ld out of range [-32..31]"),
+// 		    	    PCPVAL (op));
+// 		    return 1;
+// 		  }
+// 		*code |= (PCPVAL (op) & 0x3f);
+// 	      }
+// 	    else if (!strcmp (pop->name, "jc.a"))
+// 	      {
+// 	        if (PCPVAL (op) & ~0xffff)
+// 		  {
+// 		    as_bad (_("PCODE address 0x%08lx out of range [0..65535]"),
+// 		    	    PCPVAL (op));
+// 		    return 1;
+// 		  }
+// 		/* Note: the code will be set in pcp_emit_code.  */
+// 	      }
+// 	    else
+// 	      {
+// 	        as_fatal (_("Unknown instruction \"%s\""), pop->name);
+// 		return 1;
+// 	      }
+// 	    break;
+
+// 	  case 'u': /* unknown  */
+// 	    break;
+
+// 	  default:
+// 	    as_fatal (_("Operand #%d is unknown"), op);
+// 	    return 1;
+// 	  }
+//       break;
+
+//     default:
+//       as_fatal (_("Illegal instruction format group %d"), pop->fmt_group);
+//       return 1;
+//     }
+
+//   return 0;
+// }
+
+/* If a PCP insn could be successfully parsed and encoded, this function
+   will take care of writing out the opcode bytes and relocation info, if
+   needed.  */
+
+// static void
+// pcp_emit_code ()
+// {
+//   int opnum = -1, oplen = pcp_insn.code->len32 ? 4 : 2;
+//   char *pfrag;
+//   unsigned long code = pcp_insn.opcode;
+//   enum bfd_reloc_code_real reloc = NO_RELOC;
+//   relax_substateT state = RELAX_JC;
+//   int add_bytes;
+
+//   /* Make sure the current frag is large enough to hold a 32-bit insn.  */
+//   frag_grow (4);
+//   pfrag = frag_more (2);
+
+//   /* Emit the 16-bit base code.  */
+//   md_number_to_chars (pfrag, code, 2);
+
+//   /* Emit DWARF2 line debug info (if requested).  */
+//   dwarf2_emit_insn (2);
+
+//   /* Handle class 2 instructions (*.pi) with undefined operand.  */
+//   if ((pcp_insn.code->fmt_group == 2)
+//       && ((pcp_insn.ops[1] == 'u') || (pcp_insn.ops[1] == 'U')))
+//     {
+//       if ((pcp_insn.prefix[1] == PCP_PREFIX_NONE)
+//           || (pcp_insn.prefix[1] == PCP_PREFIX_DOFF))
+// 	{
+// 	  fix_new_exp (frag_now, (pfrag - frag_now->fr_literal), 0,
+// 	  	       &pcp_insn.opexp[1], 0, BFD_RELOC_TRICORE_PCPOFF);
+// 	  if (show_internals)
+// 	    printf ("*** fix_new_exp (1, BFD_RELOC_TRICORE_PCPOFF)\n");
+// 	}
+//       else
+// 	as_bad (_("Invalid prefix for operand #1"));
+
+//       return;
+//     }
+
+//   /* Handle 32-bit instructions.  */
+//   if (oplen == 4)
+//     {
+//       int is_lower = !strcmp (pcp_insn.code->name, "ldl.il");
+
+//       pfrag = frag_more (2);
+//       code <<= 16;
+//       if (is_lower || !strcmp (pcp_insn.code->name, "ldl.iu"))
+//         {
+// 	  if (pcp_insn.ops[1] == 'e')
+// 	    {
+// 	      if (pcp_insn.prefix[1] == PCP_PREFIX_NONE)
+// 	        {
+// 		  if (is_lower)
+// 	            code |= (PCPVAL (1) & 0xffff);
+// 		  else
+// 	            code |= ((PCPVAL (1) >> 16) & 0xffff);
+// 		}    
+// 	      else if (pcp_insn.prefix[1] == PCP_PREFIX_DPTR)
+// 		{
+// 		  if (PCPVAL (1) & 0x3)
+// 		    {
+// 		      as_bad (_("PRAM address 0x%08lx is not word-aligned"),
+// 		      	      PCPVAL (1));
+// 		      return;
+// 		    }  
+// 		  else if (PCPVAL (1) & 0xff)
+// 		    as_warn (_("PRAM address 0x%08lx should be "
+// 		    	       "aligned to a 256-byte boundary"),
+// 			     PCPVAL (1));
+// 	          code |= (PCPVAL (1) & 0xff00);
+// 	        }
+// 	      else if (pcp_insn.prefix[1] == PCP_PREFIX_DOFF)
+// 	        {
+// 		  if (PCPVAL (1) & 0x3)
+// 		    {
+// 		      as_bad (_("PRAM address 0x%08lx is not word-aligned"),
+// 		      	      PCPVAL (1));
+// 		      return;
+// 		    }
+// 		  code |= ((PCPVAL (1) >> 2) & 0x3f);
+// 		}
+// 	      else if (pcp_insn.prefix[1] == PCP_PREFIX_CPTR)
+// 	        {
+// 	          if (PCPVAL (1) & ~0xffff)
+// 		    {
+// 		      as_bad (_("PCODE address 0x%08lx out "
+// 		      		"of range [0..65535]"),
+// 		    	      PCPVAL (1));
+// 		      return;
+// 		    }
+// 		  code |= (PCPVAL (1) & 0xffff);  
+// 		}
+// 	    }
+// 	  else
+// 	    {
+// 	      opnum = 1;
+// 	      if (pcp_insn.prefix[1] == PCP_PREFIX_NONE)
+// 		{
+// 		  if (is_lower)
+// 	            reloc = BFD_RELOC_TRICORE_PCPLO;
+// 		  else  
+// 	            reloc = BFD_RELOC_TRICORE_PCPHI;
+// 		}    
+// 	      else if (pcp_insn.prefix[1] == PCP_PREFIX_DPTR)
+// 	        reloc = BFD_RELOC_TRICORE_PCPPAGE;
+// 	      else if (pcp_insn.prefix[1] == PCP_PREFIX_DOFF)
+// 	        reloc = BFD_RELOC_TRICORE_PCPOFF;
+// 	      else if (pcp_insn.prefix[1] == PCP_PREFIX_CPTR)
+// 	        reloc = BFD_RELOC_TRICORE_PCPTEXT;
+// 	      else
+// 	        {
+// ill_pfx_error:
+// 		  as_bad (_("Illegal operand prefix"));
+// 		  return;
+// 		}  
+// 	    }
+// 	}
+//       else if (!strcmp (pcp_insn.code->name, "jc.a"))
+//         {
+// 	  if (pcp_insn.ops[0] == 'e')
+// 	    {
+// 	      if ((pcp_insn.prefix[0] != PCP_PREFIX_NONE)
+// 	          && (pcp_insn.prefix[0] != PCP_PREFIX_CPTR))
+// 		goto ill_pfx_error;
+
+// 	      /* If the target address has been specified as an absolute
+// 	         expression (e.g., "0x1234"), we must assume the address
+// 		 to already be in PCP-format, so we must not translate
+// 		 it into TriCore-format (i.e., into a byte address).  */
+// 	      code |= (PCPVAL (0) & 0xffff);
+// 	    }  
+// 	  else if (pcp_insn.ops[1] == 'e')
+// 	    {  
+// 	      if ((pcp_insn.prefix[1] != PCP_PREFIX_NONE)
+// 	          && (pcp_insn.prefix[1] != PCP_PREFIX_CPTR))
+// 		goto ill_pfx_error;
+
+// 	      /* If the target address has been specified as an absolute
+// 	         expression (e.g., "0x1234"), we must assume the address
+// 		 to already be in PCP-format, so we must not translate
+// 		 it into TriCore-format (i.e., into a byte address).  */
+// 	      code |= (PCPVAL (1) & 0xffff);
+// 	    }  
+// 	  else
+// 	    {
+// 	      opnum = (pcp_insn.ops[0] == 'u') ? 0 : 1;
+// 	      if ((pcp_insn.prefix[opnum] != PCP_PREFIX_NONE)
+// 	          && (pcp_insn.prefix[opnum] != PCP_PREFIX_CPTR))
+// 		goto ill_pfx_error;
+
+// 	      reloc = BFD_RELOC_TRICORE_PCPTEXT;
+// 	    }
+// 	}
+//       else
+//         {
+// 	  as_fatal (_("Internal error: unknown 32-bit PCP instruction \"%s\""),
+// 	  	    pcp_insn.code->name);
+// 	  return;
+// 	}
+
+//       /* Emit the additional code.  */
+//       md_number_to_chars (pfrag, code & 0xffff, 2);
+
+//       /* Handle relocations.  */
+//       if (reloc != NO_RELOC)
+//         {
+// 	  fix_new_exp (frag_now, (pfrag - frag_now->fr_literal), 0,
+// 	  	       &pcp_insn.opexp[opnum], 0, reloc);
+// 	  if (show_internals)
+// 	    printf ("*** fix_new_exp (%d, %s)\n", opnum,
+// 	    	    GET_RELOC_NAME (reloc));
+// 	}
+
+//       pcp_insn.opcode = code;
+//       return;
+//     }
+
+//   /* Handle PC-relative relocations for jl and jc.  */
+//   if (!strcmp (pcp_insn.code->name, "jl"))
+//     {
+//       if (pcp_insn.ops[0] == 'u')
+//         {
+// 	  opnum = 0;
+//           reloc = BFD_RELOC_TRICORE_PCPREL10;
+// 	  state = RELAX_JL;
+// 	}
+//     }
+//   else if (!strcmp (pcp_insn.code->name, "jc"))
+//     {
+//       if (pcp_insn.ops[0] == 'u')
+//         opnum = 0;
+//       else if (pcp_insn.ops[1] == 'u')
+//         opnum = 1;
+//       if (opnum != -1)
+//         {
+// 	  reloc = BFD_RELOC_TRICORE_PCPREL6;
+// 	  state = RELAX_JC;
+// 	}
+//     }
+//   if (reloc != NO_RELOC)
+//     {
+//       /* Prepare relaxing.  */
+//       add_bytes = md_relax_table[state + 1].rlx_length;
+//       (void) frag_var (rs_machine_dependent, add_bytes, add_bytes, state,
+//       		       pcp_insn.opexp[opnum].X_add_symbol,
+// 		       pcp_insn.opexp[opnum].X_add_number, pfrag);
+//       if (show_internals)
+//         printf ("*** frag_var (%d, add_bytes=%d)\n", opnum, add_bytes);
+//     }
+//   pcp_insn.opcode = code;
+// }
+
+/* Assemble the PCP instruction starting at STR.  */
+
+// static void
+// pcp_assemble (const char* str)
+// {
+//   pcp_opcode_t *insn;
+
+//   if (show_internals)
+//     printf ("*** pcp_assemble (\"%s\")\n", str);
+
+//   /* Find out the insn's name and operands.  */
+//   memset ((char *) &pcp_insn, 0, sizeof (pcp_insn));
+//   pcp_ip (str);
+//   if (pcp_insn.error)
+//     {
+//       as_bad ("%s: %s", str, pcp_insn.error);
+//       return;
+//     }
+
+//   /* Find an opcode that matches pcp_insn.  */
+//   if ((insn = find_pcp_opcode ()) == NULL)
+//     {
+//       if (show_internals)
+//         print_pcp_insn ();
+//       as_bad (_("Opcode/operand mismatch: %s"), str);
+//       return;
+//     }
+//   pcp_insn.code = insn;
+//   pcp_insn.opcode = insn->opcode;
+
+//   /* Encode pcp_insn.  */
+//   if (pcp_encode ())
+//     {
+//       if (show_internals)
+//         print_pcp_insn ();
+//       return;
+//     }
+
+//   /* Emit its opcode and fixup/relaxation infos.  */
+//   pcp_emit_code ();
+
+//   if (show_internals)
+//     print_pcp_insn ();
+// }
+
+/* Assemble the TriCore instruction starting at STR.  */
+
+void
+md_assemble (char* str)
+{
+  opcode_t *insn;
+  int i;
+
+  assert (str);
+
+//   Until now, PCP_seg isn't used so this part is useless
+//   if (now_seg->flags & PCP_SEG)
+//     {
+//       pcp_assemble (str);
+//       optimize_next = optimize;
+//       return;
+//     }
+
+  if (show_internals)
+    printf ("*** md_assemble (\"%s\")\n", str);
+
+  /* Find out the insn's name and operands.  */
+  memset ((char *) &the_insn, 0, sizeof (the_insn));
+  tricore_ip (str);
+  if (the_insn.error)
+    {
+      as_bad ("%s: %s", str, the_insn.error);
+      goto ich_habe_fertig;
+    }
+
+  /* Find an opcode that matches the_insn.  */
+  if ((insn = find_opcode ()) == NULL)
+    {
+      if (show_internals)
+        print_the_insn ();
+      as_bad (_("Opcode/operand mismatch: %s"), str);
+      goto ich_habe_fertig;
+    }
+  the_insn.code = insn;
+  the_insn.opcode = insn->opcode;
+
+  /* Mark and check PC-relative operands.  */
+  for (i = 0; i < insn->nr_operands; ++i)
+    if (strchr ("mxrRoO", insn->args[i]))
+      {
+        the_insn.pcrel[i] = 1;
+	if (the_insn.is_odd[i])
+	  {
+	    if (show_internals)
+	      print_the_insn ();
+	    as_bad (_("Displacement 0x%08lx is not even"), VAL (i));
+	    goto ich_habe_fertig;
+	  }
+      }
+
+  /* Encode the_insn.  */
+  encode[insn->format] ();
+
+  /* Emit its opcode and fixup/relaxation infos.  */
+  emit_code ();
+
+  if (show_internals)
+    print_the_insn ();
+
+ich_habe_fertig:
+  /* Perform more workarounds, if requested and applicable.  */
+  if (workaround_cpu9 && !the_insn.error
+      && !strcmp (the_insn.code->name, "dsync"))
+    {
+      int tmp_use_insn32 = use_insn32;
+      int tmp_use_insn16 = use_insn16;
+      int tmp_optimize_next = optimize_next;
+      int tmp_show_internals = show_internals;
+
+      if (show_internals)
+        printf ("*** Inserting 2 NOPs (workaround for CPU.9 bug).\n");
+#if EXT_LISTING
+      ASM_NOTICE_WORKAROUND (_("inserting 2 NOPs as a workaround "
+		      	       "for bug CPU.9"));
+#endif
+
+      show_internals = 0;
+      md_assemble ((char*)"nop");
+
+      /* Restore desired insn size and optimization settings before
+         assembling the next "nop", as they might have been changed
+	 by md_assemble.  */
+      use_insn32 = tmp_use_insn32;
+      use_insn16 = tmp_use_insn16;
+      optimize_next = tmp_optimize_next;
+      md_assemble ((char*)"nop");
+      show_internals = tmp_show_internals;
+    }
+  else if (workaround_cpu34 && !the_insn.error
+	   && !strcmp (the_insn.code->name, "dsync"))
+    {
+      int tmp_show_internals = show_internals;
+
+      if (show_internals)
+        printf ("*** Inserting ISYNC (workaround for CPU_TC.034 bug).\n");
+#if EXT_LISTING
+      ASM_NOTICE_WORKAROUND (_("inserting ISYNC as a workaround "
+		      	       "for bug CPU_TC.034"));
+#endif
+
+      show_internals = 0;
+      md_assemble ((char*)"isync");
+      show_internals = tmp_show_internals;
+    }
+  else if (workaround_cpu69 && !the_insn.error
+	   && !strcmp (the_insn.code->name, "rslcx"))
+    {
+      int tmp_show_internals = show_internals;
+
+      if (show_internals)
+	printf ("*** Inserting NOP (workaround for CPU_TC.069 bug).\n");
+#if EXT_LISTING
+      ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround "
+		     	       "for bug CPU_TC.069"));
+#endif
+
+      show_internals = 0;
+      md_assemble ((char*)"nop");
+      show_internals = tmp_show_internals;
+    }
+  else if (workaround_cpu81 && !the_insn.error
+	   && (the_insn.regs[0] == 10)
+  	   && (!strcmp (the_insn.code->name, "ld.a")
+	       || !strcmp (the_insn.code->name, "ld.da")))
+    {
+      if (show_internals)
+        printf ("*** Issuing error message (workaround for CPU_TC.081 bug).\n");
+#if EXT_LISTING
+      ASM_NOTICE_WORKAROUND (_("Issuing an error message as a workaround "
+		     	       "for bug CPU_TC.081"));
+#endif
+      as_bad (_("%%A10 must not be loaded from memory due to bug CPU_TC.081"));
+    }
+  else if (workaround_cpu83 && !the_insn.error
+  	   && (the_insn.code->nr_operands == 0)
+	   && !strcmp (the_insn.code->name, "disable"))
+    {
+      int tmp_show_internals = show_internals;
+
+      if (show_internals)
+	printf ("*** Inserting NOP (workaround for CPU_TC.083 bug).\n");
+#if EXT_LISTING
+      ASM_NOTICE_WORKAROUND (_("inserting NOP as a workaround "
+		     	       "for bug CPU_TC.083"));
+#endif
+
+      show_internals = 0;
+      md_assemble ((char*)"nop");
+      show_internals = tmp_show_internals;
+    }
+
+  /* Reset the .code16/32, .optim and .noopt selectors.  */
+  use_insn32 = 0;
+  use_insn16 = 0;
+  optimize_next = optimize;
+}
+
+/* End of tc-tricore.c.  */
+
+/* Next week: Assemble code for Deep Thought II.  Stay tuned!  */
diff --git a/gas/config/tc-tricore.h b/gas/config/tc-tricore.h
new file mode 100644
index 00000000000..bdc38627c41
--- /dev/null
+++ b/gas/config/tc-tricore.h
@@ -0,0 +1,151 @@
+/* tc-tricore.h -- Header file for tc-tricore.c
+   Copyright (C) 1998-2005 Free Software Foundation, Inc.
+   Contributed by Michael Schumacher (mike@hightec-rt.com).
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* Define target architecture.  */
+#define TC_TRICORE
+
+#define TARGET_BYTES_BIG_ENDIAN 0
+#define TARGET_ARCH bfd_arch_tricore
+#define TARGET_FORMAT "elf32-tricore"
+#define LISTING_HEADER "Infineon TriCore Little Endian"
+
+/* Work around a bug in read.c where it uses "#ifdef LISTING" instead
+   of "#ifndef NO_LISTING".  */
+#define LISTING !NO_LISTING
+
+/* Don't try to break words.  */
+#define WORKING_DOT_WORD
+
+/* Turn "sym - ." expressions into PC-relative relocs.  */
+#define DIFF_EXPR_OK
+
+/* TriCore/PCP operands may have prefixes, but that's dealt with before
+   expression() is called, and aside from prefixes, there's no need to
+   treat operand expressions specially.  */
+#define md_operand(x)
+
+/* TriCore/PCP is little endian.  */
+#define md_number_to_chars number_to_chars_littleendian
+
+/* .short/.word may or may not be auto-aligned.  */
+#define md_cons_align(nbytes) tricore_cons_align (nbytes)
+extern void tricore_cons_align (int);
+
+/* Handle PCP section flag and PCP section alignment.  */
+#define md_elf_section_flags(f,a,t) tricore_elf_section_flags(f,a,t)
+extern flagword tricore_elf_section_flags (flagword, int, int);
+#define md_elf_section_letter(l,m) tricore_elf_section_letter(l, m)
+extern int tricore_elf_section_letter (int, char **);
+#define md_elf_section_change_hook tricore_elf_section_change_hook
+extern void tricore_elf_section_change_hook (void);
+
+/* Set machine flags in ELF header.  */
+#define elf_tc_final_processing tricore_elf_final_processing
+extern void tricore_elf_final_processing (void);
+
+/* Handle relaxation of TriCore/PCP instructions.  */
+#define TC_GENERIC_RELAX_TABLE md_relax_table
+extern const struct relax_type md_relax_table[];
+#define TC_HANDLES_FX_DONE
+#define MD_PCREL_FROM_SECTION(f,s) md_pcrel_from_section (f, s)
+extern long md_pcrel_from_section (struct fix *, segT);
+#define md_prepare_relax_scan(fragP, address, aim, this_state, this_type) \
+  do									  \
+    {									  \
+      if ((this_state == tricore_relax_loopu_state)			  \
+          && (((aim < 0) && (aim < this_type->rlx_backward))		  \
+              || ((aim >= 0) && (aim > this_type->rlx_forward))))	  \
+        fragP->fr_subtype = this_type->rlx_more;			  \
+      else if ((this_state == tricore_relax_loop_state) && (aim == -2))	  \
+        aim = 0;							  \
+    }									  \
+  while (0)
+extern relax_substateT tricore_relax_loop_state;
+extern relax_substateT tricore_relax_loopu_state;
+
+/* Handle relocations.  */
+extern void tricore_sort_relocs (asection *, arelent **, unsigned int);
+#define SET_SECTION_RELOCS(sec, relocs, n) tricore_sort_relocs (sec, relocs, n)
+extern int tricore_fix_adjustable (struct fix *);
+#define obj_fix_adjustable(fixP) tricore_fix_adjustable (fixP)
+#define TC_FIX_ADJUSTABLE(fixP) \
+  (!symbol_used_in_reloc_p (fixP->fx_addsy) && obj_fix_adjustable (fixP))
+extern int tricore_force_relocation (struct fix *);
+#define TC_FORCE_RELOCATION(fixP) tricore_force_relocation (fixP)
+#define TC_RELOC_RTSYM_LOC_FIXUP(fixP)		\
+  (((fixP)->fx_addsy == NULL)			\
+   || (!S_IS_EXTERNAL ((fixP)->fx_addsy)	\
+       && !S_IS_WEAK ((fixP)->fx_addsy)		\
+       && S_IS_DEFINED ((fixP)->fx_addsy)	\
+       && !S_IS_COMMON ((fixP)->fx_addsy)))
+
+/* Minimum instruction length for DWARF2 line debug information entries.  */
+#define DWARF2_LINE_MIN_INSN_LENGTH 2
+
+#ifdef HTC_SUPPORT
+/* Tell users that this version of GAS is supported by HighTec.  */
+extern void htc_check_gas_version_flags (int *, char ***);
+#define HOST_SPECIAL_INIT(argc, argv) \
+  htc_check_gas_version_flags (&argc, &argv)
+#define HTC_GAS_VERSION VERSION
+
+/* Enable extended listing support by setting EXT_LISTING to 1.  */
+#ifndef NO_LISTING
+#define EXT_LISTING 1
+#endif /* !NO_LISTING  */
+
+#if EXT_LISTING
+extern void listing_notice (const char *);
+extern char ext_listing_buf[];
+extern fragS *ext_listing_frag;
+#define EXT_LISTING_BUFLEN 2000
+#define EXT_BUF ext_listing_buf, EXT_LISTING_BUFLEN
+#define ASM_NOTICE() listing_notice (ext_listing_buf)
+#define ASM_NOTICE_WORKAROUND(msg)	\
+  do					\
+    {					\
+      if (listing & LISTING_LISTING)	\
+        {				\
+	  snprintf (EXT_BUF, msg);	\
+	  ASM_NOTICE ();		\
+	}				\
+    }					\
+  while (0)
+
+#define TC_FRAG_TYPE	\
+  struct ext_frag	\
+    {			\
+      char *notice;	\
+      int notice_lines;	\
+    }
+#define FRAG_NOTICE(frag) (frag)->tc_frag_data.notice
+#define FRAG_NOTICE_LINES(frag) (frag)->tc_frag_data.notice_lines
+#define TC_FRAG_INIT(frag)			\
+  do						\
+    {						\
+      FRAG_NOTICE (frag) = (char *) NULL;	\
+      FRAG_NOTICE_LINES (frag) = 0;		\
+    }						\
+  while (0)
+#endif /* EXT_LISTING  */
+#endif /* HTC_SUPPORT  */
+
+/* End of tc-tricore.h.  */
diff --git a/gas/configure.tgt b/gas/configure.tgt
index 338892add2a..ddb081cfed7 100644
--- a/gas/configure.tgt
+++ b/gas/configure.tgt
@@ -109,6 +109,7 @@ case ${cpu} in
   sparc*)		cpu_type=sparc arch=sparclite ;; # ??? See tc-sparc.c.
   tilegx*be)		cpu_type=tilegx endian=big ;;
   tilegx*)		cpu_type=tilegx endian=little ;;
+  tricore*)    cpu_type=tricore endian=little;;
   v850*)		cpu_type=v850 ;;
   visium)		cpu_type=visium endian=big ;;
   wasm32)               cpu_type=wasm32 endian=little ;;
@@ -401,6 +402,8 @@ case ${generic_target} in
 
   tilepro-*-* | tilegx*-*-*)		fmt=elf ;;
 
+  tricore-*-*)     fmt=elf ;;
+
   v850*-*-*)				fmt=elf ;;
 
   vax-*-netbsdelf*)			fmt=elf em=nbsd ;;
@@ -435,7 +438,7 @@ esac
 
 case ${cpu_type} in
   aarch64 | alpha | arm | csky | i386 | ia64 | microblaze | mips | ns32k | \
-  or1k | or1knd | pdp11 | ppc | riscv | sh | sparc | z80 | z8k)
+  or1k | or1knd | pdp11 | ppc | riscv | sh | sparc | tricore | z80 | z8k)
     bfd_gas=yes
     ;;
 esac
diff --git a/gas/po/POTFILES.in b/gas/po/POTFILES.in
index 35b4a79472c..bdf2f2db268 100644
--- a/gas/po/POTFILES.in
+++ b/gas/po/POTFILES.in
@@ -162,6 +162,8 @@ config/tc-tilegx.c
 config/tc-tilegx.h
 config/tc-tilepro.c
 config/tc-tilepro.h
+config/tc-tricore.c
+config/tc-tricore.h
 config/tc-v850.c
 config/tc-v850.h
 config/tc-vax.c
diff --git a/gdb/Makefile.in b/gdb/Makefile.in
index 29ad9030273..a786d57a416 100644
--- a/gdb/Makefile.in
+++ b/gdb/Makefile.in
@@ -843,6 +843,7 @@ ALL_TARGET_OBS = \
 	tic6x-tdep.o \
 	tilegx-linux-tdep.o \
 	tilegx-tdep.o \
+	tricore-tdep.o \
 	v850-tdep.o \
 	vax-netbsd-tdep.o \
 	vax-tdep.o \
@@ -1452,6 +1453,7 @@ HFILES_NO_SRCDIR = \
 	trad-frame.h \
 	target-float.h \
 	tramp-frame.h \
+	tricore-tdep.h \
 	type-stack.h \
 	typeprint.h \
 	ui-file.h \
diff --git a/gdb/configure.tgt b/gdb/configure.tgt
index 97a5a57c378..b53ef799e52 100644
--- a/gdb/configure.tgt
+++ b/gdb/configure.tgt
@@ -682,6 +682,11 @@ tilegx-*-linux*)
 			symfile-mem.o glibc-tdep.o linux-tdep.o"
 	;;
 
+tricore*-*-*)
+	# Target: Tricore
+	gdb_target_obs="tricore-tdep.o"
+	;;
+
 xstormy16-*-*)
 	# Target: Sanyo Xstormy16a processor
 	gdb_target_obs="xstormy16-tdep.o"
diff --git a/gdb/features/Makefile b/gdb/features/Makefile
index 6fd7d463ccd..41723738ba9 100644
--- a/gdb/features/Makefile
+++ b/gdb/features/Makefile
@@ -66,7 +66,8 @@ WHICH = mips-linux mips-dsp-linux \
 	s390-te-linux64 s390x-te-linux64 s390-vx-linux64 s390x-vx-linux64 \
 	s390-tevx-linux64 s390x-tevx-linux64 \
 	s390-gs-linux64 s390x-gs-linux64 \
-	tic6x-c64xp-linux tic6x-c64x-linux tic6x-c62x-linux
+	tic6x-c64xp-linux tic6x-c64x-linux tic6x-c62x-linux \
+	tricore
 
 # Record which registers should be sent to GDB by default after stop.
 aarch64-expedite = x29,sp,pc
@@ -94,6 +95,7 @@ s390-tevx-linux64-expedite = r14l,r15l,pswa
 s390-gs-linux64-expedite = r14,r15,pswa
 s390x-expedite = r14,r15,pswa
 tic6x-expedite = A15,PC
+tricore-expedite = a15,pc
 
 
 XSLTPROC = xsltproc
@@ -171,6 +173,7 @@ XMLTOC = \
 	s390x-vx-linux64.xml \
 	s390-gs-linux64.xml \
 	s390x-gs-linux64.xml \
+	tricore.xml \
 	z80.xml
 
 TDESC_CFILES = $(patsubst %.xml,%.c,$(XMLTOC))
diff --git a/gdb/features/tricore-core.xml b/gdb/features/tricore-core.xml
new file mode 100644
index 00000000000..2c442873082
--- /dev/null
+++ b/gdb/features/tricore-core.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2014-2020 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.tricore.core">
+  <reg name="d0" bitsize="32" regnum="0"/>
+  <reg name="d1" bitsize="32" type="data_ptr"/>
+  <reg name="d2" bitsize="32"/>
+  <reg name="d3" bitsize="32"/>
+  <reg name="d4" bitsize="32"/>
+  <reg name="d5" bitsize="32"/>
+  <reg name="d6" bitsize="32"/>
+  <reg name="d7" bitsize="32"/>
+  <reg name="d8" bitsize="32"/>
+  <reg name="d9" bitsize="32"/>
+  <reg name="d10" bitsize="32"/>
+  <reg name="d11" bitsize="32"/>
+  <reg name="d12" bitsize="32"/>
+  <reg name="d13" bitsize="32"/>
+  <reg name="d14" bitsize="32"/>
+  <reg name="d15" bitsize="32"/>
+  <reg name="a0" bitsize="32"/>
+  <reg name="a1" bitsize="32"/>
+  <reg name="a2" bitsize="32"/>
+  <reg name="a3" bitsize="32"/>
+  <reg name="a4" bitsize="32"/>
+  <reg name="a5" bitsize="32" type="code_ptr"/>
+  <reg name="a6" bitsize="32"/>
+  <reg name="a7" bitsize="32"/>
+  <reg name="a8" bitsize="32"/>
+  <reg name="a9" bitsize="32"/>
+  <reg name="a10" bitsize="32"/>
+  <reg name="a11" bitsize="32"/>
+  <reg name="a12" bitsize="32"/>
+  <reg name="a13" bitsize="32"/>
+  <reg name="a14" bitsize="32"/>
+  <reg name="a15" bitsize="32"/>
+  <reg name="lcx" bitsize="32"/>
+  <reg name="fcx" bitsize="32"/>
+  <reg name="pcxi" bitsize="32"/>
+  <reg name="psw" bitsize="32"/>
+  <reg name="pc" bitsize="32"/>
+  <reg name="icr" bitsize="32"/>
+  <reg name="isp" bitsize="32"/>
+  <reg name="btv" bitsize="32"/>
+  <reg name="biv" bitsize="32"/>
+  <reg name="syscon" bitsize="32"/>
+  <reg name="pmucon0" bitsize="32"/>
+  <reg name="cycles" bitsize="32"/>
+  <reg name="instr" bitsize="32"/>
+  <reg name="time" bitsize="32"/>
+</feature>
diff --git a/gdb/features/tricore-fpu.xml b/gdb/features/tricore-fpu.xml
new file mode 100644
index 00000000000..d2dbe4da117
--- /dev/null
+++ b/gdb/features/tricore-fpu.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2007-2020 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.tricore.fpu">
+  <reg name="FPU_TRAP_CON" bitsize="32" type="ieee_single" regnum="0"/>
+  <reg name="FPU_TRAP_PC" bitsize="32" type="ieee_single"/>
+  <reg name="FPU_TRAP_OPC" bitsize="32" type="ieee_single"/>
+  <reg name="FPU_TRAP_SRC1" bitsize="32" type="ieee_single"/>
+  <reg name="FPU_TRAP_SRC2" bitsize="32" type="ieee_single"/>
+  <reg name="FPU_TRAP_SRC3" bitsize="32" type="ieee_single"/>
+  <reg name="FPU_ID" bitsize="32" type="ieee_single"/>
+</feature>
diff --git a/gdb/features/tricore.c b/gdb/features/tricore.c
new file mode 100644
index 00000000000..e1ef0c36da8
--- /dev/null
+++ b/gdb/features/tricore.c
@@ -0,0 +1,65 @@
+/* THIS FILE IS GENERATED.  -*- buffer-read-only: t -*- vi:set ro:
+  Original: tricore.xml */
+
+#include "defs.h"
+#include "osabi.h"
+#include "target-descriptions.h"
+
+struct target_desc *tdesc_tricore;
+static void
+initialize_tdesc_tricore (void)
+{
+  target_desc_up result = allocate_target_description ();
+  set_tdesc_architecture (result.get (), bfd_scan_arch ("tricore"));
+
+  struct tdesc_feature *feature;
+
+  feature = tdesc_create_feature (result.get (), "org.gnu.gdb.tricore.core");
+  tdesc_create_reg (feature, "d0", 0, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d1", 1, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d2", 2, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d3", 3, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d4", 4, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d5", 5, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d6", 6, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d7", 7, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d8", 8, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d9", 9, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d10", 10, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d11", 11, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d12", 12, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d13", 13, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d14", 14, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "d15", 15, 1, "data", 32, "int");
+  tdesc_create_reg (feature, "a0", 16, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a1", 17, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a2", 18, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a3", 19, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a4", 20, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a5", 21, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a6", 22, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a7", 23, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a8", 24, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a9", 25, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a10", 26, 1, "address", 32, "data_ptr");
+  tdesc_create_reg (feature, "a11", 27, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a12", 28, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a13", 29, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a14", 30, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "a15", 31, 1, "address", 32, "int");
+  tdesc_create_reg (feature, "lcx", 32, 1, NULL, 32, "int");
+  tdesc_create_reg (feature, "fcx", 33, 1, NULL, 32, "int");
+  tdesc_create_reg (feature, "pcxi", 34, 1, NULL, 32, "int");
+  tdesc_create_reg (feature, "psw", 35, 1, NULL, 32, "int");
+  tdesc_create_reg (feature, "pc", 36, 1, NULL, 32, "code_ptr");
+  tdesc_create_reg (feature, "icr", 37, 1, NULL, 32, "int");
+  tdesc_create_reg (feature, "isp", 38, 1, NULL, 32, "int");
+  tdesc_create_reg (feature, "btv", 39, 1, NULL, 32, "int");
+  tdesc_create_reg (feature, "biv", 40, 1, NULL, 32, "int");
+  tdesc_create_reg (feature, "syscon", 41, 1, NULL, 32, "int");
+  tdesc_create_reg (feature, "pmucon0", 42, 1, NULL, 32, "int");
+  tdesc_create_reg (feature, "dmucon", 43, 1, NULL, 32, "int");
+  tdesc_create_reg (feature, "lcx", 44, 1, NULL, 32, "int");
+  
+  tdesc_tricore = result.release ();
+}
diff --git a/gdb/features/tricore.xml b/gdb/features/tricore.xml
new file mode 100644
index 00000000000..53e2bbe2e09
--- /dev/null
+++ b/gdb/features/tricore.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2013-2020 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE target SYSTEM "gdb-target.dtd">
+<target>
+  <architecture>tricore</architecture>
+  <xi:include href="tricore-core.xml"/>
+  <xi:include href="tricore-fpu.xml"/>
+</target>
\ No newline at end of file
diff --git a/gdb/regformats/tricore.dat b/gdb/regformats/tricore.dat
new file mode 100644
index 00000000000..7fb7b53f3ba
--- /dev/null
+++ b/gdb/regformats/tricore.dat
@@ -0,0 +1,58 @@
+# THIS FILE IS GENERATED.  -*- buffer-read-only: t -*- vi :set ro:
+# Generated from: tricore.xml
+name:tricore
+xmltarget:tricore.xml
+expedite:a15,pc
+32:d0
+32:FPU_TRAP_CON
+32:d1
+32:FPU_TRAP_PC
+32:d2
+32:FPU_TRAP_OPC
+32:d3
+32:FPU_TRAP_SRC1
+32:d4
+32:FPU_TRAP_SRC2
+32:d5
+32:FPU_TRAP_SRC3
+32:d6
+32:FPU_ID
+32:d7
+32:d8
+32:d9
+32:d10
+32:d11
+32:d12
+32:d13
+32:d14
+32:d15
+32:a0
+32:a1
+32:a2
+32:a3
+32:a4
+32:a5
+32:a6
+32:a7
+32:a8
+32:a9
+32:a10
+32:a11
+32:a12
+32:a13
+32:a14
+32:a15
+32:lcx
+32:fcx
+32:pcxi
+32:psw
+32:pc
+32:icr
+32:isp
+32:btv
+32:biv
+32:syscon
+32:pmucon0
+32:cycles
+32:instr
+32:time
diff --git a/gdb/tricore-tdep.c b/gdb/tricore-tdep.c
new file mode 100644
index 00000000000..9660e3908e9
--- /dev/null
+++ b/gdb/tricore-tdep.c
@@ -0,0 +1,738 @@
+/* Target-dependent code for Infineon TriCore.
+
+   Copyright (C) 2009-2020 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "arch-utils.h"
+#include "dis-asm.h"
+#include "frame.h"
+#include "trad-frame.h"
+#include "symtab.h"
+#include "value.h"
+#include "gdbcmd.h"
+#include "gdbcore.h"
+#include "breakpoint.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "target.h"
+#include "frame-base.h"
+#include "frame-unwind.h"
+#include "dwarf2/frame.h"
+#include "osabi.h"
+#include "target-descriptions.h"
+#include "opcode/tricore.h"
+#include "tricore-tdep.h"
+#include "remote.h"
+#include "elf-bfd.h"
+#include "elf/tricore.h"
+#include "tricore.h"
+#include "objfiles.h"
+#include "gdbtypes.h"
+#include "gdbarch.h"
+#include "opcodes/disassemble.h"
+#include "features/tricore.c"
+
+#define TRICORE_BREAKPOINT      {0x00, 0xa0} /* debug */
+constexpr gdb_byte tricore_break_insn[] = TRICORE_BREAKPOINT;
+typedef BP_MANIPULATION (tricore_break_insn) tricore_breakpoint;
+
+/* The registers of the Infineon TriCore processor.  */
+
+static const char *tricore_register_names[] =
+{
+    "d0", "d1", "d2",  "d3",  "d4",  "d5",  "d6",  "d7",
+    "d8", "d9", "d10", "d11", "d12", "d13", "d14", "d15",
+    "a0", "a1", "a2",  "a3",  "a4",  "a5",  "a6",  "a7",
+    "a8", "a9", "a10", "a11", "a12", "a13", "a14", "a15",
+    "lcx", "fcx", "pcxi", "psw", "pc", "icr", "isp",
+    "btv", "biv", "syscon", "pmucon0", "dmucon"
+};
+
+#define TRICORE_NUM_REGS ARRAY_SIZE (tricore_register_names)
+
+static unsigned int tricore_debug_flag = 0;
+
+/* This array describes which registers are stored in the context save
+   area (CSA) upon execution of a call instruction or an exception.
+   We use this to find the saved registers of a given frame.  */
+
+static int csa_upper_regs_a[] =
+{
+  TRICORE_PCXI_REGNUM, TRICORE_PSW_REGNUM, TRICORE_SP_REGNUM, TRICORE_RA_REGNUM, TRICORE_A12_REGNUM, TRICORE_A13_REGNUM,
+  TRICORE_A14_REGNUM, TRICORE_A15_REGNUM, TRICORE_D8_REGNUM, TRICORE_D9_REGNUM, TRICORE_D10_REGNUM, TRICORE_D11_REGNUM,
+  TRICORE_D12_REGNUM, TRICORE_D13_REGNUM, TRICORE_D14_REGNUM, TRICORE_D15_REGNUM
+};
+
+static const int num_csa_upper_regs = sizeof (csa_upper_regs_a) / sizeof (int);
+
+/* Same as above, but for the lower context.  */
+
+static int csa_lower_regs_a[] =
+{
+  TRICORE_PCXI_REGNUM, TRICORE_PC_REGNUM, TRICORE_A2_REGNUM, TRICORE_A3_REGNUM, TRICORE_A4_REGNUM, TRICORE_A5_REGNUM,
+  TRICORE_A6_REGNUM, TRICORE_A7_REGNUM, TRICORE_D0_REGNUM, TRICORE_D1_REGNUM, TRICORE_D2_REGNUM, TRICORE_D3_REGNUM,
+  TRICORE_D4_REGNUM, TRICORE_D5_REGNUM, TRICORE_D6_REGNUM, TRICORE_D7_REGNUM
+};
+
+static const int num_csa_lower_regs = sizeof (csa_lower_regs_a) / sizeof (int);
+
+/* Upper/lower contexts for Rider-B.  */
+
+static int csa_upper_regs_b[] =
+{
+  TRICORE_PCXI_REGNUM, TRICORE_PSW_REGNUM, TRICORE_SP_REGNUM, TRICORE_RA_REGNUM, TRICORE_D8_REGNUM, TRICORE_D9_REGNUM,
+  TRICORE_D10_REGNUM, TRICORE_D11_REGNUM, TRICORE_A12_REGNUM, TRICORE_A13_REGNUM, TRICORE_A14_REGNUM, TRICORE_A15_REGNUM,
+  TRICORE_D12_REGNUM, TRICORE_D13_REGNUM, TRICORE_D14_REGNUM, TRICORE_D15_REGNUM
+};
+
+static int csa_lower_regs_b[] =
+{
+  TRICORE_PCXI_REGNUM, TRICORE_PC_REGNUM, TRICORE_A2_REGNUM, TRICORE_A3_REGNUM, TRICORE_D0_REGNUM, TRICORE_D1_REGNUM,
+  TRICORE_D2_REGNUM, TRICORE_D3_REGNUM, TRICORE_A4_REGNUM, TRICORE_A5_REGNUM, TRICORE_A6_REGNUM, TRICORE_A7_REGNUM,
+  TRICORE_D4_REGNUM, TRICORE_D5_REGNUM, TRICORE_D6_REGNUM, TRICORE_D7_REGNUM
+};
+
+static int *csa_upper_regs = csa_upper_regs_b;
+static int *csa_lower_regs = csa_lower_regs_b;
+
+static const char *
+tricore_register_name (struct gdbarch *gdbarch, int regnum)
+{
+  if (regnum >= 0 && regnum < TRICORE_NUM_REGS)
+    return tricore_register_names[regnum];
+  return NULL;
+}
+
+/* Which instruction set architecure do we use?  */
+
+static tricore_isa current_isa = TRICORE_V1_2;
+#define RIDER_A (current_isa == TRICORE_V1_1)
+#define RIDER_B (current_isa == TRICORE_V1_2)
+
+/* Check what ISA is actually in use.  */
+
+static void
+tricore_find_isa (struct gdbarch_info *info)
+{
+  unsigned long mask;
+
+  if (info->abfd == NULL)
+    return;
+
+  // mask = tricore_elf32_convert_eflags (elf_elfheader (info->abfd)->e_flags);
+
+  mask = EF_EABI_TRICORE_V1_2;
+  
+  switch (mask & EF_EABI_TRICORE_CORE_MASK)
+    {
+      case EF_EABI_TRICORE_V1_1:
+	current_isa = TRICORE_V1_1;
+	csa_upper_regs = csa_upper_regs_a;
+	csa_lower_regs = csa_lower_regs_a;
+	break;
+
+      case EF_EABI_TRICORE_V1_2:
+      case EF_EABI_TRICORE_V1_3:
+      case EF_EABI_TRICORE_V1_3_1:
+      case EF_EABI_TRICORE_V1_6:
+      case EF_EABI_TRICORE_V1_6_1:
+	current_isa = TRICORE_V1_2;
+	csa_upper_regs = csa_upper_regs_b;
+	csa_lower_regs = csa_lower_regs_b;
+	break;
+
+      default:
+	error ("Unknown TriCore ISA in ELF header detected.");
+    }
+}
+
+/* Find the first real insn of the function starting at PC.  On the
+   TriCore, a prologue (as produced by gcc) looks like this:
+
+   > If the workaround for Rider-D's cpu13 bug is enabled:
+       dsync                    0480000d
+     If additonally the workaround for Rider-B/D's cpu9 bug is enabled:
+       nop                      0000
+       nop                      0000
+     or
+       nop                      0000000d
+       nop                      0000000d
+
+   > If the frame pointer (%a1) is used:
+       st.a [+%sp]-8,%ax        f5b8ax89
+
+       mov.aa %ax,%sp           ax80      RIDER-A only
+     or
+       mov.aa %ax,%sp           ax40      RIDER-B/D only
+     or
+       mov.aa %ax,%sp           x000a001
+
+   > If space is needed to store local variables on the stack:
+       sub.a %sp,const8         xx40      RIDER-A only
+     or
+       sub.a %sp,const8         xx20      RIDER-B/D only
+     or
+       lea %sp,[%sp]const16     xxxxaad9
+     or
+       movh.a %a15,const16      fxxxx091
+       (lea %a15,[%a15]const16  xxxxffd9) if const16 != 0
+       sub.a %sp,%sp,%a15       a020fa01
+
+   > If the TOC pointer (%a12) needs to be loaded:
+       movh.a %a12,hi:toc       cxxxx091
+       lea %a12,[%a12]lo:toc    xxxxccd9
+
+   > If this is main, then __main is called:
+       call __main              xxxxxx6d
+
+   Note that registers are not saved explicitly, as this is done
+   automatically by the call insn.  */
+
+static CORE_ADDR
+tricore_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
+{
+  CORE_ADDR insn;
+  CORE_ADDR main_pc, __main_pc, offset;
+  struct symtab_and_line sal;
+  struct bound_minimal_symbol sym;
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  struct gdbarch_info *info =tdep->info;
+
+  if (tricore_debug_flag)
+    fprintf_unfiltered (gdb_stdlog, "*** tricore_skip_prologue (0x%08lx) = ", pc);
+
+  tricore_find_isa (info);
+
+  /* Check if PC points to main ().  */
+  main_pc = __main_pc = (CORE_ADDR) 0;
+  sym = lookup_minimal_symbol_text ("main", (struct objfile *) NULL);
+  if (sym.minsym)
+    {
+      if (BMSYMBOL_VALUE_ADDRESS (sym) == pc)
+        {
+          main_pc = pc;
+          sym = lookup_minimal_symbol_text ("__main",
+                                            (struct objfile *) NULL);
+          if (sym.minsym)
+            __main_pc = BMSYMBOL_VALUE_ADDRESS (sym);
+        }
+    }
+
+  insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+
+  /* Handle Rider-B/D workarounds.  */
+  if (RIDER_B && (insn == 0x0480000d)) /* dsync  */
+    {
+      pc += 4;
+      insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+
+      /* Skip 1 or 2 16- or 32-bit NOPs, if present.  */
+      if (insn == 0x00000000) /* 2 16-bit NOPs.  */
+        {
+          pc += 4;
+          insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+        }
+      else if (insn == 0x0000000d) /* 1st 32-bit NOP.  */
+        {
+          pc += 4;
+          insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+          if (insn == 0x0000000d) /* 2nd 32-bit NOP.  */
+            {
+              pc += 4;
+              insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+            }
+        }
+      else if ((insn & 0xffff0000) == 0x00000000) /* Only 1 16-bit NOP.  */
+        {
+          pc += 2;
+          insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+        }
+    }
+
+  /* Handle stack and frame pointer manipulation.  */
+  if (RIDER_A && ((insn & 0xff) == 0x40)) /* sub.a %sp,const8  */
+    pc += 2;
+  else if (RIDER_B && ((insn & 0xff) == 0x20)) /* sub.a %sp,const8  */
+    pc += 2;
+  else
+    {
+      if ((insn & 0xfffff0ff) == 0xf5b8a089) /* st.a [+%sp]-8,%ax  */
+        {
+          pc += 4;
+          insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+
+          if (RIDER_A && ((insn & 0xf0ff) == 0xa080)) /* mov.aa %an,%sp  */
+            {
+              pc += 2;
+              insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+            }
+          else if (RIDER_B && ((insn & 0xf0ff) == 0xa040)) /* mov.aa %an,%sp  */
+            {
+              pc += 2;
+              insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+            }
+          else if ((insn & 0x0fffffff) == 0x0000a001) /* mov.aa %an,%sp  */
+            {
+              pc += 4;
+              insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+            }
+        }
+
+      if (RIDER_A && ((insn & 0xff) == 0x40)) /* sub.a %sp,const8  */
+        pc += 2;
+      else if (RIDER_B && ((insn & 0xff) == 0x20)) /* sub.a %sp,const8  */
+        pc += 2;
+      else if ((insn & 0xffff) == 0xaad9) /* lea %sp,[%sp]const16  */
+        pc += 4;
+      else if ((insn & 0xf0000fff) == 0xf0000091) /* movh.a %a15,const16  */
+        {
+          CORE_ADDR old_pc = pc;
+
+          pc += 4;
+          insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+          if ((insn & 0x0000ffff) == 0x0000ffd9) /* lea %a15,[%a15]const16  */
+            {
+              pc += 4;
+              insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+            }
+          if (insn == 0xa020fa01) /* sub.a %sp,%sp,%a15  */
+            pc += 4;
+          else
+            pc = old_pc;
+        }
+    }
+
+  /* Handle TOC pointer.  */
+  insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+  if ((insn & 0xf0000fff) == 0xc0000091)
+    {
+      pc += 8;
+      if (main_pc != (CORE_ADDR) 0)
+        insn = read_memory_integer (pc, 4, gdbarch_byte_order (gdbarch));
+    }
+
+  /* Check for "call __main".  FIXME: Should also check for CALLA etc.  */
+  if (main_pc != (CORE_ADDR) 0)
+    {
+      if ((insn & 0x000000ff) == 0x0000006d)
+        {
+          offset = (insn & 0xffff0000) >> 16;
+          offset |= (insn & 0x0000ff00) << 8;
+          if (offset & 0x800000)
+            offset |= ~0xffffff;
+          offset <<= 1;
+          if ((pc + offset) == __main_pc)
+            pc += 4;
+        }
+      else if (RIDER_B && ((insn & 0xff) == 0x5c))
+        {
+          offset = (insn & 0x0000ff00) >> 8;
+          if (offset & 0x80)
+            offset |= ~0xff;
+          offset <<= 1;
+          if ((pc + offset) == __main_pc)
+            pc += 2;
+        }
+    }
+
+  if (tricore_debug_flag)
+    fprintf_unfiltered (gdb_stdlog, "0x%08lx\n", pc);
+
+  return pc;
+}
+
+static void
+tricore_frame_this_id (struct frame_info *this_frame,
+		     void **prologue_cache,
+		     struct frame_id *this_id)
+{
+
+  try
+    {
+      // HAVE TO THINK HERE
+    }
+  catch (const gdb_exception_error &ex)
+    {
+      /* Ignore errors, this leaves the frame id as the predefined outer
+         frame id which terminates the backtrace at this point.  */
+    }
+}
+
+
+static const struct frame_unwind tricore_frame_unwind =
+{
+  "tricore frame unwind",
+  NORMAL_FRAME,
+  default_frame_unwind_stop_reason,
+  tricore_frame_this_id,
+  (value* (*)(frame_info*, void**, int)) 0XB,
+  (const frame_data*) 0XC,
+  default_frame_sniffer
+};
+
+/* Return number of args passed to a frame.
+   Can return -1, meaning no way to tell. */
+
+static int
+tricore_frame_num_args (struct frame_info *fi)
+{
+#if 0 /* WT 2006-04-19 */
+  return -1;
+#else
+  return 0;
+#endif /* WT 2006-04-19 */
+}
+
+/* TriCore uses CSAs (Context Save Area) in a linked list.
+   The normal stack concept cannot be used for TriCore. */
+static int
+tricore_inner_than (CORE_ADDR lhs, CORE_ADDR rhs)
+{
+  if (tricore_debug_flag)
+    fprintf_unfiltered (gdb_stdlog, "*** tricore_inner_than: lhs=0x%08lx, rhs=0x%08lx\n", lhs, rhs);
+  return 0;
+}
+
+/* Write the return value in SRC with type TYPE into the
+   appropriate register(s).  This is called when making the
+   current frame returning using "ret value_to_be_returned".  */
+
+static void
+tricore_store_return_value (struct type *type, struct regcache *regs,
+			    const gdb_byte *src)
+{
+  int regno, len;
+
+  if ((type->code () == TYPE_CODE_PTR) ||
+      (type->code () == TYPE_CODE_REF))
+    regno = TRICORE_A2_REGNUM;
+  else
+    regno = TRICORE_D2_REGNUM;
+
+  /* Sanity checking... */
+  if ((len = TYPE_LENGTH (type)) > 8)
+    len = 8;
+
+  regs->cooked_write_part (regno, 0, len, src);
+
+}
+
+/* Copy the return value in REGS with type TYPE to DST.  This is
+   used to find out the return value of a function after a "finish"
+   command has been issued, and after a call dummy has returned.  */
+
+static void
+tricore_extract_return_value (struct type *type,
+                              struct regcache *regs,
+                              gdb_byte *dst)
+{
+  int regno, len;
+
+  if ((type->code () == TYPE_CODE_PTR) ||
+      (type->code () == TYPE_CODE_REF))
+    regno = TRICORE_A2_REGNUM;
+  else
+    regno = TRICORE_D2_REGNUM;
+
+  /* Sanity checking... */
+  if ((len = TYPE_LENGTH (type)) > 8)
+    len = 8;
+
+  regs->cooked_read_part (regno, 0, len, dst); 
+
+}
+
+
+/* Setting/getting return values from functions.
+
+   If USE_STRUCT_CONVENTION returns 0, then gdb uses STORE_RETURN_VALUE
+   and EXTRACT_RETURN_VALUE to store/fetch the functions return value. */
+
+/* Will a function return an aggregate type in memory or in a
+   register?  Return 0 if an aggregate type can be returned in a
+   register, 1 if it must be returned in memory.  */
+
+static enum return_value_convention
+tricore_return_value (struct gdbarch *gdbarch, struct value *function,
+		    struct type *type, struct regcache *regcache,
+		    gdb_byte *readbuf, const gdb_byte *writebuf)
+{
+  int struct_return = type->code () == TYPE_CODE_STRUCT
+		      || type->code () == TYPE_CODE_UNION
+		      || type->code () == TYPE_CODE_ARRAY;
+
+  if (writebuf != NULL)
+    {
+      gdb_assert (!struct_return);
+      tricore_store_return_value (type, regcache, writebuf);
+    }
+
+  if (readbuf != NULL)
+    {
+      gdb_assert (!struct_return);
+      tricore_extract_return_value (type, regcache, readbuf);
+    }
+
+  /* All aggregate types larger than double word are returned in memory */
+  if (TYPE_LENGTH (type) > 8)
+    return RETURN_VALUE_STRUCT_CONVENTION;
+  return RETURN_VALUE_REGISTER_CONVENTION;
+}
+
+/* Figure out where the longjmp will land.  We expect the first arg (%a4)
+   to be a pointer to the jmp_buf structure from which we extract the PC
+   that we will land at.  The PC is copied into *PC.  This routine returns
+   true on success.  */
+
+static int
+tricore_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)
+{
+  CORE_ADDR a4;
+  struct gdbarch *gdbarch = get_frame_arch (frame);
+  //a4 = read_register (TRICORE_A4_REGNUM); deprecated, we should use FRAME
+  a4 = get_frame_register_unsigned(frame, TRICORE_A4_REGNUM);
+  *pc = read_memory_integer (a4, 4, gdbarch_byte_order (gdbarch));
+
+  return 1;
+}
+
+/* Caveat: Writing to TriCore's scratch pad RAM (SPRAM) is only allowed
+   in chunks of 32 bits and only at 32-bit-aligned addresses.  Since a
+   breakpoint instruction ("debug") only takes 16 bits, we need to be
+   careful when inserting/removing breakpoints.  */
+
+
+static int
+tricore_memory_insert_breakpoint (struct gdbarch *gdbarch, struct bp_target_info *bp_tgt)
+{
+  CORE_ADDR addr = bp_tgt->placed_address = bp_tgt->reqstd_address;
+  int val, offs;
+  gdb_byte bp[] = TRICORE_BREAKPOINT;
+  gdb_byte contents_cache[4];
+
+  /* Save the memory contents.  */
+  val = target_read_memory (addr & ~3, contents_cache, 4);
+  if (val != 0)
+    return val;			/* return error */
+
+  memcpy (bp_tgt->shadow_contents, contents_cache, 4);
+  bp_tgt->shadow_len = 4;
+
+
+  /* Write the breakpoint.  */
+  /* check word alignment */
+  offs = ((addr & 3) ? 2 : 0);
+  memcpy(contents_cache + offs, bp, 2);
+  val = target_write_memory (addr & ~3, contents_cache, 4);
+
+  return val;
+}
+
+static int
+tricore_memory_remove_breakpoint (struct gdbarch *gdbarch,
+			       struct bp_target_info *bp_tgt)
+{
+  CORE_ADDR addr = bp_tgt->placed_address;
+  gdb_byte *contents_cache = bp_tgt->shadow_contents;
+  gdb_byte mem_cache[4];
+  int val, offs;
+
+  val = target_read_memory (addr & ~3, mem_cache, 4);
+  if (val != 0)
+    return val;			/* return error */
+  
+  offs = ((addr & 3) ? 2 : 0);
+  memcpy(mem_cache + offs, contents_cache + offs , 2);  
+
+  val = target_write_memory (addr & ~3, mem_cache, 4);
+
+  return val;
+}
+
+static const unsigned char *
+tricore_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
+{
+  static const unsigned char breakpoint_insn[] = TRICORE_BREAKPOINT;
+
+  *lenptr = sizeof (breakpoint_insn);
+  return breakpoint_insn;
+}
+
+static struct gdbarch *
+tricore_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
+{
+  struct gdbarch_tdep *tdep;
+  struct gdbarch *gdbarch;
+  tdesc_arch_data_up tdesc_data;
+  const struct target_desc *tdesc = info.target_desc;
+
+  /* If there is already a candidate, use it.  */
+  arches = gdbarch_list_lookup_by_info (arches, &info);
+  if (arches != NULL)
+    return arches->gdbarch;
+  if (tdesc == NULL) {
+    initialize_tdesc_tricore ();
+    tdesc = tdesc_tricore;
+  }
+    
+
+  /* Check any target description for validity.  */
+  if (tdesc_has_registers (tdesc))
+    {
+      const struct tdesc_feature *feature;
+      int valid_p;
+      int i;
+
+      feature = tdesc_find_feature (tdesc,
+                                    "org.gnu.gdb.tricore.core");
+      if (feature == NULL)
+        return NULL;
+      tdesc_data = tdesc_data_alloc ();
+
+      valid_p = 1;
+      for (i = 0; i < TRICORE_NUM_REGS; i++)
+        valid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i,
+                                            tricore_register_names[i]);
+      if (!valid_p)
+        {
+          //tdesc_data.release ();
+          return NULL;
+        }
+    }
+
+  /* Allocate space for the new architecture.  */
+  tdep = XCNEW (struct gdbarch_tdep);
+  gdbarch = gdbarch_alloc (&info, tdep);
+  tdep->info = &info;
+
+  /* Register info */
+  set_gdbarch_num_regs (gdbarch, TRICORE_NUM_REGS);
+  set_gdbarch_pc_regnum (gdbarch, TRICORE_PC_REGNUM);
+  set_gdbarch_sp_regnum (gdbarch, TRICORE_SP_REGNUM);
+  set_gdbarch_deprecated_fp_regnum (gdbarch, TRICORE_FP_REGNUM);
+  set_gdbarch_ps_regnum (gdbarch, TRICORE_PSW_REGNUM);
+
+  set_gdbarch_num_pseudo_regs (gdbarch, 0);
+  set_gdbarch_register_name (gdbarch, tricore_register_name);
+  // set_gdbarch_deprecated_register_size (gdbarch, 4);
+  // set_gdbarch_deprecated_register_bytes (gdbarch, TRICORE_NUM_REGS * 4);
+  // set_gdbarch_deprecated_register_byte (gdbarch, tricore_register_byte);
+  // set_gdbarch_deprecated_register_raw_size (gdbarch, tricore_register_raw_size);
+  // set_gdbarch_deprecated_max_register_raw_size (gdbarch, 4);
+  // set_gdbarch_deprecated_register_virtual_size (gdbarch, tricore_register_virtual_size);
+  // set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 4);
+  // set_gdbarch_deprecated_register_virtual_type (gdbarch, tricore_register_virtual_type);
+  // set_gdbarch_deprecated_register_convertible (gdbarch, tricore_register_convertible);
+
+/* Frame and stack info */
+  set_gdbarch_skip_prologue (gdbarch, tricore_skip_prologue);
+  //set_gdbarch_deprecated_saved_pc_after_call (gdbarch, tricore_saved_pc_after_call);
+
+  set_gdbarch_frame_num_args (gdbarch, tricore_frame_num_args);
+
+  // set_gdbarch_deprecated_frame_chain (gdbarch, tricore_frame_chain);
+  // set_gdbarch_deprecated_frame_saved_pc (gdbarch, tricore_frame_saved_pc);
+
+  // set_gdbarch_deprecated_frame_args_address (gdbarch, tricore_frame_args_address);
+  // set_gdbarch_deprecated_frame_locals_address (gdbarch, tricore_frame_locals_address);
+
+  // set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, tricore_frame_init_saved_regs);
+  // set_gdbarch_deprecated_get_saved_register (gdbarch, tricore_get_saved_register);
+  // set_gdbarch_deprecated_init_extra_frame_info (gdbarch, tricore_init_extra_frame_info);
+
+  /* Unwind the frame.  */
+  dwarf2_append_unwinders (gdbarch);
+  frame_unwind_append_unwinder (gdbarch, &tricore_frame_unwind);
+  frame_base_append_sniffer (gdbarch, dwarf2_frame_base_sniffer);
+
+  set_gdbarch_inner_than (gdbarch, tricore_inner_than);
+
+  set_gdbarch_decr_pc_after_break (gdbarch, 0);
+  //set_gdbarch_deprecated_function_start_offset (gdbarch, 0);
+  set_gdbarch_frame_args_skip (gdbarch, 0);
+
+  /* Return value info */
+  //set_gdbarch_deprecated_extract_struct_value_address (gdbarch, tricore_extract_struct_value_address);
+  set_gdbarch_return_value (gdbarch, tricore_return_value);
+   
+ 
+  //set_gdbarch_deprecated_push_return_address (gdbarch, tricore_push_return_address);
+  //set_gdbarch_deprecated_reg_struct_has_addr (gdbarch, tricore_reg_struct_has_addr);
+  //set_gdbarch_extract_return_value (gdbarch, tricore_extract_return_value);
+  //set_gdbarch_store_return_value (gdbarch, tricore_store_return_value);
+
+  /* Call dummy info */
+  //set_gdbarch_deprecated_push_dummy_frame (gdbarch, tricore_push_dummy_frame);
+  // set_gdbarch_deprecated_pop_frame (gdbarch, tricore_pop_frame);
+  // set_gdbarch_deprecated_fix_call_dummy (gdbarch, tricore_fix_call_dummy);
+  // set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, tricore_pc_in_call_dummy);
+  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
+  // set_gdbarch_deprecated_call_dummy_words (gdbarch, tricore_call_dummy_words);
+  // set_gdbarch_deprecated_call_dummy_length (gdbarch, 0);
+  // set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof_tricore_call_dummy_words);
+  // set_gdbarch_deprecated_call_dummy_start_offset (gdbarch, 0);
+  // set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, 8);
+
+  /* we build our own dummy frames: tricore_push_dummy_frame */
+  //set_gdbarch_deprecated_use_generic_dummy_frames (gdbarch, 0);
+
+
+
+  //set_gdbarch_deprecated_push_arguments (gdbarch, tricore_push_arguments);
+  set_gdbarch_get_longjmp_target (gdbarch, tricore_get_longjmp_target);
+
+  /* Breakpoint support */
+  set_gdbarch_memory_insert_breakpoint (gdbarch, tricore_memory_insert_breakpoint);
+  set_gdbarch_memory_remove_breakpoint (gdbarch, tricore_memory_remove_breakpoint);
+  set_gdbarch_breakpoint_from_pc (gdbarch, tricore_breakpoint_from_pc);
+    set_gdbarch_breakpoint_kind_from_pc (gdbarch,
+				       tricore_breakpoint::kind_from_pc);
+  set_gdbarch_sw_breakpoint_from_kind (gdbarch,
+				       tricore_breakpoint::bp_from_kind);
+#ifdef USE_NEXTPC
+//  set_gdbarch_software_single_step (gdbarch, tricore_software_single_step);
+#endif /* USE_NEXTPC */
+
+  set_gdbarch_print_insn (gdbarch, default_print_insn);
+
+  /* Hook in OS ABI-specific overrides, if they have been registered.  */
+  gdbarch_init_osabi (info, gdbarch);
+  
+  if (tdesc_data != NULL)
+    tdesc_use_registers (gdbarch, tdesc, std::move(tdesc_data));
+
+  return gdbarch;
+}
+
+void _initialize_tricore_tdep ();
+void
+_initialize_tricore_tdep ()
+{
+  register_gdbarch_init (bfd_arch_tricore, tricore_gdbarch_init);
+
+  /* Debug this files internals.  */
+  add_setshow_zuinteger_cmd ("tricore", class_maintenance,
+			     &tricore_debug_flag, _("\
+Set tricore debugging."), _("\
+Show tricore debugging."), _("\
+When non-zero, tricore specific debugging is enabled."),
+			     NULL,
+			     NULL,
+			     &setdebuglist, &showdebuglist);
+
+}
\ No newline at end of file
diff --git a/gdb/tricore-tdep.h b/gdb/tricore-tdep.h
new file mode 100644
index 00000000000..d418f768ff9
--- /dev/null
+++ b/gdb/tricore-tdep.h
@@ -0,0 +1,98 @@
+/* Target-dependent code for Infineon TriCore.
+
+   Copyright (C) 2009-2020 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef TRICORE_TDEP_H
+#define TRICORE_TDEP_H 1
+
+/* TriCore architecture-specific information.  */
+struct gdbarch_tdep
+{
+    // We need struct gdbarch_info
+    struct gdbarch_info *info;
+    
+};
+
+#ifdef __VIRTUAL_IO__
+#include <sys/types.h>
+#include <fcntl.h>
+#include "gdb_stat.h"
+#endif /* __VIRTUAL_IO__ */
+
+#ifdef TSIM_CYCLES
+#define CYCLES_REGNUM 44
+#define INSTR_REGNUM 45
+#define TIME_REGNUM 46
+//#define TRICORE_NUM_REGS 47
+#else
+//#define TRICORE_NUM_REGS 44
+#endif
+
+/* Register numbers.  */
+enum tricore_regnum
+{
+    TRICORE_D0_REGNUM,
+    TRICORE_D1_REGNUM,
+    TRICORE_D2_REGNUM,
+    TRICORE_D3_REGNUM,
+    TRICORE_D4_REGNUM, TRICORE_DARG0_REGNUM = TRICORE_D4_REGNUM,
+    TRICORE_D5_REGNUM,
+    TRICORE_D6_REGNUM,
+    TRICORE_D7_REGNUM, TRICORE_DARGLAST_REGNUM = TRICORE_D7_REGNUM,
+    TRICORE_D8_REGNUM,
+    TRICORE_D9_REGNUM,
+    TRICORE_D10_REGNUM,
+    TRICORE_D11_REGNUM,
+    TRICORE_D12_REGNUM,
+    TRICORE_D13_REGNUM,
+    TRICORE_D14_REGNUM,
+    TRICORE_D15_REGNUM,
+    TRICORE_A0_REGNUM,
+    TRICORE_A1_REGNUM,
+    TRICORE_A2_REGNUM,
+    TRICORE_A3_REGNUM,
+    TRICORE_A4_REGNUM, TRICORE_STRUCT_RETURN_REGNUM = TRICORE_A4_REGNUM, TRICORE_AARG0_REGNUM = TRICORE_A4_REGNUM,
+    TRICORE_A5_REGNUM,
+    TRICORE_A6_REGNUM,
+    TRICORE_A7_REGNUM, TRICORE_AARGLAST_REGNUM = TRICORE_A7_REGNUM,
+    TRICORE_A8_REGNUM,
+    TRICORE_A9_REGNUM,
+    TRICORE_A10_REGNUM, TRICORE_FP_REGNUM = TRICORE_A10_REGNUM, TRICORE_SP_REGNUM = TRICORE_A10_REGNUM,
+    TRICORE_A11_REGNUM, TRICORE_RA_REGNUM = TRICORE_A11_REGNUM,
+    TRICORE_A12_REGNUM,
+    TRICORE_A13_REGNUM,
+    TRICORE_A14_REGNUM,
+    TRICORE_A15_REGNUM,
+    TRICORE_LCX_REGNUM,
+    TRICORE_FCX_REGNUM,
+    TRICORE_PCXI_REGNUM,
+    TRICORE_PSW_REGNUM,
+    TRICORE_PC_REGNUM,
+    TRICORE_ICR_REGNUM,
+    TRICORE_ISP_REGNUM,
+    TRICORE_BTV_REGNUM,
+    TRICORE_BIV_REGNUM,
+    TRICORE_SYSCON_REGNUM,
+    TRICORE_PMUCON0_REGNUM,
+    TRICORE_DMUCON_REGNUM,
+    TRICORE_NUM_REGS
+};
+
+#define INT_REGISTER_SIZE 4
+
+#endif /* tricore-tdep.h */
\ No newline at end of file
diff --git a/include/elf/tricore.h b/include/elf/tricore.h
new file mode 100644
index 00000000000..6fa9ad1eb30
--- /dev/null
+++ b/include/elf/tricore.h
@@ -0,0 +1,210 @@
+/* TriCore ELF support for BFD.
+   Copyright (C) 1998-2003 Free Software Foundation, Inc.
+   Contributed by Michael Schumacher (mike@hightec-rt.com).
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* This file holds definitions specific to the TriCore EABI.  */
+   
+
+#ifndef _ELF_TRICORE_H
+#define _ELF_TRICORE_H
+
+/* Executable-only code section.  */
+
+#define SHF_TRICORE_NOREAD	0x00000800
+
+/* Absolute section.  */
+
+#define SHF_TRICORE_ABS		0x00000400
+
+/* PCP section (code or data).  */
+
+#define SHF_TRICORE_PCP		0x10000000
+
+
+/* Instruction set architecture V1.1.  */
+#define EF_TRICORE_V1_1				0x00000001
+#define EF_EABI_TRICORE_V1_1		0x80000000
+
+/* Instruction set architecture V1.2.  */
+#define EF_TRICORE_V1_2				0x00000002
+#define EF_EABI_TRICORE_V1_2		0x40000000
+
+/* Instruction set architecture V1.3.  */
+#define EF_TRICORE_V1_3				0x00000004
+#define EF_EABI_TRICORE_V1_3		0x20000000
+
+
+/* Instruction set architecture V1.3.1  */
+
+#define EF_TRICORE_V1_3_1			0x00000100
+#define EF_EABI_TRICORE_V1_3_1		0x00800000
+
+/* Instruction set architecture V1.6.  */
+
+#define EF_TRICORE_V1_6				0x00000200
+#define EF_EABI_TRICORE_V1_6		0x00400000
+
+/* Instruction set architecture V1.6.1.  */
+
+#define EF_TRICORE_V1_6_1			0x00000400
+#define EF_EABI_TRICORE_V1_6_1		0x00200000
+
+
+/* PCP co-processor.  */
+
+#define EF_TRICORE_PCP				0x00000010
+#define EF_EABI_TRICORE_PCP			0x01000000
+
+/* PCP co-processor, version 2.  */
+
+#define EF_TRICORE_PCP2				0x00000020
+#define EF_EABI_TRICORE_PCP2		0x02000000
+
+#define EF_TRICORE_CORE_MASK		0x00000f0f
+#define EF_EABI_TRICORE_CORE_MASK	0xf0f00000
+
+/* function to convert old to new eflags definition */
+//extern unsigned long tricore_elf32_convert_eflags(unsigned long eflags);
+/* convert old eflags to EABI conforming eflags */
+#define tricore_elf32_convert_eflags(eflags) (\
+{                                             \
+  unsigned long new_flags = 0;                \
+  int i;                                      \
+                                              \
+  if (eflags & 0xffff0000)                    \
+    new_flags = eflags;                       \
+  else                                        \
+    for (i = 0; i < 16; i++)                  \
+      {                                       \
+        if (eflags & (1 << i))                \
+          new_flags |= 1 << (31-i);           \
+      }                                       \
+  (eflags) = new_flags;                       \
+} ) 
+/* Relocations.  */
+
+#include "elf/reloc-macros.h"
+
+START_RELOC_NUMBERS (elf_tricore_reloc_type)
+  RELOC_NUMBER (R_TRICORE_NONE, 0)
+  RELOC_NUMBER (R_TRICORE_32REL, 1)
+  RELOC_NUMBER (R_TRICORE_32ABS, 2)
+  RELOC_NUMBER (R_TRICORE_24REL, 3)
+  RELOC_NUMBER (R_TRICORE_24ABS, 4)
+  RELOC_NUMBER (R_TRICORE_16SM, 5)
+  RELOC_NUMBER (R_TRICORE_HIADJ, 6)
+  RELOC_NUMBER (R_TRICORE_LO, 7)
+  RELOC_NUMBER (R_TRICORE_LO2, 8)
+  RELOC_NUMBER (R_TRICORE_18ABS, 9)
+  RELOC_NUMBER (R_TRICORE_10SM, 10)
+  RELOC_NUMBER (R_TRICORE_15REL, 11)
+
+  /* Below are GNU extensions.  */
+
+  RELOC_NUMBER (R_TRICORE_HI, 12)
+  RELOC_NUMBER (R_TRICORE_16CONST, 13)
+  RELOC_NUMBER (R_TRICORE_9ZCONST, 14)
+  RELOC_NUMBER (R_TRICORE_9SCONST, 15)
+  RELOC_NUMBER (R_TRICORE_8REL, 16)
+  RELOC_NUMBER (R_TRICORE_8CONST, 17)
+  RELOC_NUMBER (R_TRICORE_10OFF, 18)
+  RELOC_NUMBER (R_TRICORE_16OFF, 19)
+  RELOC_NUMBER (R_TRICORE_8ABS, 20)
+  RELOC_NUMBER (R_TRICORE_16ABS, 21)
+  RELOC_NUMBER (R_TRICORE_1BIT, 22)
+  RELOC_NUMBER (R_TRICORE_3POS, 23)
+  RELOC_NUMBER (R_TRICORE_5POS, 24)
+
+  /* PCP relocations.  */
+
+  RELOC_NUMBER (R_TRICORE_PCPHI, 25)
+  RELOC_NUMBER (R_TRICORE_PCPLO, 26)
+  RELOC_NUMBER (R_TRICORE_PCPPAGE, 27)
+  RELOC_NUMBER (R_TRICORE_PCPOFF, 28)
+  RELOC_NUMBER (R_TRICORE_PCPTEXT, 29)
+
+  /* More GNU extensions.  */
+
+  RELOC_NUMBER (R_TRICORE_5POS2, 30)
+  RELOC_NUMBER (R_TRICORE_BRCC, 31)
+  RELOC_NUMBER (R_TRICORE_BRCZ, 32)
+  RELOC_NUMBER (R_TRICORE_BRNN, 33)
+  RELOC_NUMBER (R_TRICORE_RRN, 34)
+  RELOC_NUMBER (R_TRICORE_4CONST, 35)
+  RELOC_NUMBER (R_TRICORE_4REL, 36)
+  RELOC_NUMBER (R_TRICORE_4REL2, 37)
+  RELOC_NUMBER (R_TRICORE_5POS3, 38)
+  RELOC_NUMBER (R_TRICORE_4OFF, 39)
+  RELOC_NUMBER (R_TRICORE_4OFF2, 40)
+  RELOC_NUMBER (R_TRICORE_4OFF4, 41)
+  RELOC_NUMBER (R_TRICORE_42OFF, 42)
+  RELOC_NUMBER (R_TRICORE_42OFF2, 43)
+  RELOC_NUMBER (R_TRICORE_42OFF4, 44)
+  RELOC_NUMBER (R_TRICORE_2OFF, 45)
+  RELOC_NUMBER (R_TRICORE_8CONST2, 46)
+  RELOC_NUMBER (R_TRICORE_4POS, 47)
+  RELOC_NUMBER (R_TRICORE_16SM2, 48)
+  RELOC_NUMBER (R_TRICORE_5REL, 49)
+
+  /* GNU extensions to help optimizing virtual tables (C++).  */
+
+  RELOC_NUMBER (R_TRICORE_GNU_VTENTRY, 50)
+  RELOC_NUMBER (R_TRICORE_GNU_VTINHERIT, 51)
+
+  /* Support for shared objects.  */
+
+  RELOC_NUMBER (R_TRICORE_PCREL16, 52)
+  RELOC_NUMBER (R_TRICORE_PCREL8, 53)
+  RELOC_NUMBER (R_TRICORE_GOT, 54)
+  RELOC_NUMBER (R_TRICORE_GOT2, 55)
+  RELOC_NUMBER (R_TRICORE_GOTHI, 56)
+  RELOC_NUMBER (R_TRICORE_GOTLO, 57)
+  RELOC_NUMBER (R_TRICORE_GOTLO2, 58)
+  RELOC_NUMBER (R_TRICORE_GOTUP, 59)
+  RELOC_NUMBER (R_TRICORE_GOTOFF, 60)
+  RELOC_NUMBER (R_TRICORE_GOTOFF2, 61)
+  RELOC_NUMBER (R_TRICORE_GOTOFFHI, 62)
+  RELOC_NUMBER (R_TRICORE_GOTOFFLO, 63)
+  RELOC_NUMBER (R_TRICORE_GOTOFFLO2, 64)
+  RELOC_NUMBER (R_TRICORE_GOTOFFUP, 65)
+  RELOC_NUMBER (R_TRICORE_GOTPC, 66)
+  RELOC_NUMBER (R_TRICORE_GOTPC2, 67)
+  RELOC_NUMBER (R_TRICORE_GOTPCHI, 68)
+  RELOC_NUMBER (R_TRICORE_GOTPCLO, 69)
+  RELOC_NUMBER (R_TRICORE_GOTPCLO2, 70)
+  RELOC_NUMBER (R_TRICORE_GOTPCUP, 71)
+  RELOC_NUMBER (R_TRICORE_PLT, 72)
+  RELOC_NUMBER (R_TRICORE_COPY, 73)
+  RELOC_NUMBER (R_TRICORE_GLOB_DAT, 74)
+  RELOC_NUMBER (R_TRICORE_JMP_SLOT, 75)
+  RELOC_NUMBER (R_TRICORE_RELATIVE, 76)
+
+  /* Support for single bit objects.  */
+
+  RELOC_NUMBER (R_TRICORE_BITPOS, 77)
+
+  /* Support for small data addressing areas */
+  /* get the base address of a small data symbol */
+
+  RELOC_NUMBER (R_TRICORE_SBREG_S2, 78)
+  RELOC_NUMBER (R_TRICORE_SBREG_S1, 79)
+  RELOC_NUMBER (R_TRICORE_SBREG_D,  80)
+END_RELOC_NUMBERS (R_TRICORE_max)
+
+#endif /* _ELF_TRICORE_H  */
diff --git a/include/opcode/tricore.h b/include/opcode/tricore.h
new file mode 100644
index 00000000000..0c0cd74d3f1
--- /dev/null
+++ b/include/opcode/tricore.h
@@ -0,0 +1,459 @@
+/* Definitions dealing with TriCore/PCP opcodes and core registers.
+   Copyright (C) 1998-2003 Free Software Foundation, Inc.
+   Contributed by Michael Schumacher (mike@hightec-rt.com).
+
+This file is part of GDB, GAS, and the GNU binutils.
+
+GDB, GAS, and the GNU binutils are free software; you can redistribute
+them and/or modify them under the terms of the GNU General Public
+License as published by the Free Software Foundation; either version
+1, or (at your option) any later version.
+
+GDB, GAS, and the GNU binutils are distributed in the hope that they
+will be useful, but WITHOUT ANY WARRANTY; without even the implied
+warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this file; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+/* Supported TriCore and PCP instruction set architectures.  */
+
+/*
+	rename 	RIDER_B => V1_2
+  			RIDER_D	=> V1_3
+*/
+
+#ifndef _TRICORE_H_
+#define _TRICORE_H_ 1
+
+typedef enum _tricore_opcode_arch_val
+{
+  TRICORE_GENERIC = 0x00000000,
+  TRICORE_V1_1    = 0x00000001,  // RIDER_A
+  TRICORE_V1_2 	  = 0x00000002,  // RIDER_B RIDER_D
+  TRICORE_V1_3    = 0x00000004,  // TRICORE_V2,
+  TRICORE_V1_3_1  = 0x00000100,
+  TRICORE_V1_6    = 0x00000200,
+  TRICORE_V1_6_1  = 0x00000400,
+  TRICORE_PCP     = 0x00000010,
+  TRICORE_PCP2    = 0x00000020
+} tricore_isa;
+
+#define TRICORE_ISA_MASK	0x00000f0f
+
+/* Some handy definitions for upward/downward compatibility of insns.  */
+
+#define TRICORE_V1_6_1_UP	(TRICORE_V1_6_1)
+#define TRICORE_V1_6_UP		(TRICORE_V1_6   | TRICORE_V1_6_1_UP)
+#define TRICORE_V1_3_1_UP	(TRICORE_V1_3_1 | TRICORE_V1_6_UP)
+#define TRICORE_V1_3_UP		(TRICORE_V1_3   | TRICORE_V1_3_1_UP)
+#define TRICORE_V1_2_UP		(TRICORE_V1_2   | TRICORE_V1_3_UP)
+
+#define TRICORE_V1_2_DN		TRICORE_V1_2
+#define TRICORE_V1_3_DN		(TRICORE_V1_3   | TRICORE_V1_2_DN)
+#define TRICORE_V1_3_X_DN	(TRICORE_V1_3   | TRICORE_V1_2_DN | TRICORE_V1_3_1)
+#define TRICORE_V1_3_1_DN	(TRICORE_V1_3_1 | TRICORE_V1_3_DN)
+#define TRICORE_V1_6_DN		(TRICORE_V1_6   | TRICORE_V1_3_1_DN)
+#define TRICORE_V1_6_1_DN	(TRICORE_V1_6_1 | TRICORE_V1_6_DN)
+
+/* The various instruction formats of the TriCore architecture.  */
+
+typedef enum _tricore_fmt
+{
+  /* 32-bit formats */
+
+  TRICORE_FMT_ABS,
+  TRICORE_FMT_ABSB,
+  TRICORE_FMT_B,
+  TRICORE_FMT_BIT,
+  TRICORE_FMT_BO,
+  TRICORE_FMT_BOL,
+  TRICORE_FMT_BRC,
+  TRICORE_FMT_BRN,
+  TRICORE_FMT_BRR,
+  TRICORE_FMT_RC,
+  TRICORE_FMT_RCPW,
+  TRICORE_FMT_RCR,
+  TRICORE_FMT_RCRR,
+  TRICORE_FMT_RCRW,
+  TRICORE_FMT_RLC,
+  TRICORE_FMT_RR,
+  TRICORE_FMT_RR1,
+  TRICORE_FMT_RR2,
+  TRICORE_FMT_RRPW,
+  TRICORE_FMT_RRR,
+  TRICORE_FMT_RRR1,
+  TRICORE_FMT_RRR2,
+  TRICORE_FMT_RRRR,
+  TRICORE_FMT_RRRW,
+  TRICORE_FMT_SYS,
+
+  /* 16-bit formats */
+
+  TRICORE_FMT_SB,
+  TRICORE_FMT_SBC,
+  TRICORE_FMT_SBR,
+  TRICORE_FMT_SBRN,
+  TRICORE_FMT_SC,
+  TRICORE_FMT_SLR,
+  TRICORE_FMT_SLRO,
+  TRICORE_FMT_SR,
+  TRICORE_FMT_SRC,
+  TRICORE_FMT_SRO,
+  TRICORE_FMT_SRR,
+  TRICORE_FMT_SRRS,
+  TRICORE_FMT_SSR,
+  TRICORE_FMT_SSRO,
+  TRICORE_FMT_MAX /* Sentinel.  */
+} tricore_fmt;
+
+#if defined(__STDC__) || defined(ALMOST_STDC)
+# define F(x) TRICORE_FMT_ ## x
+#else
+# define F(x) TRICORE_FMT_/**/x
+#endif
+
+/* Opcode masks for the instruction formats above.  */
+
+extern unsigned long tricore_mask_abs;
+extern unsigned long tricore_mask_absb;
+extern unsigned long tricore_mask_b;
+extern unsigned long tricore_mask_bit;
+extern unsigned long tricore_mask_bo;
+extern unsigned long tricore_mask_bol;
+extern unsigned long tricore_mask_brc;
+extern unsigned long tricore_mask_brn;
+extern unsigned long tricore_mask_brr;
+extern unsigned long tricore_mask_rc;
+extern unsigned long tricore_mask_rcpw;
+extern unsigned long tricore_mask_rcr;
+extern unsigned long tricore_mask_rcrr;
+extern unsigned long tricore_mask_rcrw;
+extern unsigned long tricore_mask_rlc;
+extern unsigned long tricore_mask_rr;
+extern unsigned long tricore_mask_rr1;
+extern unsigned long tricore_mask_rr2;
+extern unsigned long tricore_mask_rrpw;
+extern unsigned long tricore_mask_rrr;
+extern unsigned long tricore_mask_rrr1;
+extern unsigned long tricore_mask_rrr2;
+extern unsigned long tricore_mask_rrrr;
+extern unsigned long tricore_mask_rrrw;
+extern unsigned long tricore_mask_sys;
+extern unsigned long tricore_mask_sb;
+extern unsigned long tricore_mask_sbc;
+extern unsigned long tricore_mask_sbr;
+extern unsigned long tricore_mask_sbrn;
+extern unsigned long tricore_mask_sc;
+extern unsigned long tricore_mask_slr;
+extern unsigned long tricore_mask_slro;
+extern unsigned long tricore_mask_sr;
+extern unsigned long tricore_mask_src;
+extern unsigned long tricore_mask_sro;
+extern unsigned long tricore_mask_srr;
+extern unsigned long tricore_mask_srrs;
+extern unsigned long tricore_mask_ssr;
+extern unsigned long tricore_mask_ssro;
+extern unsigned long tricore_opmask[];
+
+extern void tricore_init_arch_vars  (unsigned long);
+
+/* This structure describes TriCore opcodes.  */
+
+struct tricore_opcode
+{
+  const char *name;		/* The opcode's mnemonic name.  */
+  const int len32;		/* 1 if it's a 32-bit insn.  */
+  const unsigned long opcode;	/* The binary code of this opcode.  */
+  const unsigned long lose;	/* Mask for bits that must not be set.  */
+  const tricore_fmt format;	/* The instruction format.  */
+  const int nr_operands;	/* The number of operands.  */
+  const char *args;	/* Kinds of operands (see below).  */
+  const unsigned char *fields;	/* Where to put the operands (see below).  */
+  const tricore_isa isa;	/* Instruction set architecture.  */
+  int insind;			/* The insn's index (computed at runtime).  */
+  int inslast;			/* Index of last insn w/ that name (dito).  */
+};
+
+extern struct tricore_opcode tricore_opcodes[];
+extern const int tricore_numopcodes;
+extern unsigned long tricore_opmask[];
+
+/* This structure describes PCP/PCP2 opcodes.  */
+
+struct pcp_opcode
+{
+  const char *name;		/* The opcode's mnemonic name.  */
+  const int len32;		/* 1 if it's a 32-bit insn.  */
+  const unsigned long opcode;	/* The binary code of this opcode.  */
+  const unsigned long lose;	/* Mask for bits that must not be set.  */
+  const int fmt_group;		/* The group ID of the instruction format.  */
+  const int ooo;		/* 1 if operands may be given out of order.  */
+  const int nr_operands;	/* The number of operands.  */
+  const unsigned char *args;	/* Kinds of operands (see below),  */
+  const tricore_isa isa;	/* PCP instruction set architecture.  */
+  int insind;			/* The insn's index (computed at runtime).  */
+  int inslast;			/* Index of last insn w/ that name (dito).  */
+};
+
+extern struct pcp_opcode pcp_opcodes[];
+extern const int pcp_numopcodes;
+
+/* This structure describes TriCore core registers (SFRs).  */
+
+struct tricore_core_register
+{
+  const char *name;		/* The name of the register ($-prepended).  */
+  const unsigned long addr;	/* The memory address of the register.  */
+  const tricore_isa isa;	/* Instruction set architecture.  */
+};
+
+extern const struct tricore_core_register tricore_sfrs[];
+extern const int tricore_numsfrs;
+
+/* Kinds of operands for TriCore instructions:
+   d  A simple data register (%d0-%d15).
+   g  A simple data register with an 'l' suffix.
+   G  A simple data register with an 'u' suffix.
+   -  A simple data register with an 'll' suffix.
+   +  A simple data register with an 'uu' suffix.
+   l  A simple data register with an 'lu' suffix.
+   L  A simple data register with an 'ul' suffix.
+   D  An extended data register (d-register pair; %e0, %e2, ..., %e14).
+   i  Implicit data register %d15.
+   a  A simple address register (%a0-%a15).
+   A  An extended address register (a-register pair; %a0, %a2, ..., %a14).
+   I  Implicit address register %a15.
+   P  Implicit stack register %a10.
+   c  A core register ($psw, $pc etc.).
+   1  A 1-bit zero-extended constant.
+   2  A 2-bit zero-extended constant.
+   3  A 3-bit zero-extended constant.
+   4  A 4-bit sign-extended constant.
+   f  A 4-bit zero-extended constant.
+   5  A 5-bit zero-extended constant.
+   F  A 5-bit sign-extended constant.
+   v  A 5-bit zero-extended constant with bit 0 == 0 (=> 4bit/2).
+   6  A 6-bit zero-extended constant with bits 0,1 == 0 (=> 4bit/4).
+   8  A 8-bit zero-extended constant.
+   9  A 9-bit sign-extended constant.
+   n  A 9-bit zero-extended constant.
+   h  A 10-bit zero-extended constant.
+   k  A 10-bit zero-extended constant with bits 0,1 == 0 (=> 8bit/4).
+   0  A 10-bit sign-extended constant.
+   q  A 15-bit zero-extended constant.
+   w  A 16-bit sign-extended constant.
+   W  A 16-bit zero-extended constant.
+   M  A 32-bit memory address.
+   m  A 4-bit PC-relative offset (zero-extended, /2).
+   r  A 4-bit PC-relative offset (one-extended, /2).
+   x  A 5-bit PC-relative offset (zero-extended, /2).
+   Z  A 5-bit PC-relative offset 0x1x (zero-extended, /2).
+   R  A 8-bit PC-relative offset (sign-extended, /2).
+   o  A 15-bit PC-relative offset (sign-extended, /2).
+   O  A 24-bit PC-relative offset (sign-extended, /2).
+   t  A 18-bit absolute memory address (segmented).
+   T  A 24-bit absolute memory address (segmented, /2).
+   U  A symbol whose value isn't known yet.
+   @  Register indirect ([%an]).
+   &  SP indirect ([%sp] or [%a10]).
+   <  Pre-incremented register indirect ([+%an]).
+   >  Post-incremented register indirect ([%an+]).
+   *  Circular address mode ([%An+c]).
+   #  Bitreverse address mode ([%An+r]).
+   ?  Indexed address mode ([%An+i]).
+   S  Implicit base ([%a15]).
+*/
+
+/* The instruction fields where operands are stored.  */
+
+#define FMT_ABS_NONE	'0'
+#define FMT_ABS_OFF18	'1'
+#define FMT_ABS_S1_D	'2'
+#define FMT_ABSB_NONE	'0'
+#define FMT_ABSB_OFF18	'1'
+#define FMT_ABSB_B	'2'
+#define FMT_ABSB_BPOS3	'3'
+#define FMT_B_NONE	'0'
+#define FMT_B_DISP24	'1'
+#define FMT_BIT_NONE	'0'
+#define FMT_BIT_D	'1'
+#define FMT_BIT_P2	'2'
+#define FMT_BIT_P1	'3'
+#define FMT_BIT_S2	'4'
+#define FMT_BIT_S1	'5'
+#define FMT_BO_NONE	'0'
+#define FMT_BO_OFF10	'1'
+#define FMT_BO_S2	'2'
+#define FMT_BO_S1_D	'3'
+#define FMT_BOL_NONE	'0'
+#define FMT_BOL_OFF16	'1'
+#define FMT_BOL_S2	'2'
+#define FMT_BOL_S1_D	'3'
+#define FMT_BRC_NONE	'0'
+#define FMT_BRC_DISP15	'1'
+#define FMT_BRC_CONST4	'2'
+#define FMT_BRC_S1	'3'
+#define FMT_BRN_NONE	'0'
+#define FMT_BRN_DISP15	'1'
+#define FMT_BRN_N	'2'
+#define FMT_BRN_S1	'3'
+#define FMT_BRR_NONE	'0'
+#define FMT_BRR_DISP15	'1'
+#define FMT_BRR_S2	'2'
+#define FMT_BRR_S1	'3'
+#define FMT_RC_NONE	'0'
+#define FMT_RC_D	'1'
+#define FMT_RC_CONST9	'2'
+#define FMT_RC_S1	'3'
+#define FMT_RC_CONST10	'4'
+#define FMT_RCPW_NONE	'0'
+#define FMT_RCPW_D	'1'
+#define FMT_RCPW_P	'2'
+#define FMT_RCPW_W	'3'
+#define FMT_RCPW_CONST4	'4'
+#define FMT_RCPW_S1	'5'
+#define FMT_RCR_NONE	'0'
+#define FMT_RCR_D	'1'
+#define FMT_RCR_S3	'2'
+#define FMT_RCR_CONST9	'3'
+#define FMT_RCR_S1	'4'
+#define FMT_RCRR_NONE	'0'
+#define FMT_RCRR_D	'1'
+#define FMT_RCRR_S3	'2'
+#define FMT_RCRR_CONST4	'3'
+#define FMT_RCRR_S1	'4'
+#define FMT_RCRW_NONE	'0'
+#define FMT_RCRW_D	'1'
+#define FMT_RCRW_S3	'2'
+#define FMT_RCRW_W	'3'
+#define FMT_RCRW_CONST4	'4'
+#define FMT_RCRW_S1	'5'
+#define FMT_RLC_NONE	'0'
+#define FMT_RLC_D	'1'
+#define FMT_RLC_CONST16	'2'
+#define FMT_RLC_S1	'3'
+#define FMT_RR_NONE	'0'
+#define FMT_RR_D	'1'
+#define FMT_RR_N	'2'
+#define FMT_RR_S2	'3'
+#define FMT_RR_S1	'4'
+#define FMT_RR_D_S1	'5'
+#define FMT_RR1_NONE	'0'
+#define FMT_RR1_D	'1'
+#define FMT_RR1_N	'2'
+#define FMT_RR1_S2	'3'
+#define FMT_RR1_S1	'4'
+#define FMT_RR2_NONE	'0'
+#define FMT_RR2_D	'1'
+#define FMT_RR2_S2	'2'
+#define FMT_RR2_S1	'3'
+#define FMT_RRPW_NONE	'0'
+#define FMT_RRPW_D	'1'
+#define FMT_RRPW_P	'2'
+#define FMT_RRPW_W	'3'
+#define FMT_RRPW_S2	'4'
+#define FMT_RRPW_S1	'5'
+#define FMT_RRR_NONE	'0'
+#define FMT_RRR_D	'1'
+#define FMT_RRR_S3	'2'
+#define FMT_RRR_N	'3'
+#define FMT_RRR_S2	'4'
+#define FMT_RRR_S1	'5'
+#define FMT_RRR1_NONE	'0'
+#define FMT_RRR1_D	'1'
+#define FMT_RRR1_S3	'2'
+#define FMT_RRR1_N	'3'
+#define FMT_RRR1_S2	'4'
+#define FMT_RRR1_S1	'5'
+#define FMT_RRR2_NONE	'0'
+#define FMT_RRR2_D	'1'
+#define FMT_RRR2_S3	'2'
+#define FMT_RRR2_S2	'3'
+#define FMT_RRR2_S1	'4'
+#define FMT_RRRR_NONE	'0'
+#define FMT_RRRR_D	'1'
+#define FMT_RRRR_S3	'2'
+#define FMT_RRRR_S2	'3'
+#define FMT_RRRR_S1	'4'
+#define FMT_RRRW_NONE	'0'
+#define FMT_RRRW_D	'1'
+#define FMT_RRRW_S3	'2'
+#define FMT_RRRW_W	'3'
+#define FMT_RRRW_S2	'4'
+#define FMT_RRRW_S1	'5'
+#define FMT_SYS_NONE	'0'
+#define FMT_SYS_S1_D	'1'
+#define FMT_SB_NONE	'0'
+#define FMT_SB_DISP8	'1'
+#define FMT_SBC_NONE	'0'
+#define FMT_SBC_CONST4	'1'
+#define FMT_SBC_DISP4	'2'
+#define FMT_SBR_NONE	'0'
+#define FMT_SBR_S2	'1'
+#define FMT_SBR_DISP4	'2'
+#define FMT_SBRN_NONE	'0'
+#define FMT_SBRN_N	'1'
+#define FMT_SBRN_DISP4	'2'
+#define FMT_SC_NONE	'0'
+#define FMT_SC_CONST8	'1'
+#define FMT_SLR_NONE	'0'
+#define FMT_SLR_S2	'1'
+#define FMT_SLR_D	'2'
+#define FMT_SLRO_NONE	'0'
+#define FMT_SLRO_OFF4	'1'
+#define FMT_SLRO_D	'2'
+#define FMT_SR_NONE	'0'
+#define FMT_SR_S1_D	'1'
+#define FMT_SRC_NONE	'0'
+#define FMT_SRC_CONST4	'1'
+#define FMT_SRC_S1_D	'2'
+#define FMT_SRO_NONE	'0'
+#define FMT_SRO_S2	'1'
+#define FMT_SRO_OFF4	'2'
+#define FMT_SRR_NONE	'0'
+#define FMT_SRR_S2	'1'
+#define FMT_SRR_S1_D	'2'
+#define FMT_SRRS_NONE	'0'
+#define FMT_SRRS_S2	'1'
+#define FMT_SRRS_S1_D	'2'
+#define FMT_SRRS_N	'3'
+#define FMT_SSR_NONE	'0'
+#define FMT_SSR_S2	'1'
+#define FMT_SSR_S1	'2'
+#define FMT_SSRO_NONE	'0'
+#define FMT_SSRO_OFF4	'1'
+#define FMT_SSRO_S1	'2'
+
+/* Kinds of operands for PCP instructions:
+   a  Condition code 0-7 (CONDCA).
+   b  Condition code 8-15 (CONDCB).
+   c  CNC=[0,1,2].
+   d  DST{+,-}.
+   e  A constant expression.
+   E  An indirect constant expression.
+   f  SIZE=[8,16,32].
+   g  ST=[0,1].
+   h  EC=[0,1].
+   i  INT=[0,1].
+   j  EP=[0,1].
+   k  SET (const value 1).
+   l  CLR (const value 0).
+   m  DAC=[0,1].
+   n  CNT0=[1..8] for COPY, or [2,4,8] for BCOPY.
+   o  RTA=[0,1].
+   p  EDA=[0,1].
+   q  SDB=[0,1].
+   r  A direct register (R0-R7).
+   R  An indirect register ([R0]-[R7]).
+   s  SRC{+,-}.
+   u  A direct symbol whose value isn't known yet.
+   U  An indirect symbol whose value isn't known yet.
+*/
+
+/* End of tricore.h.  */
+
+#endif
\ No newline at end of file
diff --git a/ld/Makefile.in b/ld/Makefile.in
index ef2e99e08da..a2c77bf7398 100644
--- a/ld/Makefile.in
+++ b/ld/Makefile.in
@@ -758,6 +758,8 @@ ALL_EMULATION_SOURCES = \
 	eelf32tilegx.c \
 	eelf32tilegx_be.c \
 	eelf32tilepro.c \
+	eelf32tricoreel.c \
+	eelf32tricore.c \
 	eelf32vax.c \
 	eelf32visium.c \
 	eelf32xc16x.c \
diff --git a/ld/configure.tgt b/ld/configure.tgt
index 6205d7c9872..eb4bfc41b26 100644
--- a/ld/configure.tgt
+++ b/ld/configure.tgt
@@ -913,6 +913,12 @@ tilegxbe-*-*)		targ_emul=elf64tilegx_be
 			;;
 tilepro-*-*)		targ_emul=elf32tilepro
 			;;
+tricoreel*)		targ_emul=elf32tricoreel
+			targ_extra_emuls=elf32tricore
+			;;
+tricore*)		targ_emul=elf32tricore
+			targ_extra_emuls=elf32tricoreel
+			;;
 v850*-*-*)		targ_emul=v850_rh850
 			targ_extra_emuls=v850
 			;;
diff --git a/ld/emulparams/elf32tricore.sh b/ld/emulparams/elf32tricore.sh
new file mode 100644
index 00000000000..448c1c072e8
--- /dev/null
+++ b/ld/emulparams/elf32tricore.sh
@@ -0,0 +1,26 @@
+# If you change this file, please also look at files which source this one:
+# elf32tricoreeel.sh
+SCRIPT_NAME=elftricore
+BIG_OUTPUT_FORMAT="elf32-tricore"
+LITTLE_OUTPUT_FORMAT="elf32-tricoreel"
+OUTPUT_FORMAT=$BIG_OUTPUT_FORMAT
+#TEXT_START_ADDR=0
+NONPAGED_TEXT_START_ADDR=0x28
+ALIGNMENT=4
+MAXPAGESIZE=4
+ARCH=tricore
+EMBEDDED=yes
+
+NOP=0x80000000
+
+# Hmmm, there's got to be a better way.  This sets the stack to the
+# top of the simulator memory (2^19 bytes).
+#DATA_ADDR=0x10000
+#OTHER_RELOCATING_SECTIONS='.stack 0x7000 : { _stack = .; *(.stack) }'
+#$@{RELOCATING+ PROVIDE (__stack = 0x7000);@}
+#OTHER_RELOCATING_SECTIONS='PROVIDE (_stack = _end + 0x1000);'
+
+TEMPLATE_NAME=elf
+#GENERATE_SHLIB_SCRIPT=yes
+
+
diff --git a/ld/emulparams/elf32tricoreel.sh b/ld/emulparams/elf32tricoreel.sh
new file mode 100644
index 00000000000..3b6a76c2896
--- /dev/null
+++ b/ld/emulparams/elf32tricoreel.sh
@@ -0,0 +1,2 @@
+source_sh ${srcdir}/emulparams/elf32tricore.sh
+OUTPUT_FORMAT=$LITTLE_OUTPUT_FORMAT
diff --git a/ld/scripttempl/elftricore.sc b/ld/scripttempl/elftricore.sc
new file mode 100644
index 00000000000..902714d292f
--- /dev/null
+++ b/ld/scripttempl/elftricore.sc
@@ -0,0 +1,469 @@
+#
+# Linker script template for TriCore ELF objects and executables
+# (embedded version).
+#
+# Copyright (C) 1998-2005 Free Software Foundation, Inc.
+# Contributed by Michael Schumacher (mike@hightec-rt.com).
+#
+# When adding sections, do note that the names of some sections are used
+# when specifying the start address of the next.
+#
+test -z "$ENTRY" && ENTRY=_start
+if [ -z "$MACHINE" ]; then OUTPUT_ARCH=${ARCH}; else OUTPUT_ARCH=${ARCH}:${MACHINE}; fi
+test "$LD_FLAG" = "N" && DATA_ADDR=.
+
+# if this is for an embedded system, don't add SIZEOF_HEADERS.
+if [ -z "$EMBEDDED" ]; then
+   test -z "${TEXT_BASE_ADDRESS}" && TEXT_BASE_ADDRESS="${TEXT_START_ADDR} + SIZEOF_HEADERS"
+else
+   test -z "${TEXT_BASE_ADDRESS}" && TEXT_BASE_ADDRESS="${TEXT_START_ADDR}"
+fi
+Q=\"
+
+cat <<EOF
+OUTPUT_FORMAT("${OUTPUT_FORMAT}")
+OUTPUT_ARCH(${OUTPUT_ARCH})
+${RELOCATING+ENTRY(${ENTRY})}
+${RELOCATING+${EXECUTABLE_SYMBOLS}}
+${RELOCATING+
+
+/*
+ * NB: The memory map below works for TriCore simulators and some
+ * evaluation boards.  You may need to change the values to match
+ * your actual hardware setup and pass the modified script to the
+ * linker using its ${Q}-T${Q} option. Alternativly you can pass a 
+ * text file with the following symbol definition and a MEMORY section
+ * to the linker to override the default definitions
+ * (look at memory.x in the compiler specific directories for an example)
+ */
+
+/* the external RAM description */
+__EXT_CODE_RAM_BEGIN = DEFINED(__EXT_CODE_RAM_BEGIN)? __EXT_CODE_RAM_BEGIN : 0xa0000000;
+__EXT_CODE_RAM_SIZE  = DEFINED(__EXT_CODE_RAM_SIZE)? __EXT_CODE_RAM_SIZE : 512K ;
+__EXT_DATA_RAM_BEGIN = DEFINED(__EXT_DATA_RAM_BEGIN)? __EXT_DATA_RAM_BEGIN : 0xa0000000 + 512K;
+__EXT_DATA_RAM_SIZE  = DEFINED(__EXT_DATA_RAM_SIZE)? __EXT_DATA_RAM_SIZE : 512K;
+/*
+ * used to check for HEAP_SIZE
+ */
+__RAM_END = __EXT_DATA_RAM_BEGIN + __EXT_DATA_RAM_SIZE;
+/* the internal ram description */
+__INT_CODE_RAM_BEGIN = DEFINED(__INT_CODE_RAM_BEGIN)? __INT_CODE_RAM_BEGIN : 0xd400000;
+__INT_CODE_RAM_SIZE  = DEFINED(__INT_CODE_RAM_SIZE)? __INT_CODE_RAM_SIZE : 32K;
+__INT_DATA_RAM_BEGIN = DEFINED(__INT_DATA_RAM_BEGIN)? __INT_DATA_RAM_BEGIN : 0xd0000000;
+__INT_DATA_RAM_SIZE  = DEFINED(__INT_DATA_RAM_SIZE)? __INT_DATA_RAM_SIZE : 28K;
+/* the pcp memory description */
+__PCP_CODE_RAM_BEGIN = DEFINED(__PCP_CODE_RAM_BEGIN)? __PCP_CODE_RAM_BEGIN : 0xf0020000;
+__PCP_CODE_RAM_SIZE  = DEFINED(__PCP_CODE_RAM_SIZE)? __PCP_CODE_RAM_SIZE : 32K;
+__PCP_DATA_RAM_BEGIN = DEFINED(__PCP_DATA_RAM_BEGIN)? __PCP_DATA_RAM_BEGIN : 0xf0010000;
+__PCP_DATA_RAM_SIZE  = DEFINED(__PCP_DATA_RAM_SIZE)? __PCP_DATA_RAM_SIZE : 16K;
+
+MEMORY
+{
+  ext_cram (rx!p):	org = 0xa0000000, len = 512K
+  ext_dram (w!xp):	org = 0xa0080000, len = 512K
+  int_cram (rx!p):	org = 0xd4000000, len = 32K
+  int_dram (w!xp):	org = 0xd0000000, len = 28K
+  pcp_data (wp!x):	org = 0xf0010000, len = 32K
+  pcp_text (rxp):	org = 0xf0020000, len = 16K
+"}"
+
+
+/*
+ * Define the sizes of the user and system stacks.
+ */
+__ISTACK_SIZE = DEFINED (__ISTACK_SIZE) ? __ISTACK_SIZE : 4K ;
+__USTACK_SIZE = DEFINED (__USTACK_SIZE) ? __USTACK_SIZE : 20K ;
+
+/*
+ * The heap is the memory between the top of the user stack and
+ * __RAM_END (as defined above); programs can dynamically allocate
+ * space in this area using malloc() and various other functions.
+ * Below you can define the minimum amount of memory that the heap
+ * should provide.
+ */
+__HEAP_MIN = DEFINED (__HEAP_MIN) ? __HEAP_MIN : 64K ;
+
+}
+
+SECTIONS
+{
+  ${RELOCATING+
+  /*
+   * The startup code should be placed where the CPU expects it after a reset,
+   * so we try to locate it first, no matter where it appears in the list of
+   * objects and libraries (note: because the wildcard pattern doesn't match
+   * directories, we'll try to find crt0.o in various (sub)directories).
+   */
+  .startup :
+  {
+    KEEP (*(.startup_code))
+	. = ALIGN(8);    
+  "}" ${RELOCATING+> ext_cram =${NOP-0}}
+  }
+  ${RELOCATING+
+  /*
+   * Allocate space for absolute addressable sections; this requires that
+   * ${Q}int_dram${Q} starts at a TriCore segment (256M) and points to
+   * some RAM area!  If these conditions are not met by your particular
+   * hardware setup, you should either not use absolute data, or you
+   * must move .zdata*,.zbss*,.bdata*,.bbss* input sections to some appropriate
+   * memory area.
+   */
+  }
+  
+  ${RELOCATING-
+   .zrodata 0:
+  {
+    *(.zrodata)
+    *(.zrodata.*)
+  "}" 
+  }
+ 
+  ${RELOCATING-
+  .bbss 0 :
+  {
+	  *(.bbss)
+	  *(.bbss.*)
+  "}"
+  }
+
+ .zbss ${RELOCATING+ (NOLOAD)}${RELOCATING-0 }:
+  {
+    ${RELOCATING+ZBSS_BASE = . ;}
+    *(.zbss)
+    ${RELOCATING+*(.zbss.*)}
+    ${RELOCATING+*(.gnu.linkonce.zb.*)}
+	${RELOCATING+*(.bbss)}
+    ${RELOCATING+*(.bbss.*)}
+	${RELOCATING+. = ALIGN(8);}
+    ${RELOCATING+ZBSS_END = . ;}
+  } ${RELOCATING+> int_dram}
+
+  ${RELOCATING-
+  .bbata 0 :
+  {
+	  *(.bbata)
+	  *(.bbata.*)
+  "}"
+  }
+  
+  .zdata ${RELOCATING- 0 }:
+  {
+    ${RELOCATING+ZDATA_BASE = . ;}
+ 	${RELOCATING+*(.zrodata)}
+	${RELOCATING+*(.zrodata.*)}
+   *(.zdata)
+	${RELOCATING+*(.zdata.*)}
+    ${RELOCATING+*(.gnu.linkonce.z.*)}
+    ${RELOCATING+*(.bdata)}
+    ${RELOCATING+*(.bdata.*)}
+    ${RELOCATING+. = ALIGN(8);}
+    ${RELOCATING+ZDATA_END = . ;}
+  } ${RELOCATING+> int_dram AT> ext_cram}
+
+
+  ${RELOCATING+
+	  
+  /* define the CSA Memory area as an own section
+   * this section will be allocated into the internal RAM
+   * after the absolute addressable sections .zdata/.zbss
+   * and allocate all internal memory not occupied by .zdata/.zbss
+  */
+  .csa (NOLOAD) :
+  {
+    . = ALIGN(64);
+    __CSA_BEGIN = . ;
+    . +=  __INT_DATA_RAM_BEGIN + __INT_DATA_RAM_SIZE - ABSOLUTE(__CSA_BEGIN);
+    . = ALIGN(64);
+    __CSA_END = .;
+  "}" > int_dram
+  __CSA_SIZE = __CSA_END - __CSA_BEGIN;
+
+  /*
+   * Allocate trap and interrupt vector tables.
+   */
+  .traptab  :
+  {
+    *(.traptab)
+    . = ALIGN(8) ;
+  "}" > ext_cram
+
+  .inttab  :
+  {
+    *(.inttab)
+    . = ALIGN(8) ;
+  "}" > ext_cram
+  }
+
+  
+  
+  
+  ${RELOCATING+
+  /*
+   * Allocate .text and other read-only sections.
+   */
+  }
+  .text ${RELOCATING- 0 }:
+  {
+    ${RELOCATING+${TEXT_START_SYMBOLS}}
+    *(.text)
+    ${RELOCATING+
+	*(.text.*)
+    *(.pcp_c_ptr_init)
+    *(.pcp_c_ptr_init.*)
+    *(.gnu.linkonce.t.*)
+    /*
+     * .gnu.warning sections are handled specially by elf32.em.
+     */
+    *(.gnu.warning)
+	}
+	${RELOCATING+. = ALIGN(8);}
+  } ${RELOCATING+> ext_cram =${NOP-0}}
+
+  .rodata ${RELOCATING- 0 } :
+  {
+    *(.rodata)
+    ${RELOCATING+
+	*(.rodata.*)
+	*(.gnu.linkonce.r.*)
+    *(.rodata1)
+    *(.toc)
+    /*
+     * Create the clear and copy tables that tell the startup code
+     * which memory areas to clear and to copy, respectively.
+     */
+    . = ALIGN(4) ;
+    PROVIDE(__clear_table = .) ;
+    LONG(0 + ADDR(.bss));     LONG(SIZEOF(.bss));
+    LONG(0 + ADDR(.sbss));    LONG(SIZEOF(.sbss));
+    LONG(0 + ADDR(.zbss));    LONG(SIZEOF(.zbss));
+    LONG(-1);                 LONG(-1);
+
+    PROVIDE(__copy_table = .) ;
+    LONG(LOADADDR(.data));    LONG(0 + ADDR(.data)); LONG(SIZEOF(.data));
+    LONG(LOADADDR(.sdata));   LONG(0 + ADDR(.sdata));LONG(SIZEOF(.sdata));
+    LONG(LOADADDR(.zdata));   LONG(0 + ADDR(.zdata));LONG(SIZEOF(.zdata));
+    LONG(LOADADDR(.pcpdata)); LONG(0 + ADDR(.pcpdata)); LONG(SIZEOF(.pcpdata));
+    LONG(LOADADDR(.pcptext)); LONG(0 + ADDR(.pcptext));LONG(SIZEOF(.pcptext));
+    LONG(-1);                 LONG(-1);                  LONG(-1);
+    . = ALIGN(8);
+    }
+  } ${RELOCATING+> ext_cram}
+
+  .sdata2 ${RELOCATING- 0 }:
+  {
+    *(.sdata.rodata)
+    *(.sdata.rodata.*)
+    ${RELOCATING+. = ALIGN(8);}
+  } ${RELOCATING+> ext_cram}
+
+
+  ${RELOCATING+
+  /*
+   * C++ exception handling tables.  NOTE: gcc emits .eh_frame
+   * sections when compiling C sources with debugging enabled (-g).
+   * If you can be sure that your final application consists
+   * exclusively of C objects (i.e., no C++ objects), you may use
+   * the -R option of the ${Q}strip${Q} and ${Q}objcopy${Q} utilities to remove
+   * the .eh_frame section from the executable.
+   */
+  }
+  .eh_frame ${RELOCATING- 0 }:
+  {
+    ${RELOCATING+*(.gcc_except_table)}
+    ${RELOCATING+__EH_FRAME_BEGIN__ = . ;}
+    ${RELOCATING+KEEP (*(.eh_frame))}
+    ${RELOCATING-*(.eh_frame)}
+    ${RELOCATING+__EH_FRAME_END__ = . ;}
+	${RELOCATING+. = ALIGN(8);}
+  } ${RELOCATING+> ext_cram}
+
+  ${RELOCATING+
+  /*
+   * Constructors and destructors.
+   */
+  .ctors :
+  {
+    __CTOR_LIST__ = . ;
+    LONG((__CTOR_END__ - __CTOR_LIST__) / 4 - 2);
+    *(.ctors)
+    LONG(0) ;
+    __CTOR_END__ = . ;
+	. = ALIGN(8);
+  "}" > ext_cram
+
+  .dtors :
+  {
+    __DTOR_LIST__ = . ;
+    LONG((__DTOR_END__ - __DTOR_LIST__) / 4 - 2);
+    *(.dtors)
+    LONG(0) ;
+    __DTOR_END__ = . ;
+	. = ALIGN(8);
+  "}" > ext_cram
+
+  /*
+   * We"'"re done now with the text part of the executable.  The
+   * following sections are special in that their initial code or
+   * data (if any) must also be stored in said text part of an
+   * executable, but they ${Q}live${Q} at completely different addresses
+   * at runtime -- usually in RAM areas.  NOTE: This is not really
+   * necessary if you use a special program loader (e.g., a debugger)
+   * to load a complete executable consisting of code, data, BSS, etc.
+   * into the RAM of some target hardware or a simulator, but it *is*
+   * necessary if you want to burn your application into non-volatile
+   * memories such as EPROM or FLASH.
+   */
+  }
+
+  .pcptext${RELOCATING- 0 }:
+  {
+    ${RELOCATING+PCODE_BASE = . ;}
+    *(.pcptext)
+    ${RELOCATING+*(.pcptext.*)}
+    ${RELOCATING+. = ALIGN(8) ;}
+   ${RELOCATING+PCODE_END = . ;}
+  } ${RELOCATING+> pcp_text AT> ext_cram}
+
+  .pcpdata${RELOCATING- 0 }: 
+  {
+    ${RELOCATING+PRAM_BASE = . ;}
+    *(.pcpdata)
+    ${RELOCATING+*(.pcpdata.*)}
+    ${RELOCATING+. = ALIGN(8) ;}
+    ${RELOCATING+PRAM_END = . ;}
+  } ${RELOCATING+> pcp_data AT> ext_cram}
+
+  .data${RELOCATING- 0 }: 
+  {
+    ${RELOCATING+. = ALIGN(8) ;}
+    ${RELOCATING+DATA_BASE = . ;}
+    *(.data)
+    ${RELOCATING+*(.data.*)}
+    ${RELOCATING+*(.gnu.linkonce.d.*)}
+    ${CONSTRUCTING+SORT(CONSTRUCTORS)}
+    ${RELOCATING+. = ALIGN(8) ;}
+    ${RELOCATING+DATA_END = . ;}
+  } ${RELOCATING+> ext_dram AT> ext_cram}
+
+  .sdata ${RELOCATING- 0 }: 
+  {
+	${RELOCATING+. = ALIGN(8) ;}
+	${RELOCATING+SDATA_BASE = . ;}
+    ${RELOCATING+PROVIDE(__sdata_start = .);}
+    *(.sdata)
+    ${RELOCATING+*(.sdata.*)}
+    ${RELOCATING+*(.gnu.linkonce.s.*)}
+    ${RELOCATING+. = ALIGN(8) ;}
+  } ${RELOCATING+> ext_dram AT> ext_cram}
+
+  .sbss ${RELOCATIING+ (NOLOAD)}${RELOCATING-0 }:
+  {
+    ${RELOCATING+PROVIDE(__sbss_start = .);}
+    *(.sbss)
+    ${RELOCATING+*(.sbss.*)}
+    ${RELOCATING+*(.gnu.linkonce.sb.*)}
+    ${RELOCATING+. = ALIGN(8) ;}
+  } ${RELOCATING+> ext_dram}
+
+  ${RELOCATING+
+  /*
+   * Allocate space for BSS sections.
+   */
+  }
+  .bss ${RELOCATING+ (NOLOAD)}${RELOCATING-0 }:
+  {
+    ${RELOCATING+BSS_BASE = . ;}
+    ${RELOCATING+${OTHER_BSS_SYMBOLS}}
+    *(.bss)
+    ${RELOCATING+
+    *(.bss.*)
+    *(.gnu.linkonce.b.*)
+    *(COMMON)
+    . = ALIGN(8) ;
+    __ISTACK = . + __ISTACK_SIZE ;
+    __USTACK = __ISTACK + __USTACK_SIZE ;
+    __HEAP = __USTACK ;
+    __HEAP_END = __RAM_END ;
+    }
+  } ${RELOCATING+> ext_dram}
+  ${RELOCATING+_end = __HEAP_END ;}
+  ${RELOCATING+PROVIDE(end = _end) ;}
+
+  ${RELOCATING+
+
+  /* Make sure CSA, stack and heap addresses are properly aligned.  */
+  _. = ASSERT ((__CSA_BEGIN & 0x3f) == 0 , ${Q}illegal CSA start address${Q}) ;
+  _. = ASSERT ((__CSA_SIZE & 0x3f) == 0 , ${Q}illegal CSA size${Q}) ;
+  _. = ASSERT ((__ISTACK & 7) == 0 , ${Q}ISTACK not doubleword aligned${Q}) ;
+  _. = ASSERT ((__USTACK & 7) == 0 , ${Q}USTACK not doubleword aligned${Q}) ;
+  _. = ASSERT ((__HEAP_END & 7) == 0 , ${Q}HEAP not doubleword aligned${Q}) ;
+
+  /* Make sure enough memory is available for stacks and heap.  */
+  _. = ASSERT (__ISTACK <= __RAM_END , ${Q}not enough memory for ISTACK${Q}) ;
+  _. = ASSERT (__USTACK <= __RAM_END , ${Q}not enough memory for USTACK${Q}) ;
+  _. = ASSERT ((__HEAP_END - __HEAP) >= __HEAP_MIN ,
+               ${Q}not enough memory for HEAP${Q}) ;
+
+  /* Define a default symbol for address 0.  */
+  NULL = DEFINED (NULL) ? NULL : 0 ;
+  }
+
+  /*
+   * DWARF debug sections.
+   * Symbols in the DWARF debugging sections are relative to the
+   * beginning of the section, so we begin them at 0.
+   */
+
+  /*
+   * DWARF 1
+   */
+  .comment         0 : { *(.comment) }
+  .debug           0 : { *(.debug) }
+  .line            0 : { *(.line) }
+
+  /*
+   * GNU DWARF 1 extensions
+   */
+  .debug_srcinfo   0 : { *(.debug_srcinfo) }
+  .debug_sfnames   0 : { *(.debug_sfnames) }
+
+  /*
+   * DWARF 1.1 and DWARF 2
+   */
+  .debug_aranges   0 : { *(.debug_aranges) }
+  .debug_pubnames  0 : { *(.debug_pubnames) }
+
+  /*
+   * DWARF 2
+   */
+  .debug_info      0 : { *(.debug_info) }
+  .debug_abbrev    0 : { *(.debug_abbrev) }
+  .debug_line      0 : { *(.debug_line) }
+  .debug_frame     0 : { *(.debug_frame) }
+  .debug_str       0 : { *(.debug_str) }
+  .debug_loc       0 : { *(.debug_loc) }
+  .debug_macinfo   0 : { *(.debug_macinfo) }
+  .debug_ranges    0 : { *(.debug_ranges) }
+
+  /*
+   * SGI/MIPS DWARF 2 extensions
+   */
+  .debug_weaknames 0 : { *(.debug_weaknames) }
+  .debug_funcnames 0 : { *(.debug_funcnames) }
+  .debug_typenames 0 : { *(.debug_typenames) }
+  .debug_varnames  0 : { *(.debug_varnames) }
+
+  ${RELOCATING+
+  /*
+   * Optional sections that may only appear when relocating.
+   */
+  ${OTHER_RELOCATING_SECTIONS}
+  }
+
+  /*
+   * Optional sections that may appear regardless of relocating.
+   */
+  ${OTHER_SECTIONS}
+}
+EOF
diff --git a/opcodes/Makefile.am b/opcodes/Makefile.am
index 0e04b4c05c4..5433af57a00 100644
--- a/opcodes/Makefile.am
+++ b/opcodes/Makefile.am
@@ -251,6 +251,8 @@ TARGET_LIBOPCODES_CFILES = \
 	tilegx-opc.c \
 	tilepro-dis.c \
 	tilepro-opc.c \
+	tricore-dis.c \
+	tricore-opc.c \
 	v850-dis.c \
 	v850-opc.c \
 	vax-dis.c \
diff --git a/opcodes/Makefile.in b/opcodes/Makefile.in
index 42c15f00d30..52cc9473e7c 100644
--- a/opcodes/Makefile.in
+++ b/opcodes/Makefile.in
@@ -642,6 +642,8 @@ TARGET_LIBOPCODES_CFILES = \
 	tilegx-opc.c \
 	tilepro-dis.c \
 	tilepro-opc.c \
+	tricore-dis.c \
+	tricore-opc.c \
 	v850-dis.c \
 	v850-opc.c \
 	vax-dis.c \
@@ -1060,6 +1062,8 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tilegx-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tilepro-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tilepro-opc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tricore-dis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tricore-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/v850-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/v850-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vax-dis.Plo@am__quote@
diff --git a/opcodes/configure b/opcodes/configure
index 3513e408ce1..2a1b705ac69 100755
--- a/opcodes/configure
+++ b/opcodes/configure
@@ -12280,6 +12280,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_tic6x_arch)		ta="$ta tic6x-dis.lo" ;;
 	bfd_tilegx_arch)	ta="$ta tilegx-dis.lo tilegx-opc.lo" ;;
 	bfd_tilepro_arch)	ta="$ta tilepro-dis.lo tilepro-opc.lo" ;;
+	bfd_tricore_arch)	ta="$ta tricore-dis.lo tricore-opc.lo" ;;
 	bfd_v850_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850e_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850ea_arch)	ta="$ta v850-opc.lo v850-dis.lo" ;;
diff --git a/opcodes/configure.ac b/opcodes/configure.ac
index e564f067334..7c494459ab2 100644
--- a/opcodes/configure.ac
+++ b/opcodes/configure.ac
@@ -341,6 +341,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_tic6x_arch)		ta="$ta tic6x-dis.lo" ;;
 	bfd_tilegx_arch)	ta="$ta tilegx-dis.lo tilegx-opc.lo" ;;
 	bfd_tilepro_arch)	ta="$ta tilepro-dis.lo tilepro-opc.lo" ;;
+	bfd_tricore_arch)	ta="$ta tricore-dis.lo tricore-opc.lo" ;;
 	bfd_v850_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850e_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850ea_arch)	ta="$ta v850-opc.lo v850-dis.lo" ;;
diff --git a/opcodes/disassemble.c b/opcodes/disassemble.c
index 8590e945c58..c68707a57ba 100644
--- a/opcodes/disassemble.c
+++ b/opcodes/disassemble.c
@@ -90,6 +90,7 @@
 #define ARCH_tic6x
 #define ARCH_tilegx
 #define ARCH_tilepro
+#define ARCH_tricore
 #define ARCH_v850
 #define ARCH_vax
 #define ARCH_visium
@@ -463,6 +464,11 @@ disassembler (enum bfd_architecture a,
       disassemble = print_insn_tic6x;
       break;
 #endif
+#ifdef ARCH_tricore
+    case bfd_arch_tricore:
+      disassemble = print_insn_tricore;
+      break;
+#endif
 #ifdef ARCH_ft32
     case bfd_arch_ft32:
       disassemble = print_insn_ft32;
diff --git a/opcodes/disassemble.h b/opcodes/disassemble.h
index 8ee54dc9494..ba891315563 100644
--- a/opcodes/disassemble.h
+++ b/opcodes/disassemble.h
@@ -89,6 +89,7 @@ extern int print_insn_tic54x		(bfd_vma, disassemble_info *);
 extern int print_insn_tic6x		(bfd_vma, disassemble_info *);
 extern int print_insn_tilegx		(bfd_vma, disassemble_info *);
 extern int print_insn_tilepro		(bfd_vma, disassemble_info *);
+extern int print_insn_tricore   (bfd_vma, disassemble_info *);
 extern int print_insn_v850		(bfd_vma, disassemble_info *);
 extern int print_insn_vax		(bfd_vma, disassemble_info *);
 extern int print_insn_visium		(bfd_vma, disassemble_info *);
diff --git a/opcodes/po/POTFILES.in b/opcodes/po/POTFILES.in
index 0659b99b39b..a9c32037084 100644
--- a/opcodes/po/POTFILES.in
+++ b/opcodes/po/POTFILES.in
@@ -212,6 +212,8 @@ tilegx-dis.c
 tilegx-opc.c
 tilepro-dis.c
 tilepro-opc.c
+tricore-dis.c
+tricore-opc.c
 v850-dis.c
 v850-opc.c
 vax-dis.c
diff --git a/opcodes/tricore-dis.c b/opcodes/tricore-dis.c
new file mode 100644
index 00000000000..d8ba0480c8f
--- /dev/null
+++ b/opcodes/tricore-dis.c
@@ -0,0 +1,1948 @@
+/* Disassemble TriCore and PCP instructions.
+   Copyright (C) 1998-2003 Free Software Foundation, Inc.
+   Contributed by Michael Schumacher (mike@hightec-rt.com).
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "sysdep.h"
+
+#include "ansidecl.h"
+#include "elf/tricore.h"
+#include "opcode/tricore.h"
+#include "dis-asm.h"
+#include "libiberty.h"
+
+#define NUMOPCS tricore_numopcodes
+#define NUMSFRS tricore_numsfrs
+#define NUMPCPOPCS pcp_numopcodes
+#define MAX_OPS 5
+#define MATCHES_ISA(isa) \
+	  (((isa) == TRICORE_GENERIC) \
+	   || ((isa & TRICORE_ISA_MASK) & current_isa))
+
+#define NUMBER_OF_A_REGS	16
+
+/* Some handy shortcuts.  */
+
+typedef struct tricore_opcode opcode_t;
+typedef struct pcp_opcode pcp_opcode_t;
+typedef const struct tricore_core_register sfr_t;
+
+/* For faster lookup, we hash instruction opcodes and SFRs.  */
+
+struct insnlist
+{
+  opcode_t *code;
+  struct insnlist *next;
+};
+
+/* TriCore insns have only 6 significant bits (because of the 16-bit
+   SRRS format), so the hash table needs being restricted to 64 entries.  */
+
+static struct insnlist *insns[64];
+static struct insnlist *insnlink;
+
+/* PCP insns have only 5 significant bits (because of encoding group 0).  */
+
+struct pcplist
+{
+  pcp_opcode_t *code;
+  struct pcplist *next;
+};
+
+static struct pcplist *pcpinsns[32];
+static struct pcplist *pcplink;
+
+/* The hash key for SFRs is their LSB.  */
+
+struct sfrlist
+{
+  sfr_t *sfr;
+  struct sfrlist *next;
+};
+
+static struct sfrlist *sfrs[256];
+static struct sfrlist *sfrlink;
+
+/* 1 if the hash tables are initialized.  */
+
+static int initialized = 0;
+
+/* Which TriCore instruction set architecture are we dealing with?  */
+
+static tricore_isa current_isa = TRICORE_V1_2;
+
+/* If we can find the instruction matching a given opcode, we decode
+   its operands and store them in the following structure.  */
+
+struct decoded_insn
+{
+  opcode_t *code;
+  unsigned long opcode;
+  int regs[MAX_OPS];
+  unsigned long cexp[MAX_OPS];
+};
+
+static struct decoded_insn dec_insn;
+
+/* Forward declarations of decoding functions.  */
+
+static void decode_abs (void);
+static void decode_absb (void);
+static void decode_b (void);
+static void decode_bit (void);
+static void decode_bo (void);
+static void decode_bol (void);
+static void decode_brc (void);
+static void decode_brn (void);
+static void decode_brr (void);
+static void decode_rc (void);
+static void decode_rcpw (void);
+static void decode_rcr (void);
+static void decode_rcrr (void);
+static void decode_rcrw (void);
+static void decode_rlc (void);
+static void decode_rr (void);
+static void decode_rr1 (void);
+static void decode_rr2 (void);
+static void decode_rrpw (void);
+static void decode_rrr (void);
+static void decode_rrr1 (void);
+static void decode_rrr2 (void);
+static void decode_rrrr (void);
+static void decode_rrrw (void);
+static void decode_sys (void);
+static void decode_sb (void);
+static void decode_sbc (void);
+static void decode_sbr (void);
+static void decode_sbrn (void);
+static void decode_sc (void);
+static void decode_slr (void);
+static void decode_slro (void);
+static void decode_sr (void);
+static void decode_src (void);
+static void decode_sro (void);
+static void decode_srr (void);
+static void decode_srrs (void);
+static void decode_ssr (void);
+static void decode_ssro (void);
+
+/* Array of function pointers to decoding functions.  */
+
+static void (*decode[]) (void) =
+{
+  /* 32-bit formats.  */
+  decode_abs, decode_absb, decode_b, decode_bit, decode_bo, decode_bol,
+  decode_brc, decode_brn, decode_brr, decode_rc, decode_rcpw, decode_rcr,
+  decode_rcrr, decode_rcrw, decode_rlc, decode_rr, decode_rr1, decode_rr2,
+  decode_rrpw, decode_rrr, decode_rrr1, decode_rrr2, decode_rrrr,
+  decode_rrrw, decode_sys,
+
+  /* 16-bit formats.  */
+  decode_sb, decode_sbc, decode_sbr, decode_sbrn, decode_sc, decode_slr,
+  decode_slro, decode_sr, decode_src, decode_sro, decode_srr,
+  decode_srrs, decode_ssr, decode_ssro
+};
+
+/* More forward declarations.  */
+
+static unsigned long extract_off18 (void);
+static void init_hash_tables (void);
+static const char *find_core_reg (unsigned long);
+static void print_decoded_insn (bfd_vma, struct disassemble_info *);
+static int decode_tricore_insn (bfd_vma, unsigned long, int,
+					struct disassemble_info *);
+static int decode_pcp_insn (bfd_vma, bfd_byte [4],
+				    struct disassemble_info *);
+int print_insn_tricore (bfd_vma, struct disassemble_info *);
+
+/* Here come the decoding functions.  If you thought that the encoding
+   functions in the assembler were somewhat, umm,  boring, you should
+   take a serious look at their counterparts below.  They're even more so!
+   *yawn*   */
+
+static unsigned long
+extract_off18 ()
+{
+  unsigned long o1, o2, o3, o4;
+  unsigned long val = dec_insn.opcode;
+
+  o1 = (val & 0x003f0000) >> 16;
+  o2 = (val & 0xf0000000) >> 22;
+  o3 = (val & 0x03c00000) >> 12;
+  o4 = (val & 0x0000f000) << 2;
+  return o1 | o2 | o3 | o4;
+}
+
+static void
+decode_abs ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_ABS_OFF18:
+        dec_insn.cexp[i] = extract_off18 ();
+        break;
+
+      case FMT_ABS_S1_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_absb ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_ABSB_OFF18:
+        dec_insn.cexp[i] = extract_off18 ();
+        break;
+
+      case FMT_ABSB_B:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x800) >> 11;
+	break;
+
+      case FMT_ABSB_BPOS3:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x700) >> 8;
+	break;
+      }
+}
+
+static void
+decode_b ()
+{
+  int i;
+  unsigned long o1, o2;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_B_DISP24:
+        o1 = (dec_insn.opcode & 0xffff0000) >> 16;
+	o2 = (dec_insn.opcode & 0x0000ff00) << 8;
+	dec_insn.cexp[i] = o1 | o2;
+	break;
+      }
+}
+
+static void
+decode_bit ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_BIT_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_BIT_P2:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x0f800000) >> 23;
+	break;
+
+      case FMT_BIT_P1:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x001f0000) >> 16;
+        break;
+
+      case FMT_BIT_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_BIT_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_bo ()
+{
+  int i;
+  unsigned long o1, o2;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_BO_OFF10:
+        o1 = (dec_insn.opcode & 0x003f0000) >> 16;
+	o2 = (dec_insn.opcode & 0xf0000000) >> 22;
+	dec_insn.cexp[i] = o1 | o2;
+        break;
+
+      case FMT_BO_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_BO_S1_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_bol ()
+{
+  int i;
+  unsigned long o1, o2, o3;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_BOL_OFF16:
+        o1 = (dec_insn.opcode & 0x003f0000) >> 16;
+	o2 = (dec_insn.opcode & 0xf0000000) >> 22;
+	o3 = (dec_insn.opcode & 0x0fc00000) >> 12;
+	dec_insn.cexp[i] = o1 | o2 | o3;
+        break;
+
+      case FMT_BOL_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_BOL_S1_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_brc ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_BRC_DISP15:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x7fff0000) >> 16;
+	break;
+
+      case FMT_BRC_CONST4:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_BRC_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_brn ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_BRN_DISP15:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x7fff0000) >> 16;
+	break;
+
+      case FMT_BRN_N:
+        dec_insn.cexp[i] =  (dec_insn.opcode & 0x0000f000) >> 12;
+	dec_insn.cexp[i] |= (dec_insn.opcode & 0x00000080) >> 3;
+	break;
+
+      case FMT_BRN_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_brr ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_BRR_DISP15:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x7fff0000) >> 16;
+	break;
+
+      case FMT_BRR_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_BRR_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rc ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RC_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RC_CONST9:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x001ff000) >> 12;
+	break;
+
+      case FMT_RC_CONST10:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x003ff000) >> 12;
+        break;
+
+      case FMT_RC_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+      }
+}
+
+static void
+decode_rcpw ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RCPW_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RCPW_P:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x0f800000) >> 23;
+	break;
+
+      case FMT_RCPW_W:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x001f0000) >> 16;
+	break;
+
+      case FMT_RCPW_CONST4:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_RCPW_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rcr ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RCR_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RCR_S3:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f000000) >> 24;
+	break;
+
+      case FMT_RCR_CONST9:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x001ff000) >> 12;
+	break;
+
+      case FMT_RCR_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rcrr ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RCRR_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RCRR_S3:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f000000) >> 24;
+	break;
+
+      case FMT_RCRR_CONST4:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_RCRR_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rcrw ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RCRW_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RCRW_S3:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f000000) >> 24;
+	break;
+
+      case FMT_RCRW_W:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x001f0000) >> 16;
+	break;
+
+      case FMT_RCRW_CONST4:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_RCRW_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rlc ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RLC_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RLC_CONST16:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x0ffff000) >> 12;
+	break;
+
+      case FMT_RLC_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rr ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RR_D:
+	dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RR_N:
+	dec_insn.cexp[i] = (dec_insn.opcode & 0x00030000) >> 16;
+	break;
+
+      case FMT_RR_S2:
+	dec_insn.regs[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_RR_S1:
+	dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+
+      case FMT_RR_D_S1:
+	dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rr1 ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RR1_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RR1_N:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x00030000) >> 16;
+	break;
+
+      case FMT_RR1_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_RR1_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rr2 ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RR2_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RR2_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_RR2_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rrpw ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RRPW_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RRPW_P:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x0f800000) >> 23;
+	break;
+
+      case FMT_RRPW_W:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x001f0000) >> 16;
+	break;
+
+      case FMT_RRPW_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_RRPW_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rrr ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RRR_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RRR_S3:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f000000) >> 24;
+	break;
+
+      case FMT_RRR_N:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x00030000) >> 16;
+	break;
+
+      case FMT_RRR_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_RRR_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rrr1 ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RRR1_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RRR1_S3:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f000000) >> 24;
+	break;
+
+      case FMT_RRR1_N:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x00030000) >> 16;
+	break;
+
+      case FMT_RRR1_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_RRR1_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rrr2 ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RRR2_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RRR2_S3:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f000000) >> 24;
+	break;
+
+      case FMT_RRR2_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_RRR2_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rrrr ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RRRR_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RRRR_S3:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f000000) >> 24;
+	break;
+
+      case FMT_RRRR_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_RRRR_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_rrrw ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_RRRW_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf0000000) >> 28;
+	break;
+
+      case FMT_RRRW_S3:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f000000) >> 24;
+	break;
+
+      case FMT_RRRW_W:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x001f0000) >> 16;
+	break;
+
+      case FMT_RRRW_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0000f000) >> 12;
+	break;
+
+      case FMT_RRRW_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_sys ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SYS_S1_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x00000f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_sb ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SB_DISP8:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0xff00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_sbc ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SBC_CONST4:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0xf000) >> 12;
+	break;
+
+      case FMT_SBC_DISP4:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x0f00) >> 8;
+        if (dec_insn.code->args[i] == 'x')
+          dec_insn.cexp[i] += (dec_insn.opcode & 0x80) ? 0x10 : 0;
+	break;
+      }
+}
+
+static void
+decode_sbr ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SBR_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf000) >> 12;
+	break;
+
+      case FMT_SBR_DISP4:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x0f00) >> 8;
+        if (dec_insn.code->args[i] == 'x')
+          dec_insn.cexp[i] += (dec_insn.opcode & 0x80) ? 0x10 : 0;
+	break;
+      }
+}
+
+static void
+decode_sbrn ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SBRN_N:
+	if (dec_insn.code->args[i] == '5')
+	  {
+            dec_insn.cexp[i] =  (dec_insn.opcode & 0xf000) >> 12;
+	    dec_insn.cexp[i] |= (dec_insn.opcode & 0x0080) >> 3;
+	  }
+	else
+          dec_insn.cexp[i] =  (dec_insn.opcode & 0xf000) >> 12;
+	break;
+
+      case FMT_SBRN_DISP4:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x0f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_sc ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SC_CONST8:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0xff00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_slr ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SLR_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf000) >> 12;
+	break;
+
+      case FMT_SLR_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_slro ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SLRO_OFF4:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0xf000) >> 12;
+	break;
+
+      case FMT_SLRO_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_sr ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SR_S1_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_src ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SRC_CONST4:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0xf000) >> 12;
+	break;
+
+      case FMT_SRC_S1_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_sro ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SRO_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf000) >> 12;
+	break;
+
+      case FMT_SRO_OFF4:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x0f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_srr ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SRR_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf000) >> 12;
+	break;
+
+      case FMT_SRR_S1_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_srrs ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SRRS_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf000) >> 12;
+	break;
+
+      case FMT_SRRS_S1_D:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f00) >> 8;
+	break;
+
+      case FMT_SRRS_N:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0x00c0) >> 6;
+	break;
+      }
+}
+
+static void
+decode_ssr ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SSR_S2:
+        dec_insn.regs[i] = (dec_insn.opcode & 0xf000) >> 12;
+	break;
+
+      case FMT_SSR_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f00) >> 8;
+	break;
+      }
+}
+
+static void
+decode_ssro ()
+{
+  int i;
+
+  for (i = 0; i < dec_insn.code->nr_operands; ++i)
+    switch (dec_insn.code->fields[i])
+      {
+      case FMT_SSRO_OFF4:
+        dec_insn.cexp[i] = (dec_insn.opcode & 0xf000) >> 12;
+	break;
+
+      case FMT_SSRO_S1:
+        dec_insn.regs[i] = (dec_insn.opcode & 0x0f00) >> 8;
+	break;
+      }
+}
+
+/* Initialize the hash tables for instructions and SFRs.  */
+
+static void
+init_hash_tables ()
+{
+  opcode_t *pop;
+  pcp_opcode_t *ppop;
+  sfr_t *psfr;
+  int i, idx;
+
+  insnlink = (struct insnlist *) xmalloc (NUMOPCS * sizeof (struct insnlist));
+  pcplink = (struct pcplist *) xmalloc (NUMPCPOPCS * sizeof (struct pcplist));
+  sfrlink = (struct sfrlist *) xmalloc (NUMSFRS * sizeof (struct sfrlist));
+  memset ((char *) insns, 0, sizeof (insns));
+  memset ((char *) insnlink, 0, NUMOPCS * sizeof (struct insnlist));
+  memset ((char *) pcpinsns, 0, sizeof (pcpinsns));
+  memset ((char *) pcplink, 0, NUMPCPOPCS * sizeof (struct pcplist));
+  memset ((char *) sfrs, 0, sizeof (sfrs));
+  memset ((char *) sfrlink, 0, NUMSFRS * sizeof (struct sfrlist));
+
+  for (i = 0, pop = tricore_opcodes; i < NUMOPCS; ++i, ++pop)
+    {
+      if (!MATCHES_ISA (pop->isa))
+        continue;
+
+      idx = pop->opcode & 0x3f;
+      if (insns[idx])
+	insnlink[i].next = insns[idx];
+      insns[idx] = &insnlink[i];
+      insnlink[i].code = pop;
+    }
+
+  for (i = 0, ppop = pcp_opcodes; i < NUMPCPOPCS; ++i, ++ppop)
+    {
+      idx = (ppop->opcode >> 11) & 0x1f;
+      if (pcpinsns[idx])
+        pcplink[i].next = pcpinsns[idx];
+      pcpinsns[idx] = &pcplink[i];
+      pcplink[i].code = ppop;
+    }
+
+  for (i = 0, psfr = tricore_sfrs; i < NUMSFRS; ++i, ++psfr)
+    {
+      if (!MATCHES_ISA (psfr->isa))
+        continue;
+
+      idx = psfr->addr & 0xff;
+      if (sfrs[idx])
+        sfrlink[i].next = sfrs[idx];
+      sfrs[idx] = &sfrlink[i];
+      sfrlink[i].sfr = psfr;
+    }
+}
+
+/* Return the name of the core register (SFR) located at offset ADDR.  */
+
+static const char *
+find_core_reg (addr)
+     unsigned long addr;
+{
+  struct sfrlist *psfr;
+  int idx = addr & 0xff;
+
+  for (psfr = sfrs[idx]; psfr != NULL; psfr = psfr->next)
+    if ((psfr->sfr->addr == addr) && MATCHES_ISA (psfr->sfr->isa))
+      return psfr->sfr->name;
+
+  return (char *) 0;
+}
+
+/* Print the decoded TriCore instruction starting at MEMADDR.  */
+
+static void
+print_decoded_insn (memaddr, info)
+     bfd_vma memaddr;
+     struct disassemble_info *info;
+{
+  opcode_t *insn = dec_insn.code;
+  int i, needs_creg = 0, need_comma;
+  const char *creg;
+  bfd_vma abs;
+  static bfd_vma next_addr = 0;
+  static int expect_lea = 0;
+  static int load_areg[NUMBER_OF_A_REGS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+  static unsigned long load_hi_addr[NUMBER_OF_A_REGS] = {0};
+  static unsigned long load_addr = 0;
+  static int print_symbolic_address = 0;
+
+  /* Special cases: "nor %dn" / "nor %dn,%dn,0" -> "not %dn"  */
+  if (((*insn->name == 'n') && !strcmp (insn->name, "nor"))
+      && ((insn->nr_operands == 1)
+          || ((insn->nr_operands == 3)
+	      && (insn->args[2] == 'n')
+              && (dec_insn.regs[0] == dec_insn.regs[1])
+	      && (dec_insn.cexp[2] == 0))))
+    {
+      info->fprintf_func (info->stream, "not %%d%d", dec_insn.regs[0]);
+      return;
+    }
+  else
+    info->fprintf_func (info->stream, "%s ", insn->name);
+
+  /* Being a child of the RISC generation, a TriCore-based CPU generally
+     must load a 32-bit wide address in two steps, usually by executing
+     an instruction sequence like "movh.a %an,hi:sym; lea %am,[%an]lo:sym"
+     (an optimizing compiler performing instruction scheduling, such as
+     GCC, may insert other instructions between "movh.a" and "lea", but
+     that doesn't matter at all, because it doesn't change the execution
+     order of the two instructions, and this function can only disassemble
+     a single instruction at a time, anyway).  We would like to see which
+     address is being loaded (or, more precisely, which symbol lives at
+     the address being loaded), so we keep track of "movh.a" and "lea"
+     instructions, and print the symbolic address after a "lea" insn
+     if we can be reasonably sure that it is part of the load sequence
+     described above.  Note that "lea" is used here as a generic insn;
+     it actually may also be any load or store instruction.  */
+  if (memaddr != next_addr)
+    expect_lea = print_symbolic_address = 0;
+  next_addr = memaddr + (insn->len32 ? 4 : 2);
+
+  if (!strcmp (insn->name, "movh.a"))
+    {
+      load_areg[dec_insn.regs[0]] = 1;
+      load_hi_addr[dec_insn.regs[0]] = dec_insn.cexp[1] << 16;
+      expect_lea = 1;
+      print_symbolic_address = 0;
+    }
+  else if (0 != expect_lea
+	   && (!strcmp (insn->name, "lea")
+	       || !strncmp (insn->name, "ld.", 3)
+	       || !strncmp (insn->name, "st.", 3)
+	       || !strncmp (insn->name, "swap", 4)
+	       || !strcmp (insn->name, "ldmst")))
+    {
+      if (insn->nr_operands == 3)
+	{
+	  if ((!strcmp (insn->name, "lea")
+	       || !strncmp (insn->name, "ld.", 3)
+	       || !strcmp (insn->name, "ldmst"))
+		 ) {
+	     if ((0 != load_areg[dec_insn.regs[1]]))
+	    {
+	      load_addr = load_hi_addr[dec_insn.regs[1]] + (short) dec_insn.cexp[2];
+	      print_symbolic_address = 1;
+	    }
+      }
+	  else if (0 != load_areg[dec_insn.regs[0]])
+	    {
+	      load_addr = load_hi_addr[dec_insn.regs[0]] + (short) dec_insn.cexp[1];
+	      print_symbolic_address = 1;
+	    }
+	}
+    }
+  else
+    print_symbolic_address = 0;
+
+  if (!strncmp(insn->name,"ld.a",4))
+		load_areg[dec_insn.regs[0]] = 0;
+  else
+  if (!strncmp(insn->name,"add.a",5)
+	|| !strncmp(insn->name,"sub.a",5)
+	|| !strcmp(insn->name,"mov.a")
+	|| !strncmp(insn->name,"addsc.a",7))
+		load_areg[dec_insn.regs[0]] = 0;
+  else
+  if (!strcmp(insn->name,"mov.aa"))
+	load_areg[dec_insn.regs[0]] = load_areg[dec_insn.regs[1]];
+  else
+  if (!strncmp(insn->name,"call",4)) {
+	for (i = 2; i < 8; i++)
+		load_areg[i] = 0;
+  }
+  else
+  if (!strncmp(insn->name,"ret",3)) {
+	for (i = 2; i < 8; i++)
+		load_areg[i] = 0;
+	for (i = 10; i < 16; i++)
+		load_areg[i] = 0;
+  }
+
+
+  if (!strcmp (insn->name, "mfcr") || !strcmp (insn->name, "mtcr"))
+    needs_creg = 1;
+
+  for (i = 0; i < insn->nr_operands; ++i)
+    {
+      need_comma = (i < (insn->nr_operands - 1));
+      switch (insn->args[i])
+        {
+	case 'd':
+	  info->fprintf_func (info->stream, "%%d%d", dec_insn.regs[i]);
+	  break;
+
+	case 'g':
+	  info->fprintf_func (info->stream, "%%d%dl", dec_insn.regs[i]);
+	  break;
+
+	case 'G':
+	  info->fprintf_func (info->stream, "%%d%du", dec_insn.regs[i]);
+	  break;
+
+	case '-':
+	  info->fprintf_func (info->stream, "%%d%dll", dec_insn.regs[i]);
+	  break;
+
+	case '+':
+	  info->fprintf_func (info->stream, "%%d%duu", dec_insn.regs[i]);
+	  break;
+
+	case 'l':
+	  info->fprintf_func (info->stream, "%%d%dlu", dec_insn.regs[i]);
+	  break;
+
+	case 'L':
+	  info->fprintf_func (info->stream, "%%d%dul", dec_insn.regs[i]);
+	  break;
+
+	case 'D':
+	  info->fprintf_func (info->stream, "%%e%d", dec_insn.regs[i]);
+	  break;
+
+	case 'i':
+	  info->fprintf_func (info->stream, "%%d15");
+	  break;
+
+	case 'a':
+	case 'A':
+	  if (dec_insn.regs[i] == 10) {
+	    info->fprintf_func (info->stream, "%%sp");
+ 	  }
+	  else
+	    info->fprintf_func (info->stream, "%%a%d", dec_insn.regs[i]);
+	  break;
+
+	case 'I':
+	  info->fprintf_func (info->stream, "%%a15");
+	  break;
+
+	case 'P':
+	  info->fprintf_func (info->stream, "%%sp");
+	  break;
+
+	case 'k':
+        case '6':
+	  dec_insn.cexp[i] <<= 1;
+	  /* Fall through. */
+	case 'v':
+	  dec_insn.cexp[i] <<= 1;
+	  /* Fall through. */
+	case '1':
+	case '2':
+	case '3':
+	case 'f':
+	case '5':
+	case '8':
+	case 'h':
+	case 'n':
+	case 'M':
+	  info->fprintf_func (info->stream, "%lu", dec_insn.cexp[i]);
+	  break;
+
+	case '4':
+	  if (dec_insn.cexp[i] & 0x8)
+	    dec_insn.cexp[i] |= ~0xf;
+	  info->fprintf_func (info->stream, "%ld", dec_insn.cexp[i]);
+	  break;
+
+	case 'F':
+	  if (dec_insn.cexp[i] & 0x10)
+	    dec_insn.cexp[i] |= ~0x1f;
+	  info->fprintf_func (info->stream, "%ld", dec_insn.cexp[i]);
+	  break;
+
+	case '9':
+	  if (dec_insn.cexp[i] & 0x100)
+	    dec_insn.cexp[i] |= ~0x1ff;
+	  info->fprintf_func (info->stream, "%ld", dec_insn.cexp[i]);
+	  break;
+
+	case '0':
+	  if (dec_insn.cexp[i] & 0x200)
+	    dec_insn.cexp[i] |= ~0x3ff;
+	  info->fprintf_func (info->stream, "%ld", dec_insn.cexp[i]);
+	  if (0 != print_symbolic_address)
+	    {
+	      info->fprintf_func (info->stream, " <");
+	      (*info->print_address_func) (load_addr, info);
+	      info->fprintf_func (info->stream, ">");
+	    }
+	  break;
+
+	case 'w':
+	  if (dec_insn.cexp[i] & 0x8000)
+	    dec_insn.cexp[i] |= ~0xffff;
+	  info->fprintf_func (info->stream, "%ld", dec_insn.cexp[i]);
+	  if (0 != print_symbolic_address)
+	    {
+	      info->fprintf_func (info->stream, " <");
+	      (*info->print_address_func) (load_addr, info);
+	      info->fprintf_func (info->stream, ">");
+	    }
+	  break;
+
+	case 't':
+	  abs =  (dec_insn.cexp[i] & 0x00003fff);
+	  abs |= (dec_insn.cexp[i] & 0x0003c000) << 14;
+	  (*info->print_address_func) (abs, info);
+	  break;
+
+	case 'T':
+	  abs =  (dec_insn.cexp[i] & 0x000fffff) << 1;
+	  abs |= (dec_insn.cexp[i] & 0x00f00000) << 8;
+	  (*info->print_address_func) (abs, info);
+	  break;
+
+	case 'o':
+	  if (dec_insn.cexp[i] & 0x4000)
+	    dec_insn.cexp[i] |= ~0x7fff;
+	  abs = (dec_insn.cexp[i] << 1) + memaddr;
+	  (*info->print_address_func) (abs, info);
+	  break;
+
+	case 'O':
+	  if (dec_insn.cexp[i] & 0x800000)
+	    dec_insn.cexp[i] |= ~0xffffff;
+	  abs = (dec_insn.cexp[i] << 1) + memaddr;
+	  (*info->print_address_func) (abs, info);
+	  break;
+
+	case 'R':
+	  if (dec_insn.cexp[i] & 0x80)
+	    dec_insn.cexp[i] |= ~0xff;
+	  abs = (dec_insn.cexp[i] << 1) + memaddr;
+	  (*info->print_address_func) (abs, info);
+	  break;
+
+	case 'r':
+	  dec_insn.cexp[i] |= ~0xf;
+	  /* Fall through. */
+	case 'm':
+	case 'x':
+	  abs = (dec_insn.cexp[i] << 1) + memaddr;
+	  (*info->print_address_func) (abs, info);
+	  break;
+
+	case 'c':
+	  needs_creg = 1;
+	  /* Fall through. */
+	case 'W':
+	  if (needs_creg)
+	    {
+	      creg = find_core_reg (dec_insn.cexp[i]);
+	      if (creg)
+	        info->fprintf_func (info->stream, "%s", creg);
+	      else
+	        info->fprintf_func (info->stream, "$0x%04lx (unknown SFR)", dec_insn.cexp[i]);
+	    }
+	  else
+	    info->fprintf_func (info->stream, "%ld", dec_insn.cexp[i]);
+	  break;
+
+	case '&':
+	  dec_insn.regs[i] = 10;
+	  /* Fall through. */
+	case '@':
+	  if (dec_insn.regs[i] == 10)
+	    info->fprintf_func (info->stream, "[%%sp]");
+	  else
+	    info->fprintf_func (info->stream, "[%%a%d]", dec_insn.regs[i]);
+	  if (need_comma)
+	    {
+	      if ((insn->args[i+1] == 'a') || (insn->args[i+1] == 'd'))
+	        need_comma = 1;
+	      else
+	        need_comma = 0;
+	    }
+	  break;
+
+	case '<':
+	  if (dec_insn.regs[i] == 10)
+	    info->fprintf_func (info->stream, "[+%%sp]");
+	  else
+	    info->fprintf_func (info->stream, "[+%%a%d]", dec_insn.regs[i]);
+	  need_comma = 0;
+	  break;
+
+	case '>':
+	  if (dec_insn.regs[i] == 10)
+	    info->fprintf_func (info->stream, "[%%sp+]");
+	  else
+	    info->fprintf_func (info->stream, "[%%a%d+]", dec_insn.regs[i]);
+	  if (need_comma)
+	    {
+	      if ((insn->args[i+1] == 'a') || (insn->args[i+1] == 'd'))
+	        need_comma = 1;
+	      else
+	        need_comma = 0;
+	    }
+	  break;
+
+	case '*':
+	  if (dec_insn.regs[i] == 10)
+	    info->fprintf_func (info->stream, "[%%sp+c]");
+	  else
+	    info->fprintf_func (info->stream, "[%%a%d+c]", dec_insn.regs[i]);
+	  need_comma = 0;
+	  break;
+
+	case '#':
+	  if (dec_insn.regs[i] == 10)
+	    info->fprintf_func (info->stream, "[%%sp+r]");
+	  else
+	    info->fprintf_func (info->stream, "[%%a%d+r]", dec_insn.regs[i]);
+	  break;
+
+	case '?':
+	  if (dec_insn.regs[i] == 10)
+	    info->fprintf_func (info->stream, "[%%sp+i]");
+	  else
+	    info->fprintf_func (info->stream, "[%%a%d+i]", dec_insn.regs[i]);
+	  break;
+
+	case 'S':
+	  info->fprintf_func (info->stream, "[%%a15]");
+	  need_comma = 0;
+	  break;
+	}
+
+      if (need_comma)
+        info->fprintf_func (info->stream, ",");
+    }
+}
+
+/* Decode the (LEN32 ? 32 : 16)-bit instruction located at MEMADDR.
+   INSN already contains its bytes in the correct order, and INFO
+   contains (among others) pointers to functions for printing the
+   decoded insn.  Return the number of actually decoded bytes.  */
+
+static int
+decode_tricore_insn (memaddr, insn, len32, info)
+     bfd_vma memaddr;
+     unsigned long insn;
+     int len32;
+     struct disassemble_info *info;
+{
+  int idx = insn & 0x3f;
+  struct insnlist *pinsn;
+  unsigned long mask;
+  tricore_fmt fmt;
+
+  /* Try to find the instruction matching the given opcode.  */
+  for (pinsn = insns[idx]; pinsn != NULL; pinsn = pinsn->next)
+    {
+      if ((pinsn->code->len32 != len32)
+          || (insn & pinsn->code->lose))
+        continue;
+
+      fmt = pinsn->code->format;
+      mask = tricore_opmask[fmt];
+      if ((insn & mask) != pinsn->code->opcode)
+        continue;
+
+      /* A valid instruction was found.  Go print it. */
+      dec_insn.code = pinsn->code;
+      dec_insn.opcode = insn;
+      decode[fmt] ();
+      print_decoded_insn (memaddr, info);
+      return len32 ? 4 : 2;
+    }
+
+  /* Oops -- this isn't a valid TriCore insn!  Since we know that
+     MEMADDR is an even address (otherwise it already would have
+     been handled by print_insn_tricore below) and that TriCore
+     insns can only start at even addresses, we just print the
+     lower 16 bits of INSN as a .hword pseudo-opcode and return 2,
+     no matter what LEN32 says.  */
+  (*info->fprintf_func) (info->stream, ".hword 0x%04lx", (insn & 0xffff));
+
+  return 2;
+}
+
+/* Decode the PCP instruction located at MEMADDR.  Its first two bytes
+   are already stored in BUFFER.  INFO contains (among others) pointers
+   to functions for printing the decoded insn.  Return the number of
+   actually decoded bytes (2 or 4).  */
+
+static int
+decode_pcp_insn (memaddr, buffer, info)
+     bfd_vma memaddr;
+     bfd_byte buffer[4];
+     struct disassemble_info *info;
+{
+  unsigned long insn = 0, insn2 = 0, val;
+  int idx, fail, rb, ra;
+  struct pcplist *pinsn;
+  pcp_opcode_t *pop = (pcp_opcode_t *) NULL;
+  static const char *pcp_ccodes[] =
+  {
+    "uc", "z", "nz", "v", "c/ult", "ugt", "slt", "sgt",    /* CONDCA  */
+    "n", "nn", "nv", "nc/uge", "sge", "sle", "cnz", "cnn"  /* CONDCB  */
+  };
+
+  /* Try to find the PCP instruction matching the given opcode.  */
+  insn = bfd_getl16 (buffer);
+  idx = (insn >> 11) & 0x1f;
+  for (pinsn = pcpinsns[idx]; pinsn != NULL; pinsn = pinsn->next)
+    {
+      if (((insn & pinsn->code->opcode) != pinsn->code->opcode)
+          || (insn & pinsn->code->lose))
+        continue;
+
+      /* A valid instruction was found.  */
+      pop = pinsn->code;
+      if (pop->len32)
+        {
+	  /* This is a 32-bit insn; try to read 2 more bytes.  */
+          fail = (*info->read_memory_func) (memaddr + 2, &buffer[2], 2, info);
+          if (fail)
+            {
+              info->fprintf_func (info->stream, ".hword 0x%04lx", insn);
+	      return 2;
+	    }
+	  insn2 = bfd_getl16 (buffer + 2);
+	}
+
+      break;
+    }
+
+  if (pop == NULL)
+    {
+      /* No valid instruction was found; print it as a 16-bit word.  */
+      info->fprintf_func (info->stream, ".hword 0x%04lx", (insn & 0xffff));
+
+      return 2;
+    }
+
+  /* Print the instruction.  */
+  info->fprintf_func (info->stream, "%s  ", pop->name);
+  switch (pop->fmt_group)
+    {
+    case 0:
+      for (idx = 0; idx < pop->nr_operands; ++idx)
+        {
+	  switch (pop->args[idx])
+	    {
+	    case 'd':
+	      val = (insn >> 9) & 0x3;
+	      if (val == 0)
+	        info->fprintf_func (info->stream, "dst");
+	      else if (val == 1)
+	        info->fprintf_func (info->stream, "dst+");
+	      else if (val == 2)
+	        info->fprintf_func (info->stream, "dst-");
+	      else
+	        info->fprintf_func (info->stream, "dst *ILLEGAL*");
+	      break;
+
+	    case 's':
+	      val = (insn >> 7) & 0x3;
+	      if (val == 0)
+	        info->fprintf_func (info->stream, "src");
+	      else if (val == 1)
+	        info->fprintf_func (info->stream, "src+");
+	      else if (val == 2)
+	        info->fprintf_func (info->stream, "src-");
+	      else
+	        info->fprintf_func (info->stream, "src *ILLEGAL*");
+	      break;
+
+	    case 'c':
+	      val = (insn >> 5) & 0x3;
+	      info->fprintf_func (info->stream, "cnc=%d", (int)val);
+	      break;
+
+	    case 'n':
+	      if (!strcmp (pop->name, "copy"))
+		val = ((insn >> 2) & 0x7) + 1;
+	      else
+	        {
+		  val = (insn >> 2) & 0x3;
+		  if (val == 0)
+		    val = 8;
+		  else if (val == 3)
+		    val = 4;
+		}
+	      info->fprintf_func (info->stream, "cnt0=%d", (int)val);
+	      break;
+
+	    case 'f':
+	      val = 8 << (insn & 0x3);
+	      info->fprintf_func (info->stream, "size=%d", (int)val);
+	      break;
+
+	    case 'a':
+	    case 'b':
+	      val = insn & 0xf;
+	      info->fprintf_func (info->stream, "cc_%s", pcp_ccodes[val]);
+	      break;
+
+	    case 'g':
+	      val = (insn >> 10) & 0x1;
+	      info->fprintf_func (info->stream, "st=%d", (int)val);
+	      break;
+
+	    case 'i':
+	      val = (insn >> 9) & 0x1;
+	      info->fprintf_func (info->stream, "int=%d", (int)val);
+	      break;
+
+	    case 'j':
+	      val = (insn >> 8) & 0x1;
+	      info->fprintf_func (info->stream, "ep=%d", (int)val);
+	      break;
+
+	    case 'h':
+	      val = (insn >> 7) & 0x1;
+	      info->fprintf_func (info->stream, "ec=%d", (int)val);
+	      break;
+
+	    default:
+	      info->fprintf_func (info->stream, "***UNKNOWN OPERAND `%c'***", pop->args[idx]);
+	      break;
+	    }
+          if (idx < (pop->nr_operands - 1))
+	    info->fprintf_func (info->stream, ", ");
+        }
+      break;
+
+    case 1:
+      rb = (insn >> 6) & 0x7;
+      ra = (insn >> 3) & 0x7;
+      val = 8 << (insn & 0x3);
+      info->fprintf_func (info->stream, "r%d, [r%d], size=%d", rb, ra, (int)val);
+      break;
+
+    case 2:
+      ra = (insn >> 6) & 0x7;
+      val = insn & 0x3f;
+      info->fprintf_func (info->stream, "r%d, [%d]", ra, (int)val);
+      break;
+
+    case 3:
+      rb = (insn >> 6) & 0x7;
+      ra = (insn >> 3) & 0x7;
+      val = insn & 0x7;
+      if (!strcmp (pop->name, "ld.p") || !strcmp (pop->name, "st.p"))
+        info->fprintf_func (info->stream, "cc_%s, r%d, [r%d]", pcp_ccodes[val], rb, ra);
+      else
+        info->fprintf_func (info->stream, "cc_%s, r%d, r%d", pcp_ccodes[val], rb, ra);
+      break;
+
+    case 4:
+      ra = (insn >> 6) & 0x7;
+      val = insn & 0x3f;
+      if (!strcmp (pop->name, "chkb"))
+        info->fprintf_func (info->stream, "r%d, %d, %s", ra, (int)val & 0x1f,
+		(val & 0x20) ? "set" : "clr");
+      else if (!strcmp (pop->name, "ldl.dptr"))
+        {
+          if (ra == 7)
+            {
+              info->fprintf_func(info->stream, "r%d, 0x%04lx, %lu",ra, insn2 & 0xf00, (insn2 >> 5) & 3);
+            }
+          else
+            info->fprintf_func (info->stream, "r%d, 0x....%04lx", ra, insn2);
+        }
+      else if (!strcmp (pop->name, "ldl.il"))
+        info->fprintf_func (info->stream, "r%d, 0x....%04lx", ra, insn2);
+      else if (!strcmp (pop->name, "ldl.iu"))
+        info->fprintf_func (info->stream, "r%d, 0x%04lx....", ra, insn2);
+      else
+        info->fprintf_func (info->stream, "r%d, %d", ra, (int)val);
+      break;
+
+    case 5:
+      ra = (insn >> 6) & 0x7;
+      val = 8 << (((insn >> 5) & 0x1) | ((insn >> 8) & 0x2));
+      if ((!strcmp (pop->name, "set.f") || !strcmp (pop->name, "clr.f"))
+          && ((insn & 0x1f) >= val))
+        info->fprintf_func (info->stream, "[r%d], %d ***ILLEGAL VALUE***, size=%d", ra,
+		(int)insn & 0x1f, (int)val);
+      else
+        info->fprintf_func (info->stream, "[r%d], %d, size=%d", ra, (int)insn & 0x1f, (int)val);
+      break;
+
+    case 6:
+      rb = (insn >> 6) & 0x7;
+      ra = (insn >> 3) & 0x7;
+      if ((rb == 0) || (ra == 0) || (rb == 7) || (ra == 7) || (rb == ra))
+        info->fprintf_func (info->stream, "r%d, r%d ***ILLEGAL REGISTER USE***", rb, ra);
+      else
+        info->fprintf_func (info->stream, "r%d, r%d", rb, ra);
+      break;
+
+    case 7:
+      for (idx = 0; idx < pop->nr_operands; ++idx)
+        {
+	  switch (pop->args[idx])
+	    {
+	    case 'r':
+	    case 'R':
+	      info->fprintf_func (info->stream, "[r%lu]", (insn >> 3) & 0x7);
+	      break;
+
+	    case 'm':
+	      info->fprintf_func (info->stream, "dac=%lu", (insn >> 3) & 0x1);
+	      break;
+
+	    case 'a':
+	    case 'b':
+	      info->fprintf_func (info->stream, "cc_%s", pcp_ccodes[(insn >> 6) & 0xf]);
+	      break;
+
+	    case 'o':
+	      info->fprintf_func (info->stream, "rta=%lu", (insn >> 2) & 0x1);
+	      break;
+
+	    case 'p':
+	      info->fprintf_func (info->stream, "eda=%lu", (insn >> 1) & 0x1);
+	      break;
+
+	    case 'q':
+	      info->fprintf_func (info->stream, "sdb=%lu", insn & 1);
+	      break;
+
+	    case 'e':
+	      if (!strcmp (pop->name, "jl"))
+	        {
+		  val = insn & 0x3ff;
+		  if (val & 0x200)
+		    val |= ~0x3ff;
+	          (*info->print_address_func) (memaddr + 2 + (val << 1), info);
+		}
+	      else if (!strcmp (pop->name, "jc"))
+	        {
+		  val = insn & 0x3f;
+		  if (val & 0x20)
+		    val |= ~0x3f;
+	          (*info->print_address_func) (memaddr + 2 + (val << 1), info);
+		}
+	      else if (!strcmp (pop->name, "jc.a"))
+	        /* FIXME: address should be PCODE_BASE + (insn2 << 1).  */
+	        (*info->print_address_func)
+		 ((memaddr & 0xffff0000) + (insn2 << 1), info);
+	      else
+	        info->fprintf_func (info->stream, "***ILLEGAL expr FOR %s***", pop->name);
+	      break;
+
+	    default:
+	      info->fprintf_func (info->stream, "***UNKNOWN OPERAND `%c'***", pop->args[idx]);
+	      break;
+	    }
+          if (idx < (pop->nr_operands - 1))
+	    info->fprintf_func (info->stream, ", ");
+	}
+      break;
+
+    default:
+      info->fprintf_func (info->stream, "***ILLEGAL FORMAT GROUP %d***", pop->fmt_group);
+      break;
+    }
+
+  return pop->len32 ? 4 : 2;
+}
+
+/* Read, decode and print the byte(s) starting at MEMADDR.  Return -1
+   if a read error occurs, or else the number of decoded bytes.  We
+   do expect to find a valid TriCore instruction at MEMADDR, but we'll
+   happily just print the byte(s) as ".byte"/".hword" pseudo-ops if
+   this is not the case.  We only read as many bytes as necessary
+   (or possible) to decode a single instruction or a pseudo-op, i.e.
+   1, 2 or 4 bytes.  */
+
+/* WT 2008-11-14: what to do here? (section flags positions have changed!) */
+#ifndef SEC_ARCH_BIT_0
+#define SEC_ARCH_BIT_0	SEC_READONLY
+#endif /* SEC_ARCH_BIT_0 */
+
+int
+print_insn_tricore (bfd_vma memaddr, struct disassemble_info *info)
+{
+  bfd_byte buffer[4];
+  int len32 = 0, failure;
+  unsigned long insn = 0;
+  unsigned long mach = 0;
+
+  if (!initialized)
+    {
+      mach = tricore_elf32_convert_eflags(info->mach);
+      /* Set the current instruction set architecture.  */
+      switch (mach & EF_EABI_TRICORE_CORE_MASK)
+        {
+	  case EF_EABI_TRICORE_V1_1:
+	    current_isa = TRICORE_V1_1;
+	    break;
+          case EF_EABI_TRICORE_V1_2:
+            current_isa = TRICORE_V1_2;
+            break;
+          case EF_EABI_TRICORE_V1_3:
+            current_isa = TRICORE_V1_3;
+            break;
+          case EF_EABI_TRICORE_V1_3_1:
+            current_isa = TRICORE_V1_3_1;
+            break;
+          case EF_EABI_TRICORE_V1_6:
+            current_isa = TRICORE_V1_6;
+            break;
+          case EF_EABI_TRICORE_V1_6_1:
+            current_isa = TRICORE_V1_6_1;
+            break;
+          default:
+            current_isa = TRICORE_V1_3;
+            break;
+	}
+
+      /* Initialize architecture-dependent variables.  */
+      tricore_init_arch_vars (mach);
+
+      /* Initialize the hash tables.  */
+      init_hash_tables ();
+      initialized = 1;
+    }
+
+  memset ((char *) buffer, 0, sizeof (buffer));
+#if 0 /* WT 20041217 */
+  failure = (*info->read_memory_func) (memaddr, buffer, 1, info);
+  if (failure)
+    {
+      (*info->memory_error_func) (failure, memaddr, info);
+      return -1;
+    }
+
+  /* Try to read the 2nd byte.  */
+  failure = (*info->read_memory_func) (memaddr + 1, &buffer[1], 1, info);
+  if (failure)
+    {
+      /* Maybe MEMADDR isn't even and we reached the end of a section.  */
+      (*info->fprintf_func) (info->stream, ".byte 0x%02x", buffer[0]);
+      return 1;
+    }
+#else
+  /* read instruction half word */
+  failure = (*info->read_memory_func) (memaddr, buffer, 2, info);
+  if (failure)
+    {
+      (*info->memory_error_func) (failure, memaddr, info);
+      return -1;
+    }
+#endif /* WT 20041217 */
+
+  /* Check if we're disassembling .pcp{text,data} sections.  */
+  if (info->section && (info->section->flags & SEC_ARCH_BIT_0))
+    return decode_pcp_insn (memaddr, buffer, info);
+
+  /* Handle TriCore sections.  */
+  if (buffer[0] & 1)
+    {
+      /* Looks like this is a 32-bit insn; try to read 2 more bytes.  */
+      failure = (*info->read_memory_func) (memaddr + 2, &buffer[2], 2, info);
+      if (failure)
+        {
+          insn = bfd_getl16 (buffer);
+          (*info->fprintf_func) (info->stream, ".hword 0x%04lx", insn);
+	  return 2;
+	}
+      else
+        len32 = 1;
+    }
+
+  if (len32)
+    insn = bfd_getl32 (buffer);
+  else
+    insn = bfd_getl16 (buffer);
+
+  return decode_tricore_insn (memaddr, insn, len32, info);
+}
+
+/* End of tricore-dis.c.  */
diff --git a/opcodes/tricore-opc.c b/opcodes/tricore-opc.c
new file mode 100644
index 00000000000..76af9ffdde0
--- /dev/null
+++ b/opcodes/tricore-opc.c
@@ -0,0 +1,2497 @@
+/* Opcode and core register tables for Infineon's TriCore architecture.
+   Copyright (C) 1998-2003 Free Software Foundation, Inc.
+   Contributed by Michael Schumacher (mike@hightec-rt.com).
+
+This file is part of GDB, GAS, and the GNU binutils.
+
+GDB, GAS, and the GNU binutils are free software; you can redistribute
+them and/or modify them under the terms of the GNU General Public
+License as published by the Free Software Foundation; either version
+1, or (at your option) any later version.
+
+GDB, GAS, and the GNU binutils are distributed in the hope that they
+will be useful, but WITHOUT ANY WARRANTY; without even the implied
+warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this file; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+#include "ansidecl.h"
+#include "opcode/tricore.h"
+
+/* The TriCore has a number of special function registers, which are
+   described below.  Their actual address is some implementation
+   specific base address, plus their 16-bit offset.  */
+
+const struct tricore_core_register tricore_sfrs[] =
+{
+  {"$mmucon",	0x8000, TRICORE_V1_3_UP},
+  {"$mmu_con",	0x8000, TRICORE_V1_3_UP},
+  {"$asi",	0x8004, TRICORE_V1_3_UP},
+  {"$mmu_asi",	0x8004, TRICORE_V1_3_UP},
+  {"$mmuid",	0x8008, TRICORE_V1_3_UP},
+  {"$mmu_id",	0x8008, TRICORE_V1_3_UP},
+  {"$tva",	0x800c, TRICORE_V1_3_UP},
+  {"$mmu_tva",	0x800c, TRICORE_V1_3_UP},
+  {"$tpa",	0x8010, TRICORE_V1_3_UP},
+  {"$mmu_tpa",	0x8010, TRICORE_V1_3_UP},
+  {"$tpx",	0x8014, TRICORE_V1_3_UP},
+  {"$mmu_tpx",	0x8014, TRICORE_V1_3_UP},
+  {"$tfa",	0x8018, TRICORE_V1_3_UP},
+  {"$mmu_tfa",	0x8018, TRICORE_V1_3_UP},
+
+  {"$bmacon", 	0x9004, TRICORE_V1_3_1},
+  {"$diear", 	0x9020, TRICORE_V1_3_1},
+  {"$dietr", 	0x9024, TRICORE_V1_3_1},
+  {"$ccdier", 	0x9028, TRICORE_V1_3_1},
+  {"$smacon", 	0x9040, TRICORE_V1_3_1},
+  {"$miecon", 	0x9044, TRICORE_V1_3_1},
+  {"$piear", 	0x9210, TRICORE_V1_3_1},
+  {"$pietr", 	0x9214, TRICORE_V1_3_1},
+  {"$ccpier", 	0x9218, TRICORE_V1_3_1},
+  {"$compat", 	0x9400, TRICORE_V1_3_1},
+
+  {"$fpu_trap_con", 	0xa000, TRICORE_V1_3_1|TRICORE_V1_6_UP},
+  {"$fpu_trap_pc", 	0xa004, TRICORE_V1_3_1|TRICORE_V1_6_UP},
+  {"$fpu_trap_opc", 	0xa008, TRICORE_V1_3_1|TRICORE_V1_6_UP},
+  {"$fpu_trap_src1", 	0xa010, TRICORE_V1_3_1|TRICORE_V1_6_UP},
+  {"$fpu_trap_src2", 	0xa014, TRICORE_V1_3_1|TRICORE_V1_6_UP},
+  {"$fpu_trap_src3", 	0xa018, TRICORE_V1_3_1|TRICORE_V1_6_UP},
+  {"$fpu_trap_id", 	0xa020, TRICORE_V1_3_1|TRICORE_V1_6_UP},
+
+  {"$pma0",     0x801c, TRICORE_V1_6_UP },
+  {"$mmu_tfas", 0x8020, TRICORE_V1_6_UP },
+
+  {"$dcon2",    0x9000, TRICORE_V1_6_UP },
+  {"$bmacon", 	0x9004, TRICORE_V1_6_UP },
+  {"$dcon1",    0x9008, TRICORE_V1_6_UP },
+  {"$smacon", 	0x900c, TRICORE_V1_6_UP },
+  {"$dstr",     0x9010, TRICORE_V1_6_UP },
+  {"$datr",     0x9018, TRICORE_V1_6_UP },
+  {"$deadd",    0x901c, TRICORE_V1_6_UP },
+  {"$diear", 	0x9020, TRICORE_V1_6_UP },
+  {"$dietr", 	0x9024, TRICORE_V1_6_UP },
+  {"$ccdier", 	0x9028, TRICORE_V1_6_UP },
+  {"$dcon0",    0x9040, TRICORE_V1_6_UP },
+  {"$miecon", 	0x9044, TRICORE_V1_6_UP },
+  {"$pstr", 	0x9200, TRICORE_V1_6_UP },
+  {"$pcon1", 	0x9204, TRICORE_V1_6_UP },
+  {"$pcon2", 	0x9208, TRICORE_V1_6_UP },
+  {"$pcon0", 	0x920c, TRICORE_V1_6_UP },
+  {"$piear", 	0x9210, TRICORE_V1_6_UP },
+  {"$pietr", 	0x9214, TRICORE_V1_6_UP },
+  {"$ccpier", 	0x9218, TRICORE_V1_6 },
+  {"$compat", 	0x9400, TRICORE_V1_6_UP },
+
+  {"$dpr0_0l",	0xc000, TRICORE_GENERIC},
+  {"$dpr0_0u",	0xc004, TRICORE_GENERIC},
+  {"$dpr0_1l",	0xc008, TRICORE_GENERIC},
+  {"$dpr0_1u",	0xc00c, TRICORE_GENERIC},
+  {"$dpr0_2l",	0xc010, TRICORE_GENERIC},
+  {"$dpr0_2u",	0xc014, TRICORE_GENERIC},
+  {"$dpr0_3l",	0xc018, TRICORE_GENERIC},
+  {"$dpr0_3u",	0xc01c, TRICORE_GENERIC},
+
+  {"$dpr1_0l",	0xc400, TRICORE_GENERIC},
+  {"$dpr1_0u",	0xc404, TRICORE_GENERIC},
+  {"$dpr1_1l",	0xc408, TRICORE_GENERIC},
+  {"$dpr1_1u",	0xc40c, TRICORE_GENERIC},
+  {"$dpr1_2l",	0xc410, TRICORE_GENERIC},
+  {"$dpr1_2u",	0xc414, TRICORE_GENERIC},
+  {"$dpr1_3l",	0xc418, TRICORE_GENERIC},
+  {"$dpr1_3u",	0xc41c, TRICORE_GENERIC},
+
+  {"$dpr2_0l",	0xc800, TRICORE_V1_2_UP},
+  {"$dpr2_0u",	0xc804, TRICORE_V1_2_UP},
+  {"$dpr2_1l",	0xc808, TRICORE_V1_2_UP},
+  {"$dpr2_1u",	0xc80c, TRICORE_V1_2_UP},
+  {"$dpr2_2l",	0xc810, TRICORE_V1_2_UP},
+  {"$dpr2_2u",	0xc814, TRICORE_V1_2_UP},
+  {"$dpr2_3l",	0xc818, TRICORE_V1_2_UP},
+  {"$dpr2_3u",	0xc81c, TRICORE_V1_2_UP},
+
+  {"$dpr3_0l",	0xcc00, TRICORE_V1_2_UP},
+  {"$dpr3_0u",	0xcc04, TRICORE_V1_2_UP},
+  {"$dpr3_1l",	0xcc08, TRICORE_V1_2_UP},
+  {"$dpr3_1u",	0xcc0c, TRICORE_V1_2_UP},
+  {"$dpr3_2l",	0xcc10, TRICORE_V1_2_UP},
+  {"$dpr3_2u",	0xcc14, TRICORE_V1_2_UP},
+  {"$dpr3_3l",	0xcc18, TRICORE_V1_2_UP},
+  {"$dpr3_3u",	0xcc1c, TRICORE_V1_2_UP},
+
+  {"$cpr0_0l",	0xd000, TRICORE_GENERIC},
+  {"$cpr0_0u",	0xd004, TRICORE_GENERIC},
+  {"$cpr0_1l",	0xd008, TRICORE_GENERIC},
+  {"$cpr0_1u",	0xd00c, TRICORE_GENERIC},
+  {"$cpr0_2l",	0xd010, TRICORE_V1_2_UP},
+  {"$cpr0_2u",	0xd014, TRICORE_V1_2_UP},
+  {"$cpr0_3l",	0xd018, TRICORE_V1_2_UP},
+  {"$cpr0_3u",	0xd01c, TRICORE_V1_2_UP},
+
+  {"$cpr1_0l",	0xd400, TRICORE_GENERIC},
+  {"$cpr1_0u",	0xd404, TRICORE_GENERIC},
+  {"$cpr1_1l",	0xd408, TRICORE_GENERIC},
+  {"$cpr1_1u",	0xd40c, TRICORE_GENERIC},
+  {"$cpr1_2l",	0xd410, TRICORE_V1_2_UP},
+  {"$cpr1_2u",	0xd414, TRICORE_V1_2_UP},
+  {"$cpr1_3l",	0xd418, TRICORE_V1_2_UP},
+  {"$cpr1_3u",	0xd41c, TRICORE_V1_2_UP},
+
+  {"$cpr2_0l",	0xd800, TRICORE_V1_2_UP},
+  {"$cpr2_0u",	0xd804, TRICORE_V1_2_UP},
+  {"$cpr2_1l",	0xd808, TRICORE_V1_2_UP},
+  {"$cpr2_1u",	0xd80c, TRICORE_V1_2_UP},
+  {"$cpr2_2l",	0xd810, TRICORE_V1_2_UP},
+  {"$cpr2_2u",	0xd814, TRICORE_V1_2_UP},
+  {"$cpr2_3l",	0xd818, TRICORE_V1_2_UP},
+  {"$cpr2_3u",	0xd81c, TRICORE_V1_2_UP},
+
+  {"$cpr3_0l",	0xdc00, TRICORE_V1_2_UP},
+  {"$cpr3_0u",	0xdc04, TRICORE_V1_2_UP},
+  {"$cpr3_1l",	0xdc08, TRICORE_V1_2_UP},
+  {"$cpr3_1u",	0xdc0c, TRICORE_V1_2_UP},
+  {"$cpr3_2l",	0xdc10, TRICORE_V1_2_UP},
+  {"$cpr3_2u",	0xdc14, TRICORE_V1_2_UP},
+  {"$cpr3_3l",	0xdc18, TRICORE_V1_2_UP},
+  {"$cpr3_3u",	0xdc1c, TRICORE_V1_2_UP},
+
+  {"$dpm0_0",	0xe000, TRICORE_GENERIC},
+  {"$dpm0_1",	0xe001, TRICORE_GENERIC},
+  {"$dpm0_2",	0xe002, TRICORE_GENERIC},
+  {"$dpm0_3",	0xe003, TRICORE_GENERIC},
+
+  {"$dpm1_0",	0xe080, TRICORE_GENERIC},
+  {"$dpm1_1",	0xe081, TRICORE_GENERIC},
+  {"$dpm1_2",	0xe082, TRICORE_GENERIC},
+  {"$dpm1_3",	0xe083, TRICORE_GENERIC},
+
+  {"$cpm0_0",	0xe200, TRICORE_GENERIC},
+  {"$cpm0_1",	0xe201, TRICORE_GENERIC},
+
+  {"$cpm1_0",	0xe280, TRICORE_GENERIC},
+  {"$cpm1_1",	0xe281, TRICORE_GENERIC},
+
+  {"$dbgsr",	0xfd00, TRICORE_GENERIC},
+  {"$gprwb",	0xfd04, TRICORE_GENERIC},
+  {"$exevt",	0xfd08, TRICORE_GENERIC},
+  {"$crevt",	0xfd0c, TRICORE_GENERIC},
+  {"$swevt",	0xfd10, TRICORE_GENERIC},
+  {"$tr0evt",	0xfd20, TRICORE_GENERIC},
+  {"$tr1evt",	0xfd24, TRICORE_GENERIC},
+
+  {"$pcxi",		0xfe00, TRICORE_GENERIC},
+  {"$psw",		0xfe04, TRICORE_GENERIC},
+  {"$pc",		0xfe08, TRICORE_GENERIC},
+  {"$dbiten",	0xfe0c, TRICORE_V1_1},
+  {"$syscon",	0xfe14, TRICORE_GENERIC},
+  {"$cpuid",	0xfe18, TRICORE_V1_2_UP},
+  {"$cpu_id",	0xfe18, TRICORE_V1_2_UP},
+  {"$biv",		0xfe20, TRICORE_GENERIC},
+  {"$btv",		0xfe24, TRICORE_GENERIC},
+  {"$isp",		0xfe28, TRICORE_GENERIC},
+  {"$icr",		0xfe2c, TRICORE_GENERIC},
+  {"$fcx",		0xfe38, TRICORE_GENERIC},
+  {"$lcx",		0xfe3c, TRICORE_GENERIC},
+
+  /* These are not core SFRs, but they can be accessed using the
+     18-bit absolute address mode.  */
+
+  {"$pwrclc",	0xf0000000, TRICORE_V1_2_DN},
+  {"$pwrid",	0xf0000008, TRICORE_V1_2_DN},
+  {"$rstreq",	0xf0000010, TRICORE_V1_2_DN},
+  {"$rstsr",	0xf0000014, TRICORE_V1_2_DN},
+
+  {"$wdtcon0",	0xf0000020, TRICORE_V1_3_DN},
+  {"$wdtcon1",	0xf0000024, TRICORE_V1_3_DN},
+  {"$wdtsr",	0xf0000028, TRICORE_V1_3_DN},
+
+  {"$wdtcon0",	0xf00005f0, TRICORE_V1_3_1 | TRICORE_V1_6 },
+  {"$wdtcon1",	0xf00005f4, TRICORE_V1_3_1 | TRICORE_V1_6 },
+  {"$wdtsr",	0xf00005f8, TRICORE_V1_3_1 | TRICORE_V1_6 },
+
+  {"$stmclc",	0xf0000200, TRICORE_V1_3 | TRICORE_V1_3_1 | TRICORE_V1_6 },
+  {"$stmid",	0xf0000208, TRICORE_V1_3 | TRICORE_V1_3_1 | TRICORE_V1_6 },
+  {"$systim0",	0xf0000210, TRICORE_V1_3 | TRICORE_V1_3_1 | TRICORE_V1_6 },
+  {"$systim1",	0xf0000214, TRICORE_V1_3 | TRICORE_V1_3_1 | TRICORE_V1_6 },
+  {"$systim2",	0xf0000218, TRICORE_V1_3 | TRICORE_V1_3_1 | TRICORE_V1_6 },
+  {"$systim3",	0xf000021c, TRICORE_V1_3 | TRICORE_V1_3_1 | TRICORE_V1_6 },
+  {"$systim4",	0xf0000220, TRICORE_V1_3 | TRICORE_V1_3_1 | TRICORE_V1_6 },
+  {"$systim5",	0xf0000224, TRICORE_V1_3 | TRICORE_V1_3_1 | TRICORE_V1_6 },
+  {"$systim6",	0xf0000228, TRICORE_V1_3 | TRICORE_V1_3_1 | TRICORE_V1_6 },
+
+
+  {"$nmisr",	0xf000002c, TRICORE_V1_2_DN},
+  {"$pmcon",	0xf0000030, TRICORE_V1_2_DN},
+  {"$pmcsr",	0xf0000034, TRICORE_V1_2_DN},
+  {"$pllclc",	0xf0000040, TRICORE_V1_2_DN},
+  {"$eckclc",	0xf0000044, TRICORE_V1_2_DN},
+  {"$icuclc",	0xf0000048, TRICORE_V1_2_DN},
+
+  {"$stmclc",	0xf0000300, TRICORE_V1_2_DN},
+  {"$stmid",	0xf0000308, TRICORE_V1_2_DN},
+  {"$systim0",	0xf0000320, TRICORE_V1_2_DN},
+  {"$systim1",	0xf0000324, TRICORE_V1_2_DN},
+  {"$systim2",	0xf0000328, TRICORE_V1_2_DN},
+  {"$systim3",	0xf000032c, TRICORE_V1_2_DN},
+  {"$systim4",	0xf0000330, TRICORE_V1_2_DN},
+  {"$systim5",	0xf0000334, TRICORE_V1_2_DN},
+  {"$systim6",	0xf0000338, TRICORE_V1_2_DN},
+  {"$systim7",	0xf000033c, TRICORE_V1_2_DN},
+
+  {"$jdpid",	0xf0000408, TRICORE_V1_2_DN},
+  {"$comdata",	0xf0000468, TRICORE_V1_2_DN},
+  {"$iosr",		0xf000046c, TRICORE_V1_2_DN},
+
+  {"$ebucon",	0xf0000510, TRICORE_V1_2_DN},
+  {"$drmcon",	0xf0000514, TRICORE_V1_2_DN},
+  {"$drmstat",	0xf0000518, TRICORE_V1_2_DN},
+  {"$addsel0",	0xf0000520, TRICORE_V1_2_DN},
+  {"$addsel1",	0xf0000524, TRICORE_V1_2_DN},
+  {"$addsel2",	0xf0000528, TRICORE_V1_2_DN},
+  {"$addsel3",	0xf000052c, TRICORE_V1_2_DN},
+  {"$addsel4",	0xf0000530, TRICORE_V1_2_DN},
+  {"$addsel5",	0xf0000534, TRICORE_V1_2_DN},
+  {"$addsel6",	0xf0000538, TRICORE_V1_2_DN},
+  {"$addsel7",	0xf000053c, TRICORE_V1_2_DN},
+
+  {"$buscon0",	0xf0000560, TRICORE_V1_2_DN},
+  {"$buscon1",	0xf0000564, TRICORE_V1_2_DN},
+  {"$buscon2",	0xf0000568, TRICORE_V1_2_DN},
+  {"$buscon3",	0xf000056c, TRICORE_V1_2_DN},
+  {"$buscon4",	0xf0000570, TRICORE_V1_2_DN},
+  {"$buscon5",	0xf0000574, TRICORE_V1_2_DN},
+  {"$buscon6",	0xf0000578, TRICORE_V1_2_DN},
+  {"$buscon7",	0xf000057c, TRICORE_V1_2_DN},
+
+  {"$gtclc",	0xf0000700, TRICORE_V1_2_DN},
+  {"$gtid",		0xf0000708, TRICORE_V1_2_DN},
+  {"$t01irs",	0xf0000710, TRICORE_V1_2_DN},
+  {"$t01ots",	0xf0000714, TRICORE_V1_2_DN},
+  {"$t2con",	0xf0000718, TRICORE_V1_2_DN},
+  {"$t2rccon",	0xf000071c, TRICORE_V1_2_DN},
+  {"$t2ais",	0xf0000720, TRICORE_V1_2_DN},
+  {"$t2bis",	0xf0000724, TRICORE_V1_2_DN},
+  {"$t2es",		0xf0000728, TRICORE_V1_2_DN},
+  {"$gtosel",	0xf000072c, TRICORE_V1_2_DN},
+  {"$gtout",	0xf0000730, TRICORE_V1_2_DN},
+  {"$t0dcba",	0xf0000734, TRICORE_V1_2_DN},
+  {"$t0cba",	0xf0000738, TRICORE_V1_2_DN},
+  {"$t0rdcba",	0xf000073c, TRICORE_V1_2_DN},
+  {"$t0rcba",	0xf0000740, TRICORE_V1_2_DN},
+  {"$t1dcba",	0xf0000744, TRICORE_V1_2_DN},
+  {"$t1cba",	0xf0000748, TRICORE_V1_2_DN},
+  {"$t1rdcba",	0xf000074c, TRICORE_V1_2_DN},
+  {"$t1rcba",	0xf0000750, TRICORE_V1_2_DN},
+  {"$t2",		0xf0000754, TRICORE_V1_2_DN},
+  {"$t2rc0",	0xf0000758, TRICORE_V1_2_DN},
+  {"$t2rc1",	0xf000075c, TRICORE_V1_2_DN},
+  {"$t012run",	0xf0000760, TRICORE_V1_2_DN},
+
+  {"$gtsrsel",	0xf00007dc, TRICORE_V1_2_DN},
+  {"$gtsrc0",	0xf00007e0, TRICORE_V1_2_DN},
+  {"$gtsrc1",	0xf00007e4, TRICORE_V1_2_DN},
+  {"$gtsrc2",	0xf00007e8, TRICORE_V1_2_DN},
+  {"$gtsrc3",	0xf00007ec, TRICORE_V1_2_DN},
+  {"$gtsrc4",	0xf00007f0, TRICORE_V1_2_DN},
+  {"$gtsrc5",	0xf00007f4, TRICORE_V1_2_DN},
+  {"$gtsrc6",	0xf00007f8, TRICORE_V1_2_DN},
+  {"$gtsrc7",	0xf00007fc, TRICORE_V1_2_DN},
+
+  {"$pcpclc",	0xf0003f00, TRICORE_V1_2_DN},
+  {"$pcpid",	0xf0003f08, TRICORE_V1_2_DN},
+  {"$pcpcs",	0xf0003f10, TRICORE_V1_2_DN},
+  {"$pcpes",	0xf0003f14, TRICORE_V1_2_DN},
+  {"$pcpicr",	0xf0003f20, TRICORE_V1_2_DN},
+  {"$pcpsrc3",	0xf0003ff0, TRICORE_V1_2_DN},
+  {"$pcpsrc2",	0xf0003ff4, TRICORE_V1_2_DN},
+  {"$pcpsrc1",	0xf0003ff8, TRICORE_V1_2_DN},
+  {"$pcpsrc0",	0xf0003ffc, TRICORE_V1_2_DN}
+};
+
+const int tricore_numsfrs = sizeof tricore_sfrs / sizeof tricore_sfrs[0];
+
+/* Here are the opcodes for the TriCore CPU.  The assembler requires that
+   all instances of the same mnemonic must be consecutive (16-bit versions
+   before 32-bit, BOL before BO).  If they aren't, the assembler will bomb
+   at runtime.  The disassembler shouldn't care, though.  */
+
+struct tricore_opcode tricore_opcodes[] =
+{
+#define INDICES 0, 0
+  {"abs",        1, 0x01c0000b, 0x0e3f0ff4, F(RR),   2, "dd",    "13",
+		 TRICORE_GENERIC, INDICES},
+  {"abs.b",      1, 0x05c0000b, 0x0a3f0ff4, F(RR),   2, "dd",    "13",
+		 TRICORE_GENERIC, INDICES},
+  {"abs.h",      1, 0x07c0000b, 0x083f0ff4, F(RR),   2, "dd",    "13",
+		 TRICORE_GENERIC, INDICES},
+  {"absdif",     1, 0x00e0000b, 0x0f1f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"absdif",     1, 0x01c0008b, 0x0e200074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"absdif.b",   1, 0x04e0000b, 0x0b1f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"absdif.h",   1, 0x06e0000b, 0x091f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"absdifs",    1, 0x00f0000b, 0x0f0f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"absdifs",    1, 0x01e0008b, 0x0e000074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"absdifs.b",  1, 0x04f0000b, 0x0b0f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"absdifs.h",  1, 0x06f0000b, 0x090f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"abss",       1, 0x01d0000b, 0x0e2f0ff4, F(RR),   2, "dd",    "13",
+		 TRICORE_GENERIC, INDICES},
+  {"abss.b",     1, 0x05d0000b, 0x0a2f0ff4, F(RR),   2, "dd",    "13",
+		 TRICORE_V1_1, INDICES},
+  {"abss.h",     1, 0x07d0000b, 0x082f0ff4, F(RR),   2, "dd",    "13",
+		 TRICORE_GENERIC, INDICES},
+  {"add",        0, 0x00000012, 0xffff00ed, F(SRR),  3, "did",   "201",
+		 TRICORE_V1_2_UP, INDICES},
+  {"add",        0, 0x00000092, 0xffff006d, F(SRC),  3, "di4",   "201",
+		 TRICORE_V1_2_UP, INDICES},
+  {"add",        0, 0x0000001a, 0xffff00e5, F(SRR),  3, "idd",   "021",
+		 TRICORE_GENERIC, INDICES},
+  {"add",        0, 0x00000042, 0xffff00bd, F(SRR),  2, "dd",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"add",        0, 0x0000009a, 0xffff0065, F(SRC),  3, "id4",   "021",
+		 TRICORE_GENERIC, INDICES},
+  {"add",        0, 0x000000c2, 0xffff003d, F(SRC),  2, "d4",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"add",        1, 0x0000000b, 0x0fff00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"add",        1, 0x0000008b, 0x0fe00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"add.a",      0, 0x00000030, 0xffff00cf, F(SRR),  2, "aa",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"add.a",      0, 0x000000b0, 0xffff004f, F(SRC),  2, "a4",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"add.a",      1, 0x00100001, 0x0fef00fe, F(RR),   3, "aaa",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"add.b",      1, 0x0400000b, 0x0bff00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"add.f",      1, 0x0021006b, 0x00def094, F(RRR),  3, "ddd",   "125",
+  		 TRICORE_V1_3_UP, INDICES},
+  {"add.h",      1, 0x0600000b, 0x09ff00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"addc",       1, 0x0050000b, 0x0faf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"addc",       1, 0x00a0008b, 0x0f400074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"addi",       1, 0x0000001b, 0x000000e4, F(RLC),  3, "ddw",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"addih",      1, 0x0000009b, 0x00000064, F(RLC),  3, "ddW",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"addih.a",    1, 0x00000011, 0x000000ee, F(RLC),  3, "aaW",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"adds",       0, 0x00000022, 0xffff00dd, F(SRR),  2, "dd",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"adds",       1, 0x0020000b, 0x0fdf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"adds",       1, 0x0040008b, 0x0fa00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"adds.b",     1, 0x0420000b, 0x0bdf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"adds.bu",    1, 0x0430000b, 0x0bcf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"adds.h",     1, 0x0620000b, 0x09df00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"adds.hu",    1, 0x0630000b, 0x09cf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"adds.u",     1, 0x0030000b, 0x0fcf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"adds.u",     1, 0x0060008b, 0x0f800074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"addsc.a",    0, 0x00000010, 0xffff002f, F(SRRS), 3, "ad2",   "213",
+		 TRICORE_V1_1, INDICES},
+  {"addsc.a",    0, 0x00000010, 0xffff002f, F(SRRS), 4, "aai2",  "2103",
+		 TRICORE_V1_2_UP, INDICES},
+  {"addsc.a",    1, 0x06000001, 0x09fc00fe, F(RR),   4, "aad2",  "1432",
+		 TRICORE_V1_1, INDICES},
+  {"addsc.a",    1, 0x06000001, 0x09fc00fe, F(RR),   4, "aad2",  "1342",
+		 TRICORE_V1_2_UP, INDICES},
+  {"addsc.a",    1, 0x06010001, 0x09fc00fe, F(RR),   4, "aad2",  "1342",
+		 TRICORE_V1_2_UP, INDICES},
+  {"addsc.a",    1, 0x06020001, 0x09fc00fe, F(RR),   4, "aad2",  "1342",
+		 TRICORE_V1_2_UP, INDICES},
+  {"addsc.a",    1, 0x06030001, 0x09fc00fe, F(RR),   4, "aad2",  "1342",
+		 TRICORE_V1_2_UP, INDICES},
+  {"addsc.at",   1, 0x06200001, 0x09df00fe, F(RR),   3, "aad",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"addsc.at",   1, 0x06200001, 0x09df00fe, F(RR),   3, "aad",   "134",
+		 TRICORE_V1_2_UP, INDICES},
+  {"addx",       1, 0x0040000b, 0x0fbf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"addx",       1, 0x0080008b, 0x0f600074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"and",        0, 0x00000016, 0xffff00e9, F(SRR),  2, "dd",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"and",        0, 0x00000026, 0xffff00d9, F(SRR),  2, "dd",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"and",        0, 0x00000096, 0xffff0069, F(SC),   2, "i8",    "01",
+		 TRICORE_V1_1, INDICES},
+  {"and",        0, 0x00000016, 0xffff00e9, F(SC),   2, "i8",    "01",
+		 TRICORE_V1_2_UP, INDICES},
+  {"and",        1, 0x0080000f, 0x0f7f00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"and",        1, 0x0100008f, 0x0ee00070, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"and.and.t",  1, 0x00000047, 0x006000b8, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"and.andn.t", 1, 0x00600047, 0x000000b8, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"and.eq",     1, 0x0200000b, 0x0dff00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"and.eq",     1, 0x0400008b, 0x0be00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"and.ge",     1, 0x0240000b, 0x0dbf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"and.ge",     1, 0x0480008b, 0x0b600074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"and.ge.u",   1, 0x0250000b, 0x0daf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"and.ge.u",   1, 0x04a0008b, 0x0b400074, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"and.lt",     1, 0x0220000b, 0x0ddf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"and.lt",     1, 0x0440008b, 0x0ba00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"and.lt.u",   1, 0x0230000b, 0x0dcf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"and.lt.u",   1, 0x0460008b, 0x0b800074, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"and.ne",     1, 0x0210000b, 0x0def00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"and.ne",     1, 0x0420008b, 0x0bc00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"and.nor.t",  1, 0x00400047, 0x002000b8, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"and.or.t",   1, 0x00200047, 0x004000b8, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"and.t",      1, 0x00000087, 0x00600078, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"andn",       1, 0x00e0000f, 0x0f1f00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"andn",       1, 0x01c0008f, 0x0e200070, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"andn.t",     1, 0x00600087, 0x00000078, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"bisr",       0, 0x000000c0, 0xffff003f, F(SC),   1, "8",     "1",
+		 TRICORE_V1_1, INDICES},
+  {"bisr",       0, 0x000000e0, 0xffff001f, F(SC),   1, "8",     "1",
+		 TRICORE_V1_2_UP, INDICES},
+  {"bisr",       1, 0x000000ad, 0xffe00f52, F(RC),   1, "n",     "2",
+		 TRICORE_GENERIC, INDICES},
+  {"bisr",       1, 0x002000ad, 0xffc00f52, F(RC),   1, "h",     "4",
+		 TRICORE_V1_6_1, INDICES},
+  {"bmerge",     1, 0x0000004b, 0x0fff00b4, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"bmerge",     1, 0x0010004b, 0x0fef00b4, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_2_UP, INDICES},
+  {"bsplit",     1, 0x0600004b, 0x09fff0b4, F(RR),   2, "Dd",    "14",
+		 TRICORE_V1_1, INDICES},
+  {"bsplit",     1, 0x0090004b, 0x0f6ff0b4, F(RR),   2, "Dd",    "14",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.i",   1, 0x03800089, 0x0c400f76, F(BO),   2, ">0",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.i",   1, 0x038000a9, 0xfc7f0f56, F(BO),   1, "#",     "2",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.i",   1, 0x07800089, 0x08400f76, F(BO),   2, "<0",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.i",   1, 0x078000a9, 0x08400f56, F(BO),   2, "*0",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.i",   1, 0x0b800089, 0x04400f76, F(BO),   2, "@0",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.w",   1, 0x03000089, 0x0cc00f76, F(BO),   2, ">0",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.w",   1, 0x030000a9, 0xfcff0f56, F(BO),   1, "#",     "2",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.w",   1, 0x07000089, 0x08c00f76, F(BO),   2, "<0",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.w",   1, 0x070000a9, 0x08c00f56, F(BO),   2, "*0",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.w",   1, 0x0b000089, 0x04c00f76, F(BO),   2, "@0",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.wi",  1, 0x03400089, 0x0c800f76, F(BO),   2, ">0",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.wi",  1, 0x034000a9, 0xfcbf0f56, F(BO),   1, "#",     "2",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.wi",  1, 0x07400089, 0x08800f76, F(BO),   2, "<0",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.wi",  1, 0x074000a9, 0x08800f56, F(BO),   2, "*0",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"cachea.wi",  1, 0x0b400089, 0x04800f76, F(BO),   2, "@0",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+
+  {"cachei.w",   1, 0x02c00089, 0x0d000f76, F(BO),   2, ">0",    "21",
+  		 TRICORE_V1_6_UP|TRICORE_V1_3_1, INDICES},
+  {"cachei.w",   1, 0x06c00089, 0x09000f76, F(BO),   2, "<0",    "21",
+  		 TRICORE_V1_6_UP|TRICORE_V1_3_1, INDICES},
+  {"cachei.w",   1, 0x0ac00089, 0x05000f76, F(BO),   2, "@0",    "21",
+  		 TRICORE_V1_6_UP|TRICORE_V1_3_1, INDICES},
+  {"cachei.wi",  1, 0x03c00089, 0x0c000f76, F(BO),   2, ">0",    "21",
+  		 TRICORE_V1_6_UP|TRICORE_V1_3_1, INDICES},
+  {"cachei.wi",  1, 0x07c00089, 0x08000f76, F(BO),   2, "<0",    "21",
+  		 TRICORE_V1_6_UP|TRICORE_V1_3_1, INDICES},
+  {"cachei.wi",  1, 0x0bc00089, 0x04000f76, F(BO),   2, "@0",    "21",
+  		 TRICORE_V1_6_UP|TRICORE_V1_3_1, INDICES},
+
+  {"cadd",       0, 0x0000000a, 0xffff00f5, F(SRR),  3, "did",   "201",
+		 TRICORE_V1_1, INDICES},
+  {"cadd",       0, 0x0000008a, 0xffff0075, F(SRC),  3, "di4",   "201",
+		 TRICORE_GENERIC, INDICES},
+  {"cadd",       1, 0x0000002b, 0x00ff00d4, F(RRR),  4, "dddd",  "1254",
+		 TRICORE_GENERIC, INDICES},
+  {"cadd",       1, 0x000000ab, 0x00e00054, F(RCR),  4, "ddd9",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"cadd.a",     1, 0x00000021, 0x00ff00de, F(RRR),  4, "adaa",  "1254",
+		 TRICORE_V1_1, INDICES},
+  {"cadd.a",     1, 0x000000a1, 0x00e0005e, F(RCR),  4, "ada9",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"caddn",      0, 0x0000004a, 0xffff00b5, F(SRR),  3, "did",   "201",
+		 TRICORE_V1_1, INDICES},
+  {"caddn",      0, 0x000000ca, 0xffff0035, F(SRC),  3, "di4",   "201",
+		 TRICORE_GENERIC, INDICES},
+  {"caddn",      1, 0x0010002b, 0x00ef00d4, F(RRR),  4, "dddd",  "1254",
+		 TRICORE_GENERIC, INDICES},
+  {"caddn",      1, 0x002000ab, 0x00c00054, F(RCR),  4, "ddd9",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"caddn.a",    1, 0x00100021, 0x00ef00de, F(RRR),  4, "adaa",  "1254",
+		 TRICORE_V1_1, INDICES},
+  {"caddn.a",    1, 0x002000a1, 0x00c0005e, F(RCR),  4, "ada9",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"call",       0, 0x0000005c, 0xffff00a3, F(SB),   1, "R",     "1",
+		 TRICORE_V1_2_UP, INDICES},
+  {"call",       1, 0x0000006d, 0x00000092, F(B),    1, "O",     "1",
+		 TRICORE_GENERIC, INDICES},
+  {"calla",      1, 0x000000ed, 0x00000012, F(B),    1, "T",     "1",
+		 TRICORE_GENERIC, INDICES},
+  {"calli",      1, 0x0000002d, 0xffff0fd2, F(RR),   1, "a",     "3",
+		 TRICORE_V1_1, INDICES},
+  {"calli",      1, 0x0000002d, 0xfffff0d2, F(RR),   1, "a",     "4",
+		 TRICORE_V1_2_UP, INDICES},
+  {"clo",        1, 0x01c0000f, 0x0e3ff0f0, F(RR),   2, "dd",    "14",
+		 TRICORE_GENERIC, INDICES},
+  {"clo.b",      1, 0x03d0000f, 0x0c2ff0f0, F(RR),   2, "dd",    "14",
+		 TRICORE_V1_1, INDICES},
+  {"clo.h",      1, 0x07d0000f, 0x082ff0f0, F(RR),   2, "dd",    "14",
+		 TRICORE_GENERIC, INDICES},
+  {"cls",        1, 0x01d0000f, 0x0e2ff0f0, F(RR),   2, "dd",    "14",
+		 TRICORE_GENERIC, INDICES},
+  {"cls.b",      1, 0x03e0000f, 0x0c1ff0f0, F(RR),   2, "dd",    "14",
+		 TRICORE_V1_1, INDICES},
+  {"cls.h",      1, 0x07e0000f, 0x081ff0f0, F(RR),   2, "dd",    "14",
+		 TRICORE_GENERIC, INDICES},
+  {"clz",        1, 0x01b0000f, 0x0e4ff0f0, F(RR),   2, "dd",    "14",
+		 TRICORE_GENERIC, INDICES},
+  {"clz.b",      1, 0x03c0000f, 0x0c3ff0f0, F(RR),   2, "dd",    "14",
+		 TRICORE_V1_1, INDICES},
+  {"clz.h",      1, 0x07c0000f, 0x083ff0f0, F(RR),   2, "dd",    "14",
+		 TRICORE_GENERIC, INDICES},
+  {"cmov",       0, 0x0000002a, 0xffff00d5, F(SRR),  3, "did",   "201",
+		 TRICORE_GENERIC, INDICES},
+  {"cmov",       0, 0x000000aa, 0xffff0055, F(SRC),  3, "di4",   "201",
+		 TRICORE_GENERIC, INDICES},
+  {"cmovn",      0, 0x0000006a, 0xffff0095, F(SRR),  3, "did",   "201",
+		 TRICORE_GENERIC, INDICES},
+  {"cmovn",      0, 0x000000ea, 0xffff0015, F(SRC),  3, "di4",   "201",
+		 TRICORE_GENERIC, INDICES},
+  {"cmp.f",      1, 0x0001004b, 0x0ffe00b4, F(RR),   3, "ddd",   "143",
+  		 TRICORE_V1_3_UP, INDICES},
+  {"cmpswap.w",  1, 0x08c00049, 0x070000b6, F(BO),   3, "@0D",   "213",
+  		 TRICORE_V1_6_1_UP, INDICES}, /* base + offset */
+  {"cmpswap.w",  1, 0x00c00069, 0xff3f0096, F(BO),   2, "#D",    "23",
+  		 TRICORE_V1_6_1_UP, INDICES}, /* bit reverse */
+  {"cmpswap.w",  1, 0x04c00069, 0x0b000096, F(BO),   3, "*0D",    "213",
+  		 TRICORE_V1_6_1_UP, INDICES}, /* circular */
+  {"cmpswap.w",  1, 0x00c00049, 0x0f0000b6, F(BO),   3, ">0D",    "213",
+  		 TRICORE_V1_6_1_UP, INDICES}, /* post increment */
+  {"cmpswap.w",  1, 0x04c00049, 0x0b0000b6, F(BO),   3, "<0D",    "213",
+  		 TRICORE_V1_6_1_UP, INDICES}, /* pre increment */
+  {"crc32",      1, 0x0030004b, 0x0fcf00b4, F(RR),   3, "ddd",    "143",
+  		 TRICORE_V1_6_1_UP, INDICES},
+  {"csub",       1, 0x0020002b, 0x00df00d4, F(RRR),  4, "dddd",  "1254",
+		 TRICORE_GENERIC, INDICES},
+  {"csub.a",     1, 0x00200021, 0x00df00de, F(RRR),  4, "adaa",  "1254",
+		 TRICORE_V1_1, INDICES},
+  {"csubn",      1, 0x0030002b, 0x00cf00d4, F(RRR),  4, "dddd",  "1254",
+		 TRICORE_GENERIC, INDICES},
+  {"csubn.a",    1, 0x00300021, 0x00cf00de, F(RRR),  4, "adaa",  "1254",
+		 TRICORE_V1_1, INDICES},
+  {"debug",      0, 0x0000a000, 0xffff5fff, F(SR),   0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"debug",      1, 0x0100000d, 0xfefffff2, F(SYS),  0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"dextr",      1, 0x00000077, 0x007f0088, F(RRPW), 4, "ddd5",  "1542",
+		 TRICORE_GENERIC, INDICES},
+  {"dextr",      1, 0x00800017, 0x007f00e8, F(RRRR), 4, "dddd",  "1432",
+		 TRICORE_GENERIC, INDICES},
+  {"difsc.a",    1, 0x05000001, 0x0afc00fe, F(RR),   4, "daa2",  "1432",
+		 TRICORE_V1_1, INDICES},
+  {"disable",    1, 0x0340000d, 0xfcbffff2, F(SYS),  0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"disable",    1, 0x03c0000d, 0xfc3ff0f2, F(SYS),  1, "d",     "1",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"div",        1, 0x0201004b, 0x0dfe00b4, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_6_UP, INDICES},
+  {"div.u",      1, 0x0211004b, 0x0dee00b4, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_6_UP, INDICES},
+  {"div.f",      1, 0x0051004b, 0x0fae00b4, F(RR),   3, "ddd",   "143",
+  		 TRICORE_V1_3_UP, INDICES},
+  {"dsync",      1, 0x0480000d, 0xfb7ffff2, F(SYS),  0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"dvadj",      0, 0x00000072, 0xffff008d, F(SRR),  2, "Dd",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"dvadj",      1, 0x0080002b, 0x007f0fd4, F(RRR),  3, "DDd",   "124",
+		 TRICORE_V1_1, INDICES},
+  {"dvadj",      1, 0x00d0006b, 0x002f0f94, F(RRR),  3, "DDd",   "124",
+		 TRICORE_V1_2_UP, INDICES},
+  {"dvinit",     1, 0x0000004f, 0x0fff00b0, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"dvinit",     1, 0x01a0004b, 0x0e5f00b4, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_2_UP, INDICES},
+  {"dvinit.b",   1, 0x0040004f, 0x0fbf00b0, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"dvinit.b",   1, 0x05a0004b, 0x0a5f00b4, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_2_UP, INDICES},
+  {"dvinit.bu",  1, 0x0050004f, 0x0faf00b0, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"dvinit.bu",  1, 0x04a0004b, 0x0b5f00b4, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_2_UP, INDICES},
+  {"dvinit.h",   1, 0x0020004f, 0x0fdf00b0, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"dvinit.h",   1, 0x03a0004b, 0x0c5f00b4, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_2_UP, INDICES},
+  {"dvinit.hu",  1, 0x0030004f, 0x0fcf00b0, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"dvinit.hu",  1, 0x02a0004b, 0x0d5f00b4, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_2_UP, INDICES},
+  {"dvinit.u",   1, 0x0010004f, 0x0fef00b0, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"dvinit.u",   1, 0x00a0004b, 0x0f5f00b4, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_2_UP, INDICES},
+  {"dvstep",     0, 0x00000032, 0xffff00cd, F(SRR),  2, "Dd",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"dvstep",     1, 0x0090002b, 0x006f0fd4, F(RRR),  3, "DDd",   "124",
+		 TRICORE_V1_1, INDICES},
+  {"dvstep",     1, 0x00f0006b, 0x000f0f94, F(RRR),  3, "DDd",   "124",
+		 TRICORE_V1_2_UP, INDICES},
+  {"dvstep.u",   0, 0x000000b2, 0xffff004d, F(SRR),  2, "Dd",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"dvstep.u",   1, 0x00a0002b, 0x005f0fd4, F(RRR),  3, "DDd",   "124",
+		 TRICORE_V1_1, INDICES},
+  {"dvstep.u",   1, 0x00e0006b, 0x001f0f94, F(RRR),  3, "DDd",   "124",
+		 TRICORE_V1_2_UP, INDICES},
+  {"enable",     1, 0x0300000d, 0xfcfffff2, F(SYS),  0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"eq",         0, 0x0000003a, 0xffff00c5, F(SRR),  3, "idd",   "021",
+		 TRICORE_GENERIC, INDICES},
+  {"eq",         0, 0x000000ba, 0xffff0045, F(SRC),  3, "id4",   "021",
+		 TRICORE_GENERIC, INDICES},
+  {"eq",         1, 0x0100000b, 0x0eff00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"eq",         1, 0x0200008b, 0x0de00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"eq.a",       1, 0x04000001, 0x0bff00fe, F(RR),   3, "daa",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"eq.b",       1, 0x0500000b, 0x0aff00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"eq.h",       1, 0x0700000b, 0x08ff00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"eq.w",       1, 0x0900000b, 0x06ff00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"eqany.b",    1, 0x0560000b, 0x0a9f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"eqany.b",    1, 0x0ac0008b, 0x05200074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"eqany.h",    1, 0x0760000b, 0x089f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"eqany.h",    1, 0x0ec0008b, 0x01200074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"eqz.a",      1, 0x04800001, 0x0b7ff0fe, F(RR),   2, "da",    "14",
+		 TRICORE_GENERIC, INDICES},
+  {"extr",       1, 0x00400017, 0x00bff0e8, F(RRRR), 3, "ddD",   "142",
+		 TRICORE_GENERIC, INDICES},
+  {"extr",       1, 0x00400037, 0x0020f0c8, F(RRPW), 4, "dd55",  "1523",
+		 TRICORE_GENERIC, INDICES},
+  {"extr",       1, 0x00400057, 0x00a0f0a8, F(RRRW), 4, "ddd5",  "1523",
+		 TRICORE_GENERIC, INDICES},
+  {"extr.u",     1, 0x00600017, 0x009ff0e8, F(RRRR), 3, "ddD",   "142",
+		 TRICORE_GENERIC, INDICES},
+  {"extr.u",     1, 0x00600037, 0x0000f0c8, F(RRPW), 4, "dd55",  "1523",
+		 TRICORE_GENERIC, INDICES},
+  {"extr.u",     1, 0x00600057, 0x0080f0a8, F(RRRW), 4, "ddd5",  "1523",
+		 TRICORE_GENERIC, INDICES},
+  {"fcall",      1, 0x00000061, 0x0000009e, F(B),    1, "O",     "1",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"fcalla",     1, 0x000000e1, 0x0000001e, F(B),    1, "T",     "1",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"fcalli",     1, 0x0010002d, 0xffeff0d2, F(RR),   1, "a",     "4",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"ftoi",       1, 0x0101004b, 0x0efef0b4, F(RR),   2, "dd",    "14",
+  		 TRICORE_V1_3_UP, INDICES},
+  {"fret",       0, 0x00007000, 0xffff8fff, F(SR),   0, "",     "",
+                 TRICORE_V1_6_UP, INDICES},
+  {"fret",       1, 0x00c0000d, 0xff3ffff2, F(SYS),  0, "",     "",
+                 TRICORE_V1_6_UP, INDICES},
+  {"ftoq31",     1, 0x0111004b, 0x0eee00b4, F(RR),   3, "ddd",   "143",
+  		 TRICORE_V1_3_UP, INDICES},
+  {"ftou",       1, 0x0121004b, 0x0edef0b4, F(RR),   2, "dd",    "14",
+  		 TRICORE_V1_3_UP, INDICES},
+
+  {"ftoiz",      1, 0x0131004b, 0x0ecef0b4, F(RR),   2, "dd",    "14",
+  		 TRICORE_V1_3_1_UP, INDICES},
+  {"ftoq31z",     1, 0x0181004b, 0x0e7e00b4, F(RR),   3, "ddd",   "143",
+  		 TRICORE_V1_3_1_UP, INDICES},
+  {"ftouz",      1, 0x0171004b, 0x0e8ef0b4, F(RR),   2, "dd",    "14",
+  		 TRICORE_V1_3_1_UP, INDICES},
+
+
+  {"ge",         1, 0x0140000b, 0x0ebf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"ge",         1, 0x0280008b, 0x0d600074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"ge.a",       1, 0x04300001, 0x0bcf00fe, F(RR),   3, "daa",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"ge.u",       1, 0x0150000b, 0x0eaf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"ge.u",       1, 0x02a0008b, 0x0d400074, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"imask",      1, 0x00200037, 0x00400fc8, F(RRPW), 4, "Dd55",  "1423",
+		 TRICORE_GENERIC, INDICES},
+  {"imask",      1, 0x00200057, 0x00c00fa8, F(RRRW), 4, "Ddd5",  "1423",
+		 TRICORE_GENERIC, INDICES},
+  {"imask",      1, 0x002000b7, 0x00400f48, F(RCPW), 4, "Df55",  "1423",
+		 TRICORE_GENERIC, INDICES},
+  {"imask",      1, 0x002000d7, 0x00c00f28, F(RCRW), 4, "Dfd5",  "1423",
+		 TRICORE_GENERIC, INDICES},
+  {"ins.t",      1, 0x00000067, 0x00600098, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"insert",     1, 0x00000017, 0x00ff00e8, F(RRRR), 4, "dddD",  "1432",
+		 TRICORE_GENERIC, INDICES},
+  {"insert",     1, 0x00000037, 0x006000c8, F(RRPW), 5, "ddd55", "15423",
+		 TRICORE_GENERIC, INDICES},
+  {"insert",     1, 0x00000057, 0x00e000a8, F(RRRW), 5, "dddd5", "15423",
+		 TRICORE_GENERIC, INDICES},
+  {"insert",     1, 0x00000097, 0x00ff0068, F(RCRR), 4, "ddfD",  "1432",
+		 TRICORE_GENERIC, INDICES},
+  {"insert",     1, 0x000000b7, 0x00600048, F(RCPW), 5, "ddf55", "15423",
+		 TRICORE_GENERIC, INDICES},
+  {"insert",     1, 0x000000d7, 0x00e00028, F(RCRW), 5, "ddfd5", "15423",
+		 TRICORE_GENERIC, INDICES},
+  {"insn.t",     1, 0x00200067, 0x00400098, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"isync",      1, 0x04c0000d, 0xfb3ffff2, F(SYS),  0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"itof",       1, 0x0141004b, 0x0ebef0b4, F(RR),   2, "dd",    "14",
+		 TRICORE_V1_3_UP, INDICES},
+  {"ixmax",      1, 0x00a0006b, 0x005f0f94, F(RRR),  3, "DDd",   "124",
+		 TRICORE_V1_3_UP, INDICES},
+  {"ixmax.u",    1, 0x00b0006b, 0x004f0f94, F(RRR),  3, "DDd",   "124",
+		 TRICORE_V1_3_UP, INDICES},
+  {"ixmin",      1, 0x0080006b, 0x007f0f94, F(RRR),  3, "DDd",   "124",
+		 TRICORE_V1_3_UP, INDICES},
+  {"ixmin.u",    1, 0x0090006b, 0x006f0f94, F(RRR),  3, "DDd",   "124",
+		 TRICORE_V1_3_UP, INDICES},
+  {"j",          0, 0x0000005c, 0xffff00a3, F(SB),   1, "R",     "1",
+		 TRICORE_V1_1, INDICES},
+  {"j",          0, 0x0000003c, 0xffff00c3, F(SB),   1, "R",     "1",
+		 TRICORE_V1_2_UP, INDICES},
+  {"j",          1, 0x0000001d, 0x000000e2, F(B),    1, "O",     "1",
+		 TRICORE_GENERIC, INDICES},
+  {"ja",         1, 0x0000009d, 0x00000062, F(B),    1, "T",     "1",
+		 TRICORE_GENERIC, INDICES},
+  {"jeq",        0, 0x0000001e, 0xffff00e1, F(SBR),  3, "idm",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"jeq",        0, 0x0000006e, 0xffff0091, F(SBC),  3, "i4m",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"jeq",        0, 0x000000be, 0xffff0041, F(SBR),  3, "idx",   "012",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"jeq",        0, 0x0000009e, 0xffff0061, F(SBC),  3, "i4x",   "012",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"jeq",        0, 0x0000003e, 0xffff00c1, F(SBR),  3, "idm",   "012",
+		 TRICORE_V1_3_UP, INDICES},
+  {"jeq",        0, 0x0000001e, 0xffff00e1, F(SBC),  3, "i4m",   "012",
+		 TRICORE_V1_2_UP, INDICES},
+  {"jeq",        1, 0x0000005f, 0x800000a0, F(BRR),  3, "ddo",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jeq",        1, 0x000000df, 0x80000020, F(BRC),  3, "d4o",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jeq.a",      1, 0x0000007d, 0x80000082, F(BRR),  3, "aao",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jge",        1, 0x0000007f, 0x80000080, F(BRR),  3, "ddo",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jge",        1, 0x000000ff, 0x80000000, F(BRC),  3, "d4o",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jge.u",      1, 0x8000007f, 0x00000080, F(BRR),  3, "ddo",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jge.u",      1, 0x800000ff, 0x00000000, F(BRC),  3, "dfo",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jgez",       0, 0x000000fe, 0xffff0001, F(SBR),  2, "dm",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"jgez",       0, 0x000000ce, 0xffff0031, F(SBR),  2, "dm",    "12",
+		 TRICORE_V1_2_UP, INDICES},
+  {"jgtz",       0, 0x0000007e, 0xffff0081, F(SBR),  2, "dm",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"jgtz",       0, 0x0000004e, 0xffff00b1, F(SBR),  2, "dm",    "12",
+		 TRICORE_V1_6_1_DN, INDICES},
+  {"ji",         0, 0x0000003c, 0xffff0fc3, F(SBR),  1, "a",     "1",
+		 TRICORE_V1_1, INDICES},
+  {"ji",         0, 0x000000dc, 0xfffff023, F(SR),   1, "a",     "1",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ji",         1, 0x0030002d, 0xffcf0fd2, F(RR),   1, "a",     "3",
+		 TRICORE_V1_1, INDICES},
+  {"ji",         1, 0x0030002d, 0xffcff0d2, F(RR),   1, "a",     "4",
+		 TRICORE_V1_2_UP, INDICES},
+  {"jl",         1, 0x0000005d, 0x000000a2, F(B),    1, "O",     "1",
+		 TRICORE_GENERIC, INDICES},
+  {"jla",        1, 0x000000dd, 0x00000022, F(B),    1, "T",     "1",
+		 TRICORE_GENERIC, INDICES},
+  {"jlez",       0, 0x000000be, 0xffff0041, F(SBR),  2, "dm",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"jlez",       0, 0x0000008e, 0xffff0071, F(SBR),  2, "dm",    "12",
+		 TRICORE_V1_2_UP, INDICES},
+  {"jli",        1, 0x0020002d, 0xffdf0fd2, F(RR),   1, "a",     "3",
+		 TRICORE_V1_1, INDICES},
+  {"jli",        1, 0x0020002d, 0xffdff0d2, F(RR),   1, "a",     "4",
+		 TRICORE_V1_2_UP, INDICES},
+  {"jlt",        1, 0x0000003f, 0x800000c0, F(BRR),  3, "ddo",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jlt",        1, 0x000000bf, 0x80000040, F(BRC),  3, "d4o",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jlt.u",      1, 0x8000003f, 0x000000c0, F(BRR),  3, "ddo",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jlt.u",      1, 0x800000bf, 0x00000040, F(BRC),  3, "dfo",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jltz",       0, 0x0000003e, 0xffff00c1, F(SBR),  2, "dm",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"jltz",       0, 0x0000000e, 0xffff00f1, F(SBR),  2, "dm",    "12",
+		 TRICORE_V1_6_1_DN, INDICES},
+  {"jne",        0, 0x0000009e, 0xffff0061, F(SBR),  3, "idm",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"jne",        0, 0x000000ee, 0xffff0011, F(SBC),  3, "i4m",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"jne",        0, 0x000000fe, 0xffff0001, F(SBR),  3, "idx",   "012",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"jne",        0, 0x000000de, 0xffff0021, F(SBC),  3, "i4x",   "012",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"jne",        0, 0x0000007e, 0xffff0081, F(SBR),  3, "idm",   "012",
+		 TRICORE_V1_2_UP, INDICES},
+  {"jne",        0, 0x0000005e, 0xffff00a1, F(SBC),  3, "i4m",   "012",
+		 TRICORE_V1_2_UP, INDICES},
+  {"jne",        1, 0x8000005f, 0x000000a0, F(BRR),  3, "ddo",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jne",        1, 0x800000df, 0x00000020, F(BRC),  3, "d4o",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jne.a",      1, 0x8000007d, 0x00000082, F(BRR),  3, "aao",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jned",       1, 0x8000001f, 0x000000e0, F(BRR),  3, "ddo",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jned",       1, 0x8000009f, 0x00000060, F(BRC),  3, "d4o",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jnei",       1, 0x0000001f, 0x800000e0, F(BRR),  3, "ddo",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jnei",       1, 0x0000009f, 0x80000060, F(BRC),  3, "d4o",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jnz",        0, 0x000000ae, 0xffff0051, F(SB),   2, "iR",    "01",
+		 TRICORE_V1_1, INDICES},
+  {"jnz",        0, 0x000000ee, 0xffff0011, F(SB),   2, "iR",    "01",
+		 TRICORE_V1_2_UP, INDICES},
+  {"jnz",        0, 0x000000de, 0xffff0021, F(SBR),  2, "dm",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"jnz",        0, 0x000000f6, 0xffff0009, F(SBR),  2, "dm",    "12",
+		 TRICORE_V1_2_UP, INDICES},
+  {"jnz.a",      0, 0x0000007c, 0xffff0083, F(SBR),  2, "am",    "12",
+  		 TRICORE_V1_1 | TRICORE_V1_6_1_DN, INDICES},
+  {"jnz.a",      1, 0x800000bd, 0x0000f042, F(BRR),  2, "ao",    "31",
+		 TRICORE_GENERIC, INDICES},
+  {"jnz.t",      0, 0x0000004e, 0xffff0031, F(SBRN), 3, "i5m",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"jnz.t",      0, 0x000000ae, 0xffff0051, F(SBRN), 3, "ifm",   "012",
+		 TRICORE_V1_2_UP, INDICES},
+  {"jnz.t",      1, 0x8000006f, 0x00000010, F(BRN),  3, "d5o",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"jz",         0, 0x0000002e, 0xffff00d1, F(SB),   2, "iR",    "01",
+		 TRICORE_V1_1, INDICES},
+  {"jz",         0, 0x0000006e, 0xffff0091, F(SB),   2, "iR",    "01",
+		 TRICORE_V1_2_UP, INDICES},
+  {"jz",         0, 0x0000005e, 0xffff00a1, F(SBR),  2, "dm",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"jz",         0, 0x00000076, 0xffff0089, F(SBR),  2, "dm",    "12",
+		 TRICORE_V1_6_1_DN, INDICES},
+  {"jz.a",       0, 0x000000bc, 0xffff0043, F(SBR),  2, "am",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"jz.a",       1, 0x000000bd, 0x8000f042, F(BRR),  2, "ao",    "31",
+		 TRICORE_GENERIC, INDICES},
+  {"jz.t",       0, 0x0000000e, 0xffff0071, F(SBRN), 3, "i5m",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"jz.t",       0, 0x0000002e, 0xffff00d1, F(SBRN), 3, "ifm",   "012",
+		 TRICORE_V1_2_UP, INDICES},
+  {"jz.t",       1, 0x0000006f, 0x80000010, F(BRN),  3, "d5o",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.a",       0, 0x000000d8, 0xffff0027, F(SC),   3, "I&k",   "001",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.a",       0, 0x0000000c, 0xffff00f3, F(SLRO), 3, "aS6",   "201",
+		 TRICORE_V1_1, INDICES},
+  {"ld.a",       0, 0x000000c8, 0xffff0037, F(SLRO), 3, "aS6",   "201",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.a",       0, 0x00000028, 0xffff00d7, F(SRO),  3, "I@6",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"ld.a",       0, 0x000000cc, 0xffff0033, F(SRO),  3, "I@6",   "012",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.a",       0, 0x00000064, 0xffff009b, F(SLR),  2, "a>",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"ld.a",       0, 0x000000c4, 0xffff003b, F(SLR),  2, "a>",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.a",       0, 0x000000b8, 0xffff0047, F(SLR),  2, "a@",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"ld.a",       0, 0x000000d4, 0xffff002b, F(SLR),  2, "a@",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.a",       1, 0x00000099, 0x00000066, F(BOL),  3, "a@w",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.a",       1, 0x01800009, 0x0e4000f6, F(BO),   3, "a>0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.a",       1, 0x01800029, 0xfe7f00d6, F(BO),   2, "a#",    "32",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.a",       1, 0x05800009, 0x0a4000f6, F(BO),   3, "a<0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.a",       1, 0x05800029, 0x0a4000d6, F(BO),   3, "a*0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.a",       1, 0x08000085, 0x0400007a, F(ABS),  2, "at",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.a",       1, 0x09800009, 0x064000f6, F(BO),   3, "a@0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.b",       0, 0x00000008, 0xffff00f7, F(SRO),  3, "i@f",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"ld.b",       0, 0x00000034, 0xffff00cb, F(SLRO), 3, "dSf",   "201",
+		 TRICORE_V1_1, INDICES},
+  {"ld.b",       0, 0x00000044, 0xffff00bb, F(SLR),  2, "d>",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"ld.b",       0, 0x00000098, 0xffff0067, F(SLR),  2, "d@",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"ld.b",       1, 0x00000079, 0x00000086, F(BOL),  3, "d@w",   "321",
+		 TRICORE_V1_6_UP, INDICES}, // TC1.6
+  {"ld.b",       1, 0x00000005, 0x0c0000fa, F(ABS),  2, "dt",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.b",       1, 0x00000009, 0x0fc000f6, F(BO),   3, "d>0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.b",       1, 0x00000029, 0xffff00d6, F(BO),   2, "d#",    "32",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.b",       1, 0x04000009, 0x0bc000f6, F(BO),   3, "d<0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.b",       1, 0x04000029, 0x0bc000d6, F(BO),   3, "d*0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.b",       1, 0x08000009, 0x07c000f6, F(BO),   3, "d@0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.bu",      0, 0x00000058, 0xffff00a7, F(SLR),  2, "d@",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"ld.bu",      0, 0x00000014, 0xffff00eb, F(SLR),  2, "d@",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.bu",      0, 0x00000088, 0xffff0077, F(SRO),  3, "i@f",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"ld.bu",      0, 0x0000000c, 0xffff00f3, F(SRO),  3, "i@f",   "012",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.bu",      0, 0x000000b4, 0xffff004b, F(SLRO), 3, "dSf",   "201",
+		 TRICORE_V1_1, INDICES},
+  {"ld.bu",      0, 0x00000008, 0xffff00f7, F(SLRO), 3, "dSf",   "201",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.bu",      0, 0x000000c4, 0xffff003b, F(SLR),  2, "d>",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"ld.bu",      0, 0x00000004, 0xffff00fb, F(SLR),  2, "d>",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.bu",      1, 0x00000039, 0x000000c6, F(BOL),  3, "d@w",   "321",
+		 TRICORE_V1_6_UP, INDICES}, // TC1.6
+  {"ld.bu",      1, 0x00400009, 0x0f8000f6, F(BO),   3, "d>0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.bu",      1, 0x00400029, 0xffbf00d6, F(BO),   2, "d#",    "32",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.bu",      1, 0x04000005, 0x080000fa, F(ABS),  2, "dt",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.bu",      1, 0x04400009, 0x0b8000f6, F(BO),   3, "d<0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.bu",      1, 0x04400029, 0x0b8000d6, F(BO),   3, "d*0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.bu",      1, 0x08400009, 0x078000f6, F(BO),   3, "d@0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.d",       1, 0x01400009, 0x0e8000f6, F(BO),   3, "D>0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.d",       1, 0x01400029, 0xfebf00d6, F(BO),   2, "D#",    "32",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.d",       1, 0x04000085, 0x0800007a, F(ABS),  2, "Dt",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.d",       1, 0x05400009, 0x0a8000f6, F(BO),   3, "D<0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.d",       1, 0x05400029, 0x0a8000d6, F(BO),   3, "D*0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.d",       1, 0x09400009, 0x068000f6, F(BO),   3, "D@0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.da",      1, 0x01c00009, 0x0e0000f6, F(BO),   3, "A>0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.da",      1, 0x01c00029, 0xfe3f00d6, F(BO),   2, "A#",    "32",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.da",      1, 0x05c00009, 0x0a0000f6, F(BO),   3, "A<0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.da",      1, 0x05c00029, 0x0a0000d6, F(BO),   3, "A*0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.da",      1, 0x09c00009, 0x060000f6, F(BO),   3, "A@0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.da",      1, 0x0c000085, 0x0000007a, F(ABS),  2, "At",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.h",       0, 0x00000024, 0xffff00db, F(SLR),  2, "d>",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"ld.h",       0, 0x00000084, 0xffff007b, F(SLR),  2, "d>",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.h",       0, 0x00000048, 0xffff00b7, F(SRO),  3, "i@v",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"ld.h",       0, 0x0000008c, 0xffff0073, F(SRO),  3, "i@v",   "012",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.h",       0, 0x00000074, 0xffff008b, F(SLRO), 3, "dSv",   "201",
+		 TRICORE_V1_1, INDICES},
+  {"ld.h",       0, 0x00000088, 0xffff0077, F(SLRO), 3, "dSv",   "201",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.h",       0, 0x000000d8, 0xffff0027, F(SLR),  2, "d@",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"ld.h",       0, 0x00000094, 0xffff006b, F(SLR),  2, "d@",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.h",       1, 0x000000c9, 0x00000036, F(BOL),  3, "d@w",   "321",
+		 TRICORE_V1_6_UP, INDICES}, // TC1.6
+  {"ld.h",       1, 0x00800009, 0x0f4000f6, F(BO),   3, "d>0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.h",       1, 0x00800029, 0xff7f00d6, F(BO),   2, "d#",    "32",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.h",       1, 0x04800009, 0x0b4000f6, F(BO),   3, "d<0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.h",       1, 0x04800029, 0x0b4000d6, F(BO),   3, "d*0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.h",       1, 0x08000005, 0x040000fa, F(ABS),  2, "dt",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.h",       1, 0x08800009, 0x074000f6, F(BO),   3, "d@0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.hu",      1, 0x000000b9, 0x00000046, F(BOL),  3, "d@w",   "321",
+		 TRICORE_V1_6_UP, INDICES}, // TC1.6
+  {"ld.hu",      1, 0x00c00009, 0x0f0000f6, F(BO),   3, "d>0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.hu",      1, 0x00c00029, 0xff3f00d6, F(BO),   2, "d#",    "32",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.hu",      1, 0x04c00009, 0x0b0000f6, F(BO),   3, "d<0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.hu",      1, 0x04c00029, 0x0b0000d6, F(BO),   3, "d*0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.hu",      1, 0x08c00009, 0x070000f6, F(BO),   3, "d@0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.hu",      1, 0x0c000005, 0x000000fa, F(ABS),  2, "dt",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.q",       1, 0x00000045, 0x0c0000ba, F(ABS),  2, "dt",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.q",       1, 0x02000009, 0x0dc000f6, F(BO),   3, "d>0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.q",       1, 0x02000029, 0xfdff00d6, F(BO),   2, "d#",    "32",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.q",       1, 0x06000009, 0x09c000f6, F(BO),   3, "d<0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.q",       1, 0x06000029, 0x09c000d6, F(BO),   3, "d*0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.q",       1, 0x0a000009, 0x05c000f6, F(BO),   3, "d@0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.w",       0, 0x00000058, 0xffff00a7, F(SC),   3, "i&k",   "001",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.w",       0, 0x00000038, 0xffff00c7, F(SLR),  2, "d@",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"ld.w",       0, 0x00000054, 0xffff00ab, F(SLR),  2, "d@",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.w",       0, 0x000000a4, 0xffff005b, F(SLR),  2, "d>",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"ld.w",       0, 0x00000044, 0xffff00bb, F(SLR),  2, "d>",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.w",       0, 0x000000c8, 0xffff0037, F(SRO),  3, "i@6",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"ld.w",       0, 0x0000004c, 0xffff00b3, F(SRO),  3, "i@6",   "012",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.w",       0, 0x000000f4, 0xffff000b, F(SLRO), 3, "dS6",   "201",
+		 TRICORE_V1_1, INDICES},
+  {"ld.w",       0, 0x00000048, 0xffff00b7, F(SLRO), 3, "dS6",   "201",
+		 TRICORE_V1_2_UP, INDICES},
+  {"ld.w",       1, 0x00000019, 0x000000e6, F(BOL),  3, "d@w",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.w",       1, 0x00000085, 0x0c00007a, F(ABS),  2, "dt",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.w",       1, 0x01000009, 0x0ec000f6, F(BO),   3, "d>0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.w",       1, 0x01000029, 0xfeff00d6, F(BO),   2, "d#",    "32",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.w",       1, 0x05000009, 0x0ac000f6, F(BO),   3, "d<0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.w",       1, 0x05000029, 0x0ac000d6, F(BO),   3, "d*0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ld.w",       1, 0x09000009, 0x06c000f6, F(BO),   3, "d@0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"ldlcx",      1, 0x08000015, 0x04000fea, F(ABS),  1, "t",     "1",
+		 TRICORE_GENERIC, INDICES},
+  {"ldlcx",      1, 0x09000049, 0x06c00fb6, F(BO),   2, "@0",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"ldmst",      1, 0x00400049, 0x0f8000b6, F(BO),   3, ">0D",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"ldmst",      1, 0x00400069, 0xffbf0096, F(BO),   2, "#D",    "23",
+		 TRICORE_GENERIC, INDICES},
+  {"ldmst",      1, 0x040000e5, 0x0800001a, F(ABS),  2, "tD",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"ldmst",      1, 0x04400049, 0x0b8000b6, F(BO),   3, "<0D",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"ldmst",      1, 0x04400069, 0x0b800096, F(BO),   3, "*0D",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"ldmst",      1, 0x08400049, 0x078000b6, F(BO),   3, "@0D",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"lducx",      1, 0x09400049, 0x06800fb6, F(BO),   2, "@0",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"lducx",      1, 0x0c000015, 0x00000fea, F(ABS),  1, "t",     "1",
+		 TRICORE_GENERIC, INDICES},
+  {"lea",        1, 0x000000c5, 0x0c00003a, F(ABS),  2, "at",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"lea",        1, 0x000000d9, 0x00000026, F(BOL),  3, "a@w",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"lea",        1, 0x0a000049, 0x05c000b6, F(BO),   3, "a@0",   "321",
+		 TRICORE_GENERIC, INDICES},
+  {"loop",       0, 0x000000fc, 0xffff0003, F(SBR),  2, "ar",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"loop",       1, 0x000000fd, 0x80000f02, F(BRR),  2, "ao",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"loopu",      1, 0x800000fd, 0x0000ff02, F(BRR),  1, "o",     "1",
+		 TRICORE_V1_2_UP, INDICES},
+  {"lt",         0, 0x0000007a, 0xffff0085, F(SRR),  3, "idd",   "021",
+		 TRICORE_GENERIC, INDICES},
+  {"lt",         0, 0x000000fa, 0xffff0005, F(SRC),  3, "id4",   "021",
+		 TRICORE_GENERIC, INDICES},
+  {"lt",         1, 0x0120000b, 0x0edf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"lt",         1, 0x0240008b, 0x0da00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"lt.a",       1, 0x04200001, 0x0bdf00fe, F(RR),   3, "daa",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"lt.b",       1, 0x0520000b, 0x0adf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"lt.bu",      1, 0x0530000b, 0x0acf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"lt.h",       1, 0x0720000b, 0x08df00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"lt.hu",      1, 0x0730000b, 0x08cf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"lt.u",       0, 0x00000006, 0xffff00f9, F(SRR),  3, "idd",   "021",
+		 TRICORE_V1_1, INDICES},
+  {"lt.u",       0, 0x00000086, 0xffff0079, F(SRC),  3, "idf",   "021",
+		 TRICORE_V1_1, INDICES},
+  {"lt.u",       1, 0x0130000b, 0x0ecf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"lt.u",       1, 0x0260008b, 0x0d800074, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"lt.w",       1, 0x0920000b, 0x06df00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"lt.wu",      1, 0x0930000b, 0x06cf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"madd",       1, 0x000a0003, 0x00f500fc, F(RRR2), 4, "dddd",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"madd",       1, 0x00200013, 0x00c000ec, F(RCR),  4, "ddd9",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"madd",       1, 0x00600013, 0x008000ec, F(RCR),  4, "DDd9",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd",       1, 0x006a0003, 0x009500fc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.f",     1, 0x0061006b, 0x009e0094, F(RRR),  4, "dddd",  "1254",
+		 TRICORE_V1_3_UP, INDICES},
+  {"madd.h",     1, 0x00600083, 0x009c007c, F(RRR1), 5, "DDdd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"madd.h",     1, 0x00600083, 0x009c007c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.h",     1, 0x00640083, 0x0098007c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.h",     1, 0x00680083, 0x0094007c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.h",     1, 0x006c0083, 0x0090007c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.q",     1, 0x00100043, 0x00ec00bc, F(RRR1), 5, "dddd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"madd.q",     1, 0x00100043, 0x00ec00bc, F(RRR1), 5, "ddGG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.q",     1, 0x00000043, 0x00fc00bc, F(RRR1), 5, "dddG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.q",     1, 0x00040043, 0x00f800bc, F(RRR1), 5, "dddg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.q",     1, 0x00080043, 0x00f400bc, F(RRR1), 5, "dddd1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.q",     1, 0x00140043, 0x00e800bc, F(RRR1), 5, "ddgg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.q",     1, 0x00600043, 0x009c00bc, F(RRR1), 5, "DDdG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.q",     1, 0x00640043, 0x009800bc, F(RRR1), 5, "DDdg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.q",     1, 0x006c0043, 0x009000bc, F(RRR1), 5, "DDdd1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.q",     1, 0x00700043, 0x008c00bc, F(RRR1), 5, "DDGG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.q",     1, 0x00740043, 0x008800bc, F(RRR1), 5, "DDgg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.u",     1, 0x00400013, 0x00a000ec, F(RCR),  4, "DDdn",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madd.u",     1, 0x00680003, 0x009700fc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddm",      1, 0x00600013, 0x008000ec, F(RCR),  4, "DDd9",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"maddm",      1, 0x006a0003, 0x009500fc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"maddm.h",    1, 0x00700083, 0x008f007c, F(RRR1), 4, "DDdd",  "1254",
+		 TRICORE_V1_1, INDICES},
+  {"maddm.h",    1, 0x00700083, 0x008c007c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddm.h",    1, 0x00740083, 0x0088007c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddm.h",    1, 0x00780083, 0x0084007c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddm.h",    1, 0x007c0083, 0x0080007c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddm.q",    1, 0x00700043, 0x008f00bc, F(RRR1), 4, "DDdd",  "1254",
+		 TRICORE_V1_1, INDICES},
+  {"maddm.u",    1, 0x00400013, 0x00a000ec, F(RCR),  4, "DDdn",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"maddm.u",    1, 0x00680003, 0x009700fc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"maddms",     1, 0x00e00013, 0x000000ec, F(RCR),  4, "DDd9",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"maddms",     1, 0x00ea0003, 0x001500fc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"maddms.h",   1, 0x00f00083, 0x000c007c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddms.h",   1, 0x00f40083, 0x0008007c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddms.h",   1, 0x00f80083, 0x0004007c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddms.h",   1, 0x00fc0083, 0x0000007c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddms.u",   1, 0x00c00013, 0x002000ec, F(RCR),  4, "DDdn",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"maddms.u",   1, 0x00e80003, 0x001700fc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"maddr.h",    1, 0x00780043, 0x008400bc, F(RRR1), 5, "dDdd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"maddr.h",    1, 0x00780043, 0x008400bc, F(RRR1), 5, "dDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddr.h",    1, 0x00300083, 0x00cc007c, F(RRR1), 5, "dddL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddr.h",    1, 0x00340083, 0x00c8007c, F(RRR1), 5, "dddl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddr.h",    1, 0x00380083, 0x00c4007c, F(RRR1), 5, "ddd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddr.h",    1, 0x003c0083, 0x00c0007c, F(RRR1), 5, "ddd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddr.q",    1, 0x00180043, 0x00e400bc, F(RRR1), 5, "dddd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"maddr.q",    1, 0x00180043, 0x00e400bc, F(RRR1), 5, "ddGG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddr.q",    1, 0x001c0043, 0x00e000bc, F(RRR1), 5, "ddgg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddrs.h",   1, 0x00f80043, 0x000400bc, F(RRR1), 5, "dDdd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"maddrs.h",   1, 0x00f80043, 0x000400bc, F(RRR1), 5, "dDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddrs.h",   1, 0x00b00083, 0x004c007c, F(RRR1), 5, "dddL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddrs.h",   1, 0x00b40083, 0x0048007c, F(RRR1), 5, "dddl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddrs.h",   1, 0x00b80083, 0x0044007c, F(RRR1), 5, "ddd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddrs.h",   1, 0x00bc0083, 0x0040007c, F(RRR1), 5, "ddd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddrs.q",   1, 0x00980043, 0x006400bc, F(RRR1), 5, "dddd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"maddrs.q",   1, 0x00980043, 0x006400bc, F(RRR1), 5, "ddGG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddrs.q",   1, 0x009c0043, 0x006000bc, F(RRR1), 5, "ddgg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds",      1, 0x008a0003, 0x007500fc, F(RRR2), 4, "dddd",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"madds",      1, 0x00a00013, 0x004000ec, F(RCR),  4, "ddd9",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"madds",      1, 0x00e00013, 0x000000ec, F(RCR),  4, "DDd9",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds",      1, 0x00ea0003, 0x001500fc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.h",    1, 0x00e00083, 0x001c007c, F(RRR1), 5, "DDdd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"madds.h",    1, 0x00e00083, 0x001c007c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.h",    1, 0x00e40083, 0x0018007c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.h",    1, 0x00e80083, 0x0014007c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.h",    1, 0x00ec0083, 0x0010007c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.q",    1, 0x00900043, 0x006c00bc, F(RRR1), 5, "dddd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"madds.q",    1, 0x00900043, 0x006c00bc, F(RRR1), 5, "ddGG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.q",    1, 0x00800043, 0x007c00bc, F(RRR1), 5, "dddG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.q",    1, 0x00840043, 0x007800bc, F(RRR1), 5, "dddg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.q",    1, 0x00880043, 0x007400bc, F(RRR1), 5, "dddd1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.q",    1, 0x00940043, 0x006800bc, F(RRR1), 5, "ddgg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.q",    1, 0x00e00043, 0x001c00bc, F(RRR1), 5, "DDdG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.q",    1, 0x00e40043, 0x001800bc, F(RRR1), 5, "DDdg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.q",    1, 0x00ec0043, 0x001000bc, F(RRR1), 5, "DDdd1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.q",    1, 0x00f00043, 0x000c00bc, F(RRR1), 5, "DDGG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.q",    1, 0x00f40043, 0x000800bc, F(RRR1), 5, "DDgg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.u",    1, 0x00800013, 0x006000ec, F(RCR),  4, "dddn",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"madds.u",    1, 0x00880003, 0x007700fc, F(RRR2), 4, "dddd",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"madds.u",    1, 0x00c00013, 0x002000ec, F(RCR),  4, "DDdn",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"madds.u",    1, 0x00e80003, 0x001700fc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsu.h",   1, 0x006000c3, 0x009c003c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsu.h",   1, 0x006400c3, 0x0098003c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsu.h",   1, 0x006800c3, 0x0094003c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsu.h",   1, 0x006c00c3, 0x0090003c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsum.h",  1, 0x007000c3, 0x008c003c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsum.h",  1, 0x007400c3, 0x0088003c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsum.h",  1, 0x007800c3, 0x0084003c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsum.h",  1, 0x007c00c3, 0x0080003c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsums.h", 1, 0x00f000c3, 0x000c003c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsums.h", 1, 0x00f400c3, 0x0008003c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsums.h", 1, 0x00f800c3, 0x0004003c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsums.h", 1, 0x00fc00c3, 0x0000003c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsur.h",  1, 0x003000c3, 0x00cc003c, F(RRR1), 5, "dddL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsur.h",  1, 0x003400c3, 0x00c8003c, F(RRR1), 5, "dddl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsur.h",  1, 0x003800c3, 0x00c4003c, F(RRR1), 5, "ddd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsur.h",  1, 0x003c00c3, 0x00c0003c, F(RRR1), 5, "ddd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsurs.h", 1, 0x00b000c3, 0x004c003c, F(RRR1), 5, "dddL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsurs.h", 1, 0x00b400c3, 0x0048003c, F(RRR1), 5, "dddl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsurs.h", 1, 0x00b800c3, 0x0044003c, F(RRR1), 5, "ddd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsurs.h", 1, 0x00bc00c3, 0x0040003c, F(RRR1), 5, "ddd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsus.h",  1, 0x00e000c3, 0x001c003c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsus.h",  1, 0x00e400c3, 0x0018003c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsus.h",  1, 0x00e800c3, 0x0014003c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"maddsus.h",  1, 0x00ec00c3, 0x0010003c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"max",        1, 0x01a0000b, 0x0e5f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"max",        1, 0x0340008b, 0x0ca00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"max.b",      1, 0x05a0000b, 0x0a5f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"max.bu",     1, 0x05b0000b, 0x0a4f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"max.h",      1, 0x07a0000b, 0x085f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"max.hu",     1, 0x07b0000b, 0x084f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"max.u",      1, 0x01b0000b, 0x0e4f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"max.u",      1, 0x0360008b, 0x0c800074, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"mfcr",       1, 0x0000004d, 0x00000fb2, F(RLC),  2, "dW",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"min",        1, 0x0180000b, 0x0e7f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"min",        1, 0x0300008b, 0x0ce00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"min.b",      1, 0x0580000b, 0x0a7f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"min.bu",     1, 0x0590000b, 0x0a6f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"min.h",      1, 0x0780000b, 0x087f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"min.hu",     1, 0x0790000b, 0x086f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"min.u",      1, 0x0190000b, 0x0e6f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"min.u",      1, 0x0320008b, 0x0cc00074, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"mov",        0, 0x00000002, 0xffff00fd, F(SRR),  2, "dd",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"mov",        0, 0x00000082, 0xffff007d, F(SRC),  2, "d4",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"mov",        0, 0x000000d2, 0xffff002d, F(SRC),  2, "D4",    "21",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"mov",        0, 0x000000c6, 0xffff0039, F(SC),   2, "i8",    "01",
+		 TRICORE_V1_1, INDICES},
+  {"mov",        0, 0x000000da, 0xffff0025, F(SC),   2, "i8",    "01",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mov",        1, 0x0000003b, 0x00000fc4, F(RLC),  2, "dw",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"mov",        1, 0x01f0000b, 0x0e0f0ff4, F(RR),   2, "dd",    "13",
+		 TRICORE_GENERIC, INDICES},
+  {"mov",        1, 0x000000fb, 0x00000f04, F(RLC),  2, "Dw",    "12",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"mov",        1, 0x0800000b, 0x07ff0ff4, F(RR),   2, "Dd",    "13",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"mov",        1, 0x0810000b, 0x07ef00f4, F(RR),   3, "Ddd",   "143",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"mov.a",      0, 0x000000a0, 0xffff005f, F(SRC),  2, "af",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mov.a",      0, 0x00000030, 0xffff00cf, F(SRR),  2, "ad",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"mov.a",      0, 0x00000060, 0xffff009f, F(SRR),  2, "ad",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mov.a",      1, 0x06300001, 0x09cf0ffe, F(RR),   2, "ad",    "13",
+		 TRICORE_GENERIC, INDICES},
+  {"mov.aa",     0, 0x00000080, 0xffff007f, F(SRR),  2, "aa",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"mov.aa",     0, 0x00000040, 0xffff00bf, F(SRR),  2, "aa",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mov.aa",     1, 0x00000001, 0x0fff0ffe, F(RR),   2, "aa",    "13",
+		 TRICORE_GENERIC, INDICES},
+  {"mov.d",      0, 0x00000020, 0xffff00df, F(SRR),  2, "da",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"mov.d",      0, 0x00000080, 0xffff007f, F(SRR),  2, "da",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mov.d",      1, 0x04c00001, 0x0b3f0ffe, F(RR),   2, "da",    "13",
+		 TRICORE_GENERIC, INDICES},
+  {"mov.u",      1, 0x000000bb, 0x00000f44, F(RLC),  2, "dW",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"movh",       1, 0x0000007b, 0x00000f84, F(RLC),  2, "dW",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"movh.a",     1, 0x00000091, 0x00000f6e, F(RLC),  2, "aW",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"movz.a",     0, 0x00001000, 0xffffe0ff, F(SR),   1, "a",     "1",
+		 TRICORE_V1_1, INDICES},
+  {"msub",       1, 0x000a0023, 0x00f500dc, F(RRR2), 4, "dddd",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"msub",       1, 0x00200033, 0x00c000cc, F(RCR),  4, "ddd9",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"msub",       1, 0x00600033, 0x008000cc, F(RCR),  4, "DDd9",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub",       1, 0x006a0023, 0x009500dc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.f",     1, 0x0071006b, 0x008e0094, F(RRR),  4, "dddd",  "1254",
+		 TRICORE_V1_3_UP, INDICES},
+  {"msub.h",     1, 0x006000a3, 0x009c005c, F(RRR1), 5, "DDdd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"msub.h",     1, 0x006000a3, 0x009c005c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.h",     1, 0x006400a3, 0x0098005c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.h",     1, 0x006800a3, 0x0094005c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.h",     1, 0x006c00a3, 0x0090005c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.q",     1, 0x00100063, 0x00ec009c, F(RRR1), 5, "dddd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"msub.q",     1, 0x00100063, 0x00ec009c, F(RRR1), 5, "ddGG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.q",     1, 0x00000063, 0x00fc009c, F(RRR1), 5, "dddG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.q",     1, 0x00040063, 0x00f8009c, F(RRR1), 5, "dddg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.q",     1, 0x00080063, 0x00f4009c, F(RRR1), 5, "dddd1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.q",     1, 0x00140063, 0x00e8009c, F(RRR1), 5, "ddgg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.q",     1, 0x00600063, 0x009c009c, F(RRR1), 5, "DDdG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.q",     1, 0x00640063, 0x0098009c, F(RRR1), 5, "DDdg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.q",     1, 0x006c0063, 0x0090009c, F(RRR1), 5, "DDdd1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.q",     1, 0x00700063, 0x008c009c, F(RRR1), 5, "DDGG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.q",     1, 0x00740063, 0x0088009c, F(RRR1), 5, "DDgg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.u",     1, 0x00400033, 0x00a000cc, F(RCR),  4, "DDdn",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msub.u",     1, 0x00680023, 0x009700dc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubad.h",   1, 0x006000e3, 0x009c001c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubad.h",   1, 0x006400e3, 0x0098001c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubad.h",   1, 0x006800e3, 0x0094001c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubad.h",   1, 0x006c00e3, 0x0090001c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadm.h",  1, 0x007000e3, 0x008c001c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadm.h",  1, 0x007400e3, 0x0088001c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadm.h",  1, 0x007800e3, 0x0084001c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadm.h",  1, 0x007c00e3, 0x0080001c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadms.h", 1, 0x00f000e3, 0x000c001c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadms.h", 1, 0x00f400e3, 0x0008001c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadms.h", 1, 0x00f800e3, 0x0004001c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadms.h", 1, 0x00fc00e3, 0x0000001c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadr.h",  1, 0x003000e3, 0x00cc001c, F(RRR1), 5, "dddL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadr.h",  1, 0x003400e3, 0x00c8001c, F(RRR1), 5, "dddl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadr.h",  1, 0x003800e3, 0x00c4001c, F(RRR1), 5, "ddd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadr.h",  1, 0x003c00e3, 0x00c0001c, F(RRR1), 5, "ddd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadrs.h", 1, 0x00b000e3, 0x004c001c, F(RRR1), 5, "dddL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadrs.h", 1, 0x00b400e3, 0x0048001c, F(RRR1), 5, "dddl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadrs.h", 1, 0x00b800e3, 0x0044001c, F(RRR1), 5, "ddd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubadrs.h", 1, 0x00bc00e3, 0x0040001c, F(RRR1), 5, "ddd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubads.h",  1, 0x00e000e3, 0x001c001c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubads.h",  1, 0x00e400e3, 0x0018001c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubads.h",  1, 0x00e800e3, 0x0014001c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubads.h",  1, 0x00ec00e3, 0x0010001c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubm",      1, 0x00600033, 0x008000cc, F(RCR),  4, "DDd9",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"msubm",      1, 0x006a0023, 0x009500dc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"msubm.h",    1, 0x007000a3, 0x008f005c, F(RRR1), 4, "DDdd",  "1254",
+		 TRICORE_V1_1, INDICES},
+  {"msubm.h",    1, 0x007000a3, 0x008c005c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubm.h",    1, 0x007400a3, 0x0088005c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubm.h",    1, 0x007800a3, 0x0084005c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubm.h",    1, 0x007c00a3, 0x0080005c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubm.q",    1, 0x00700063, 0x008f009c, F(RRR1), 4, "DDdd",  "1254",
+		 TRICORE_V1_1, INDICES},
+  {"msubm.u",    1, 0x00400033, 0x00a000cc, F(RCR),  4, "DDdn",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"msubm.u",    1, 0x00680023, 0x009700dc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"msubms",     1, 0x00e00033, 0x000000cc, F(RCR),  4, "DDd9",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"msubms",     1, 0x00ea0023, 0x001500dc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"msubms.h",   1, 0x00f000a3, 0x000c005c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubms.h",   1, 0x00f400a3, 0x0008005c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubms.h",   1, 0x00f800a3, 0x0004005c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubms.h",   1, 0x00fc00a3, 0x0000005c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubms.u",   1, 0x00c00033, 0x002000cc, F(RCR),  4, "DDdn",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"msubms.u",   1, 0x00e80023, 0x001700dc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"msubr.h",    1, 0x00780063, 0x0084009c, F(RRR1), 5, "dDdd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"msubr.h",    1, 0x00780063, 0x0084009c, F(RRR1), 5, "dDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubr.h",    1, 0x003000a3, 0x00cc005c, F(RRR1), 5, "dddL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubr.h",    1, 0x003400a3, 0x00c8005c, F(RRR1), 5, "dddl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubr.h",    1, 0x003800a3, 0x00c4005c, F(RRR1), 5, "ddd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubr.h",    1, 0x003c00a3, 0x00c0005c, F(RRR1), 5, "ddd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubr.q",    1, 0x00180063, 0x00e4009c, F(RRR1), 5, "dddd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"msubr.q",    1, 0x00180063, 0x00e4009c, F(RRR1), 5, "ddGG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubr.q",    1, 0x001c0063, 0x00e0009c, F(RRR1), 5, "ddgg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubrs.h",   1, 0x00f80063, 0x0004009c, F(RRR1), 5, "dDdd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"msubrs.h",   1, 0x00f80063, 0x0004009c, F(RRR1), 5, "dDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubrs.h",   1, 0x00b000a3, 0x004c005c, F(RRR1), 5, "dddL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubrs.h",   1, 0x00b400a3, 0x0048005c, F(RRR1), 5, "dddl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubrs.h",   1, 0x00b800a3, 0x0044005c, F(RRR1), 5, "ddd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubrs.h",   1, 0x00bc00a3, 0x0040005c, F(RRR1), 5, "ddd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubrs.q",   1, 0x00980063, 0x0064009c, F(RRR1), 5, "dddd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"msubrs.q",   1, 0x00980063, 0x0064009c, F(RRR1), 5, "ddGG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubrs.q",   1, 0x009c0063, 0x0060009c, F(RRR1), 5, "ddgg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs",      1, 0x008a0023, 0x007500dc, F(RRR2), 4, "dddd",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"msubs",      1, 0x00a00033, 0x004000cc, F(RCR),  4, "ddd9",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"msubs",      1, 0x00e00033, 0x000000cc, F(RCR),  4, "DDd9",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs",      1, 0x00ea0023, 0x001500dc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.h",    1, 0x00e000a3, 0x001c005c, F(RRR1), 5, "DDdd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"msubs.h",    1, 0x00e000a3, 0x001c005c, F(RRR1), 5, "DDdL1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.h",    1, 0x00e400a3, 0x0018005c, F(RRR1), 5, "DDdl1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.h",    1, 0x00e800a3, 0x0014005c, F(RRR1), 5, "DDd-1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.h",    1, 0x00ec00a3, 0x0010005c, F(RRR1), 5, "DDd+1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.q",    1, 0x00900063, 0x006c009c, F(RRR1), 5, "dddd1", "12543",
+		 TRICORE_V1_1, INDICES},
+  {"msubs.q",    1, 0x00900063, 0x006c009c, F(RRR1), 5, "ddGG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.q",    1, 0x00800063, 0x007c009c, F(RRR1), 5, "dddG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.q",    1, 0x00840063, 0x0078009c, F(RRR1), 5, "dddg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.q",    1, 0x00880063, 0x0074009c, F(RRR1), 5, "dddd1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.q",    1, 0x00940063, 0x0068009c, F(RRR1), 5, "ddgg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.q",    1, 0x00e00063, 0x001c009c, F(RRR1), 5, "DDdG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.q",    1, 0x00e40063, 0x0018009c, F(RRR1), 5, "DDdg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.q",    1, 0x00ec0063, 0x0010009c, F(RRR1), 5, "DDdd1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.q",    1, 0x00f00063, 0x000c009c, F(RRR1), 5, "DDGG1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.q",    1, 0x00f40063, 0x0008009c, F(RRR1), 5, "DDgg1", "12543",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.u",    1, 0x00800033, 0x006000cc, F(RCR),  4, "dddn",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"msubs.u",    1, 0x00880023, 0x007700dc, F(RRR2), 4, "dddd",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"msubs.u",    1, 0x00c00033, 0x002000cc, F(RCR),  4, "DDdn",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"msubs.u",    1, 0x00e80023, 0x001700dc, F(RRR2), 4, "DDdd",  "1243",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mtcr",       1, 0x000000cd, 0xf0000032, F(RLC),  2, "Wd",    "23",
+		 TRICORE_GENERIC, INDICES},
+  {"mul",        0, 0x000000e2, 0xffff001d, F(SRR),  2, "dd",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"mul",        1, 0x00200053, 0x0fc000ac, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"mul",        1, 0x00a00073, 0x0f5f008c, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"mul",        1, 0x000a0073, 0x0ff5008c, F(RR2),  3, "ddd",   "132",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul",        1, 0x00600053, 0x0f8000ac, F(RC),   3, "Dd9",   "132",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul",        1, 0x006a0073, 0x0f95008c, F(RR2),  3, "Ddd",   "132",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.f",      1, 0x0041004b, 0x0fbe00b4, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_3_UP, INDICES},
+  {"mul.h",      1, 0x018000b3, 0x0e7c004c, F(RR),   4, "Ddd1",  "1432",
+		 TRICORE_V1_1, INDICES},
+  {"mul.h",      1, 0x006000b3, 0x0f9c004c, F(RR1),  4, "DdL1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.h",      1, 0x006400b3, 0x0f98004c, F(RR1),  4, "Ddl1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.h",      1, 0x006800b3, 0x0f94004c, F(RR1),  4, "Dd-1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.h",      1, 0x006c00b3, 0x0f90004c, F(RR1),  4, "Dd+1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.q",      1, 0x00400093, 0x0fbc006c, F(RR),   4, "ddd1",  "1432",
+		 TRICORE_V1_1, INDICES},
+  {"mul.q",      1, 0x00000093, 0x0ffc006c, F(RR1),  4, "ddG1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.q",      1, 0x00040093, 0x0ff8006c, F(RR1),  4, "ddg1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.q",      1, 0x00080093, 0x0ff4006c, F(RR1),  4, "ddd1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.q",      1, 0x00100093, 0x0fec006c, F(RR1),  4, "dGG1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.q",      1, 0x00140093, 0x0fe8006c, F(RR1),  4, "dgg1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.q",      1, 0x00600093, 0x0f9c006c, F(RR1),  4, "DdG1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.q",      1, 0x00640093, 0x0f98006c, F(RR1),  4, "Ddg1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.q",      1, 0x006c0093, 0x0f90006c, F(RR1),  4, "Ddd1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.u",      1, 0x00400053, 0x0fa000ac, F(RC),   3, "Ddn",   "132",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mul.u",      1, 0x00680073, 0x0f97008c, F(RR2),  3, "Ddd",   "132",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulm",       1, 0x00600053, 0x0f8000ac, F(RC),   3, "Dd9",   "132",
+		 TRICORE_V1_1, INDICES},
+  {"mulm",       1, 0x06a00073, 0x095f008c, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"mulm.h",     1, 0x007000b3, 0x0f8c004c, F(RR1),  4, "DdL1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulm.h",     1, 0x007400b3, 0x0f88004c, F(RR1),  4, "Ddl1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulm.h",     1, 0x007800b3, 0x0f84004c, F(RR1),  4, "Dd-1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulm.h",     1, 0x007c00b3, 0x0f80004c, F(RR1),  4, "Dd+1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulm.u",     1, 0x00400053, 0x0fa000ac, F(RC),   3, "Ddn",   "132",
+		 TRICORE_V1_1, INDICES},
+  {"mulm.u",     1, 0x06800073, 0x097f008c, F(RR),   3, "Ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"mulms.h",    1, 0x00f000b3, 0x0f0c004c, F(RR1),  4, "DdL1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulms.h",    1, 0x00f400b3, 0x0f08004c, F(RR1),  4, "Ddl1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulms.h",    1, 0x00f800b3, 0x0f04004c, F(RR1),  4, "Dd-1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulms.h",    1, 0x00fc00b3, 0x0f00004c, F(RR1),  4, "Dd+1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulr.h",     1, 0x00c000b3, 0x0f3c004c, F(RR),   4, "ddd1",  "1432",
+		 TRICORE_V1_1, INDICES},
+  {"mulr.h",     1, 0x003000b3, 0x0fcc004c, F(RR1),  4, "ddL1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulr.h",     1, 0x003400b3, 0x0fc8004c, F(RR1),  4, "ddl1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulr.h",     1, 0x003800b3, 0x0fc4004c, F(RR1),  4, "dd-1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulr.h",     1, 0x003c00b3, 0x0fc0004c, F(RR1),  4, "dd+1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulr.q",     1, 0x00600093, 0x0f9c006c, F(RR),   4, "ddd1",  "1432",
+		 TRICORE_V1_1, INDICES},
+  {"mulr.q",     1, 0x00180093, 0x0fe4006c, F(RR1),  4, "dGG1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"mulr.q",     1, 0x001c0093, 0x0fe0006c, F(RR1),  4, "dgg1",  "1432",
+		 TRICORE_V1_2_UP, INDICES},
+  {"muls",       1, 0x00a00053, 0x0f4000ac, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"muls",       1, 0x08a00073, 0x075f008c, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"muls",       1, 0x008a0073, 0x0f75008c, F(RR2),  3, "ddd",   "132",
+		 TRICORE_V1_2_UP, INDICES},
+  {"muls.u",     1, 0x00800053, 0x0f6000ac, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"muls.u",     1, 0x08800073, 0x077f008c, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"muls.u",     1, 0x00880073, 0x0f77008c, F(RR2),  3, "ddd",   "132",
+		 TRICORE_V1_2_UP, INDICES},
+  {"nand",       1, 0x0090000f, 0x0f6f00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"nand",       1, 0x0120008f, 0x0ec00070, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"nand.t",     1, 0x00000007, 0x006000f8, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"ne",         1, 0x0110000b, 0x0eef00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"ne",         1, 0x0220008b, 0x0dc00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"ne.a",       1, 0x04100001, 0x0bef00fe, F(RR),   3, "daa",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"nez.a",      1, 0x04900001, 0x0b6ff0fe, F(RR),   2, "da",    "14",
+		 TRICORE_GENERIC, INDICES},
+  {"nop",        0, 0x00000000, 0xffffffff, F(SR),   0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"nop",        1, 0x0000000d, 0xfffffff2, F(SYS),  0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"nor",        0, 0x00000036, 0xfffff0c9, F(SR),   1, "d",     "1",
+		 TRICORE_V1_1, INDICES},
+  {"nor",        0, 0x00000046, 0xfffff0b9, F(SR),   1, "d",     "1",
+		 TRICORE_V1_2_UP, INDICES},
+  {"nor",        1, 0x00b0000f, 0x0f4f00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"nor",        1, 0x0160008f, 0x0e800070, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"nor.t",      1, 0x00400087, 0x00200078, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"or",         0, 0x00000056, 0xffff00a9, F(SRR),  2, "dd",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"or",         0, 0x000000a6, 0xffff0059, F(SRR),  2, "dd",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"or",         0, 0x000000d6, 0xffff0029, F(SC),   2, "i8",    "01",
+		 TRICORE_V1_1, INDICES},
+  {"or",         0, 0x00000096, 0xffff0069, F(SC),   2, "i8",    "01",
+		 TRICORE_V1_2_UP, INDICES},
+  {"or",         1, 0x00a0000f, 0x0f5f00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"or",         1, 0x0140008f, 0x0ea00070, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"or.and.t",   1, 0x000000c7, 0x00600038, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"or.andn.t",  1, 0x006000c7, 0x00000038, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"or.eq",      1, 0x0270000b, 0x0d8f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"or.eq",      1, 0x04e0008b, 0x0b000074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"or.ge",      1, 0x02b0000b, 0x0d4f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"or.ge",      1, 0x0560008b, 0x0a800074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"or.ge.u",    1, 0x02c0000b, 0x0d3f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"or.ge.u",    1, 0x0580008b, 0x0a600074, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"or.lt",      1, 0x0290000b, 0x0d6f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"or.lt",      1, 0x0520008b, 0x0ac00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"or.lt.u",    1, 0x02a0000b, 0x0d5f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"or.lt.u",    1, 0x0540008b, 0x0aa00074, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"or.ne",      1, 0x0280000b, 0x0d7f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"or.ne",      1, 0x0500008b, 0x0ae00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"or.nor.t",   1, 0x004000c7, 0x00200038, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"or.or.t",    1, 0x002000c7, 0x00400038, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"or.t",       1, 0x00200087, 0x00400078, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"orn",        1, 0x00f0000f, 0x0f0f00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"orn",        1, 0x01e0008f, 0x0e000070, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"orn.t",      1, 0x00200007, 0x004000f8, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"pack",       1, 0x0000006b, 0x00fff094, F(RRR),  3, "dDd",   "125",
+		 TRICORE_GENERIC, INDICES},
+  {"parity",     1, 0x0080004b, 0x0f7ff0b4, F(RR),   2, "dd",    "14",
+		 TRICORE_V1_1, INDICES},
+  {"parity",     1, 0x0020004b, 0x0fdff0b4, F(RR),   2, "dd",    "14",
+		 TRICORE_V1_2_UP, INDICES},
+  {"q31tof",     1, 0x0151004b, 0x0eae00b4, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_3_UP, INDICES},
+  {"qseed.f",    1, 0x0191004b, 0x0e6ef0b4, F(RR),   2, "dd",    "14",
+		 TRICORE_V1_3_UP, INDICES},
+  {"restore",    1, 0x0380000d, 0xfc7ff0f2, F(SYS),  1, "d",     "1",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"ret",        0, 0x00009000, 0xffff6fff, F(SR),   0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"ret",        1, 0x0140000d, 0xfebffff2, F(SYS),  0, "",      "",
+		 TRICORE_V1_1, INDICES},
+  {"ret",        1, 0x0180000d, 0xfe7ffff2, F(SYS),  0, "",      "",
+		 TRICORE_V1_2_UP, INDICES},
+  {"rfe",        0, 0x00008000, 0xffff7fff, F(SR),   0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"rfe",        1, 0x0180000d, 0xfe7ffff2, F(SYS),  0, "",      "",
+		 TRICORE_V1_1, INDICES},
+  {"rfe",        1, 0x01c0000d, 0xfe3ffff2, F(SYS),  0, "",      "",
+		 TRICORE_V1_2_UP, INDICES},
+  {"rfm",        1, 0x0140000d, 0xfebffff2, F(SYS),  0, "",      "",
+		 TRICORE_V1_2_UP, INDICES},
+  {"rslcx",      1, 0x0240000d, 0xfdbffff2, F(SYS),  0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"rstv",       1, 0x0000002f, 0xffffffd0, F(SYS),  0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"rsub",       0, 0x000050d2, 0xffffa02d, F(SR),   1, "d",     "1",
+		 TRICORE_V1_1, INDICES},
+  {"rsub",       0, 0x00005032, 0xffffa0cd, F(SR),   1, "d",     "1",
+		 TRICORE_V1_2_UP, INDICES},
+  {"rsub",       1, 0x0100008b, 0x0ee00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"rsubs",      1, 0x0140008b, 0x0ea00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"rsubs.u",    1, 0x0160008b, 0x0e800074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"sat.b",      0, 0x000000d2, 0xfffff02d, F(SR),   1, "d",     "1",
+		 TRICORE_V1_1, INDICES},
+  {"sat.b",      0, 0x00000032, 0xfffff0cd, F(SR),   1, "d",     "1",
+		 TRICORE_V1_2_UP, INDICES},
+  {"sat.b",      1, 0x05e0000b, 0x0a1ff0f4, F(RR),   2, "dd",    "14",
+		 TRICORE_GENERIC, INDICES},
+  {"sat.bu",     0, 0x000010d2, 0xffffe02d, F(SR),   1, "d",     "1",
+		 TRICORE_V1_1, INDICES},
+  {"sat.bu",     0, 0x00001032, 0xffffe0cd, F(SR),   1, "d",     "1",
+		 TRICORE_V1_2_UP, INDICES},
+  {"sat.bu",     1, 0x05f0000b, 0x0a0ff0f4, F(RR),   2, "dd",    "14",
+		 TRICORE_GENERIC, INDICES},
+  {"sat.h",      0, 0x000020d2, 0xffffd02d, F(SR),   1, "d",     "1",
+		 TRICORE_V1_1, INDICES},
+  {"sat.h",      0, 0x00002032, 0xffffd0cd, F(SR),   1, "d",     "1",
+		 TRICORE_V1_2_UP, INDICES},
+  {"sat.h",      1, 0x07e0000b, 0x081ff0f4, F(RR),   2, "dd",    "14",
+		 TRICORE_GENERIC, INDICES},
+  {"sat.hu",     0, 0x000030d2, 0xffffc02d, F(SR),   1, "d",     "1",
+		 TRICORE_V1_1, INDICES},
+  {"sat.hu",     0, 0x00003032, 0xffffc0cd, F(SR),   1, "d",     "1",
+		 TRICORE_V1_2_UP, INDICES},
+  {"sat.hu",     1, 0x07f0000b, 0x080ff0f4, F(RR),   2, "dd",    "14",
+		 TRICORE_GENERIC, INDICES},
+  {"sel",        1, 0x0040002b, 0x00bf00d4, F(RRR),  4, "dddd",  "1254",
+		 TRICORE_GENERIC, INDICES},
+  {"sel",        1, 0x008000ab, 0x00600054, F(RCR),  4, "ddd9",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"sel.a",      1, 0x00400021, 0x00bf00de, F(RRR),  4, "adaa",  "1254",
+		 TRICORE_V1_1, INDICES},
+  {"sel.a",      1, 0x008000a1, 0x0060005e, F(RCR),  4, "ada9",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"seln",       1, 0x0050002b, 0x00af00d4, F(RRR),  4, "dddd",  "1254",
+		 TRICORE_GENERIC, INDICES},
+  {"seln",       1, 0x00a000ab, 0x00400054, F(RCR),  4, "ddd9",  "1243",
+		 TRICORE_GENERIC, INDICES},
+  {"seln.a",     1, 0x00500021, 0x00af00de, F(RRR),  4, "adaa",  "1254",
+		 TRICORE_V1_1, INDICES},
+  {"seln.a",     1, 0x00a000a1, 0x0040005e, F(RCR),  4, "ada9",  "1243",
+		 TRICORE_V1_1, INDICES},
+  {"sh",         0, 0x00000026, 0xffff00d9, F(SRC),  2, "d4",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"sh",         0, 0x00000006, 0xffff00f9, F(SRC),  2, "d4",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"sh",         1, 0x0000000f, 0x0fff00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"sh",         1, 0x0000008f, 0x0fe00070, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.and.t",   1, 0x00000027, 0x006000d8, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.andn.t",  1, 0x00600027, 0x000000d8, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.b",       1, 0x0200000f, 0x0dff00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"sh.b",       1, 0x0400008f, 0x0be00070, F(RC),   3, "dd9",   "132",
+		 TRICORE_V1_1, INDICES},
+  {"sh.eq",      1, 0x0370000b, 0x0c8f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.eq",      1, 0x06e0008b, 0x09000074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.ge",      1, 0x03b0000b, 0x0c4f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.ge",      1, 0x0760008b, 0x08800074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.ge.u",    1, 0x03c0000b, 0x0c3f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.ge.u",    1, 0x0780008b, 0x08600074, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.h",       1, 0x0400000f, 0x0bff00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.h",       1, 0x0800008f, 0x07e00070, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.lt",      1, 0x0390000b, 0x0c6f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.lt",      1, 0x0720008b, 0x08c00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.lt.u",    1, 0x03a0000b, 0x0c5f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.lt.u",    1, 0x0740008b, 0x08a00074, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.nand.t",  1, 0x000000a7, 0x00600058, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.ne",      1, 0x0380000b, 0x0c7f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.ne",      1, 0x0700008b, 0x08e00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.nor.t",   1, 0x00400027, 0x002000d8, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.or.t",    1, 0x00200027, 0x004000d8, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.orn.t",   1, 0x002000a7, 0x00400058, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.xnor.t",  1, 0x004000a7, 0x00200058, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"sh.xor.t",   1, 0x006000a7, 0x00000058, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"sha",        0, 0x000000a6, 0xffff0059, F(SRC),  2, "d4",    "21",
+		 TRICORE_V1_1, INDICES},
+  {"sha",        0, 0x00000086, 0xffff0079, F(SRC),  2, "d4",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"sha",        1, 0x0010000f, 0x0fef00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"sha",        1, 0x0020008f, 0x0fc00070, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"sha.b",      1, 0x0210000f, 0x0def00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"sha.b",      1, 0x0420008f, 0x0bc00070, F(RC),   3, "dd9",   "132",
+		 TRICORE_V1_1, INDICES},
+  {"sha.h",      1, 0x0410000f, 0x0bef00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"sha.h",      1, 0x0820008f, 0x07c00070, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"shas",       1, 0x0020000f, 0x0fdf00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"shas",       1, 0x0040008f, 0x0fa00070, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"st.a",       0, 0x000000f8, 0xffff0007, F(SC),   3, "&kI",   "010",
+  		 TRICORE_V1_2_UP, INDICES},
+  {"st.a",       0, 0x00000018, 0xffff00e7, F(SRO),  3, "@6I",   "120",
+		 TRICORE_V1_1, INDICES},
+  {"st.a",       0, 0x000000ec, 0xffff0013, F(SRO),  3, "@6I",   "120",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.a",       0, 0x0000002c, 0xffff00d3, F(SSRO), 3, "S6a",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"st.a",       0, 0x000000e8, 0xffff0017, F(SSRO), 3, "S6a",   "012",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.a",       0, 0x00000054, 0xffff00ab, F(SSR),  2, ">a",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"st.a",       0, 0x000000e4, 0xffff001b, F(SSR),  2, ">a",    "12",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.a",       0, 0x00000084, 0xffff007b, F(SSR),  2, "@a",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"st.a",       0, 0x000000f4, 0xffff000b, F(SSR),  2, "@a",    "12",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.a",       1, 0x000000b5, 0x0000004a, F(BOL),  3, "@wa",   "213",
+		 TRICORE_V1_6_UP, INDICES}, // TC1.6
+  {"st.a",       1, 0x01800089, 0x0e400076, F(BO),   3, ">0a",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.a",       1, 0x018000a9, 0xfe7f0056, F(BO),   2, "#a",    "23",
+		 TRICORE_GENERIC, INDICES},
+  {"st.a",       1, 0x05800089, 0x0a400076, F(BO),   3, "<0a",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.a",       1, 0x058000a9, 0x0a400056, F(BO),   3, "*0a",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.a",       1, 0x080000a5, 0x0400005a, F(ABS),  2, "ta",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"st.a",       1, 0x09800089, 0x06400076, F(BO),   3, "@0a",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.b",       0, 0x00000078, 0xffff0087, F(SSR),  2, "@d",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"st.b",       0, 0x00000034, 0xffff00cb, F(SSR),  2, "@d",    "12",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.b",       0, 0x0000008c, 0xffff0073, F(SSRO), 3, "Sfd",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"st.b",       0, 0x00000028, 0xffff00d7, F(SSRO), 3, "Sfd",   "012",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.b",       0, 0x000000a8, 0xffff0057, F(SRO),  3, "@fi",   "120",
+		 TRICORE_V1_1, INDICES},
+  {"st.b",       0, 0x0000002c, 0xffff00d3, F(SRO),  3, "@fi",   "120",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.b",       0, 0x000000e4, 0xffff001b, F(SSR),  2, ">d",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"st.b",       0, 0x00000024, 0xffff00db, F(SSR),  2, ">d",    "12",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.b",       1, 0x000000e9, 0x00000016, F(BOL),  3, "@wd",   "213",
+		 TRICORE_V1_6_UP, INDICES}, // TC1.6
+  {"st.b",       1, 0x00000025, 0x0c0000da, F(ABS),  2, "td",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"st.b",       1, 0x00000089, 0x0fc00076, F(BO),   3, ">0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.b",       1, 0x000000a9, 0xffff0056, F(BO),   2, "#d",    "23",
+		 TRICORE_GENERIC, INDICES},
+  {"st.b",       1, 0x04000089, 0x0bc00076, F(BO),   3, "<0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.b",       1, 0x040000a9, 0x0bc00056, F(BO),   3, "*0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.b",       1, 0x08000089, 0x07c00076, F(BO),   3, "@0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.d",       1, 0x01400089, 0x0e800076, F(BO),   3, ">0D",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.d",       1, 0x014000a9, 0xfebf0056, F(BO),   2, "#D",    "23",
+		 TRICORE_GENERIC, INDICES},
+  {"st.d",       1, 0x040000a5, 0x0800005a, F(ABS),  2, "tD",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"st.d",       1, 0x05400089, 0x0a800076, F(BO),   3, "<0D",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.d",       1, 0x054000a9, 0x0a800056, F(BO),   3, "*0D",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.d",       1, 0x09400089, 0x06800076, F(BO),   3, "@0D",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.da",      1, 0x01c00089, 0x0e000076, F(BO),   3, ">0A",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.da",      1, 0x01c000a9, 0xfe3f0056, F(BO),   2, "#A",    "23",
+		 TRICORE_GENERIC, INDICES},
+  {"st.da",      1, 0x05c00089, 0x0a000076, F(BO),   3, "<0A",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.da",      1, 0x05c000a9, 0x0a000056, F(BO),   3, "*0A",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.da",      1, 0x09c00089, 0x06000076, F(BO),   3, "@0A",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.da",      1, 0x0c0000a5, 0x0000005a, F(ABS),  2, "tA",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"st.h",       0, 0x00000014, 0xffff00eb, F(SSR),  2, ">d",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"st.h",       0, 0x000000a4, 0xffff005b, F(SSR),  2, ">d",    "12",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.h",       0, 0x0000004c, 0xffff00b3, F(SSRO), 3, "Svd",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"st.h",       0, 0x000000a8, 0xffff0057, F(SSRO), 3, "Svd",   "012",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.h",       0, 0x00000068, 0xffff0097, F(SRO),  3, "@vi",   "120",
+		 TRICORE_V1_1, INDICES},
+  {"st.h",       0, 0x000000ac, 0xffff0053, F(SRO),  3, "@vi",   "120",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.h",       0, 0x000000f8, 0xffff0007, F(SSR),  2, "@d",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"st.h",       0, 0x000000b4, 0xffff004b, F(SSR),  2, "@d",    "12",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.h",       1, 0x000000f9, 0x00000006, F(BOL),  3, "@wd",   "213",
+		 TRICORE_V1_6_UP, INDICES}, // TC1.6
+  {"st.h",       1, 0x00800089, 0x0f400076, F(BO),   3, ">0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.h",       1, 0x008000a9, 0xff7f0056, F(BO),   2, "#d",    "23",
+		 TRICORE_GENERIC, INDICES},
+  {"st.h",       1, 0x04800089, 0x0b400076, F(BO),   3, "<0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.h",       1, 0x048000a9, 0x0b400056, F(BO),   3, "*0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.h",       1, 0x08000025, 0x040000da, F(ABS),  2, "td",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"st.h",       1, 0x08800089, 0x07400076, F(BO),   3, "@0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.q",       1, 0x00000065, 0x0c00009a, F(ABS),  2, "td",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"st.q",       1, 0x02000089, 0x0dc00076, F(BO),   3, ">0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.q",       1, 0x020000a9, 0xfdff0056, F(BO),   2, "#d",    "23",
+		 TRICORE_GENERIC, INDICES},
+  {"st.q",       1, 0x06000089, 0x09c00076, F(BO),   3, "<0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.q",       1, 0x060000a9, 0x09c00056, F(BO),   3, "*0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.q",       1, 0x0a000089, 0x05c00076, F(BO),   3, "@0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.t",       1, 0x000000d5, 0x0c00002a, F(ABSB), 3, "t31",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"st.w",       0, 0x00000078, 0xffff0087, F(SC),   3, "&ki",   "010",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.w",       0, 0x00000004, 0xffff00fb, F(SSR),  2, "@d",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"st.w",       0, 0x00000074, 0xffff008b, F(SSR),  2, "@d",    "12",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.w",       0, 0x00000094, 0xffff006b, F(SSR),  2, ">d",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"st.w",       0, 0x00000064, 0xffff009b, F(SSR),  2, ">d",    "12",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.w",       0, 0x000000cc, 0xffff0033, F(SSRO), 3, "S6d",   "012",
+		 TRICORE_V1_1, INDICES},
+  {"st.w",       0, 0x00000068, 0xffff0097, F(SSRO), 3, "S6d",   "012",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.w",       0, 0x000000e8, 0xffff0017, F(SRO),  3, "@6i",   "120",
+		 TRICORE_V1_1, INDICES},
+  {"st.w",       0, 0x0000006c, 0xffff0093, F(SRO),  3, "@6i",   "120",
+		 TRICORE_V1_2_UP, INDICES},
+  {"st.w",       1, 0x00000059, 0x000000a6, F(BOL),  3, "@wd",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.w",       1, 0x000000a5, 0x0c00005a, F(ABS),  2, "td",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"st.w",       1, 0x01000089, 0x0ec00076, F(BO),   3, ">0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.w",       1, 0x010000a9, 0xfeff0056, F(BO),   2, "#d",    "23",
+		 TRICORE_GENERIC, INDICES},
+  {"st.w",       1, 0x05000089, 0x0ac00076, F(BO),   3, "<0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.w",       1, 0x050000a9, 0x0ac00056, F(BO),   3, "*0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"st.w",       1, 0x09000089, 0x06c00076, F(BO),   3, "@0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"stlcx",      1, 0x00000015, 0x0c000fea, F(ABS),  1, "t",     "1",
+		 TRICORE_GENERIC, INDICES},
+  {"stlcx",      1, 0x09800049, 0x06400fb6, F(BO),   2, "@0",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"stucx",      1, 0x04000015, 0x08000fea, F(ABS),  1, "t",     "1",
+		 TRICORE_GENERIC, INDICES},
+  {"stucx",      1, 0x09c00049, 0x06000fb6, F(BO),   2, "@0",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"sub",        0, 0x00000052, 0xffff00ad, F(SRR),  3, "did",   "201",
+		 TRICORE_V1_2_UP, INDICES},
+  {"sub",        0, 0x0000005a, 0xffff00a5, F(SRR),  3, "idd",   "021",
+		 TRICORE_GENERIC, INDICES},
+  {"sub",        0, 0x000000a2, 0xffff005d, F(SRR),  2, "dd",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"sub",        1, 0x0080000b, 0x0f7f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"sub.a",      0, 0x00000040, 0xffff00bf, F(SC),   2, "P8",    "01",
+		 TRICORE_V1_1, INDICES},
+  {"sub.a",      0, 0x00000020, 0xffff00df, F(SC),   2, "P8",    "01",
+		 TRICORE_V1_2_UP, INDICES},
+  {"sub.a",      1, 0x00200001, 0x0fdf00fe, F(RR),   3, "aaa",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"sub.b",      1, 0x0480000b, 0x0b7f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"sub.f",      1, 0x0031006b, 0x00cef094, F(RRR),  3, "ddd",   "125",
+		 TRICORE_V1_3_UP, INDICES},
+  {"sub.h",      1, 0x0680000b, 0x097f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"subc",       1, 0x00d0000b, 0x0f2f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"subs",       0, 0x00000062, 0xffff009d, F(SRR),  2, "dd",    "21",
+		 TRICORE_GENERIC, INDICES},
+  {"subs",       1, 0x00a0000b, 0x0f5f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"subs.b",     1, 0x04a0000b, 0x0b5f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"subs.bu",    1, 0x04b0000b, 0x0b4f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_V1_1, INDICES},
+  {"subs.h",     1, 0x06a0000b, 0x095f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"subs.hu",    1, 0x06b0000b, 0x094f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"subs.u",     1, 0x00b0000b, 0x0f4f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"subsc.a",    1, 0x06100001, 0x09ec00fe, F(RR),   4, "aad2",  "1432",
+		 TRICORE_V1_1, INDICES},
+  {"subx",       1, 0x00c0000b, 0x0f3f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"svlcx",      1, 0x0200000d, 0xfdfffff2, F(SYS),  0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"swap.a",     1, 0x00800049, 0x0f4000b6, F(BO),   3, ">0a",   "213",
+		 TRICORE_V1_1, INDICES},
+  {"swap.a",     1, 0x00800069, 0xff7f0096, F(BO),   2, "#a",    "23",
+		 TRICORE_V1_1, INDICES},
+  {"swap.a",     1, 0x04800049, 0x0b4000b6, F(BO),   3, "<0a",   "213",
+		 TRICORE_V1_1, INDICES},
+  {"swap.a",     1, 0x04800069, 0x0b400096, F(BO),   3, "*0a",   "213",
+		 TRICORE_V1_1, INDICES},
+  {"swap.a",     1, 0x080000e5, 0x0400001a, F(ABS),  2, "ta",    "12",
+		 TRICORE_V1_1, INDICES},
+  {"swap.a",     1, 0x08800049, 0x074000b6, F(BO),   3, "@0a",   "213",
+		 TRICORE_V1_1, INDICES},
+  {"swap.w",     1, 0x00000049, 0x0fc000b6, F(BO),   3, ">0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"swap.w",     1, 0x00000069, 0xffff0096, F(BO),   2, "#d",    "23",
+		 TRICORE_GENERIC, INDICES},
+  {"swap.w",     1, 0x000000e5, 0x0c00001a, F(ABS),  2, "td",    "12",
+		 TRICORE_GENERIC, INDICES},
+  {"swap.w",     1, 0x04000049, 0x0bc000b6, F(BO),   3, "<0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"swap.w",     1, 0x04000069, 0x0bc00096, F(BO),   3, "*0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"swap.w",     1, 0x08000049, 0x07c000b6, F(BO),   3, "@0d",   "213",
+		 TRICORE_GENERIC, INDICES},
+  {"swap.w",     1, 0x08000069, 0xf7ff0096, F(BO),   2, "?d",    "23",
+  		 TRICORE_V1_6_UP, INDICES},
+  {"swapmsk.w",    1, 0x00800049, 0x0f4000b6, F(BO),   3, ">0D",   "213",
+  		 TRICORE_V1_6_1_UP, INDICES},
+  {"swapmsk.w",    1, 0x00800069, 0xff7f0096, F(BO),   2, "#D",    "23",
+  		 TRICORE_V1_6_1_UP, INDICES},
+  {"swapmsk.w",    1, 0x04800049, 0x0b4000b6, F(BO),   3, "<0D",   "213",
+  		 TRICORE_V1_6_1_UP, INDICES},
+  {"swapmsk.w",    1, 0x04800069, 0x0b400096, F(BO),   3, "*0D",   "213",
+  		 TRICORE_V1_6_1_UP, INDICES},
+  {"swapmsk.w",    1, 0x08800049, 0x074000b6, F(BO),   3, "@0D",   "213",
+  		 TRICORE_V1_6_1_UP, INDICES},
+  {"swapmsk.w",    1, 0x08800069, 0xf77f0096, F(BO),   2, "?D",    "23",
+  		 TRICORE_V1_6_1_UP, INDICES},
+  {"syscall",    1, 0x008000ad, 0xff600f52, F(RC),   1, "n",     "2",
+		 TRICORE_GENERIC, INDICES},
+  {"tlbdemap",   1, 0x00000075, 0xfffff08a, F(RR),   1, "d",     "4",
+		 TRICORE_V1_3_UP, INDICES},
+  {"tlbflush.a", 1, 0x00400075, 0xffbfff8a, F(RR),   0, "",      "",
+		 TRICORE_V1_3_UP, INDICES},
+  {"tlbflush.b", 1, 0x00500075, 0xffafff8a, F(RR),   0, "",      "",
+		 TRICORE_V1_3_UP, INDICES},
+  {"tlbmap",     1, 0x04000075, 0xfbfff08a, F(RR),   1, "D",     "4",
+		 TRICORE_V1_3_UP, INDICES},
+  {"tlbprobe.a", 1, 0x00800075, 0xff7ff08a, F(RR),   1, "d",     "4",
+		 TRICORE_V1_3_UP, INDICES},
+  {"tlbprobe.i", 1, 0x00900075, 0xff6ff08a, F(RR),   1, "d",     "4",
+		 TRICORE_V1_3_UP, INDICES},
+  {"trapsv",     1, 0x0540000d, 0xfabffff2, F(SYS),  0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"trapv",      1, 0x0500000d, 0xfafffff2, F(SYS),  0, "",      "",
+		 TRICORE_GENERIC, INDICES},
+  {"unpack",     1, 0x0500004b, 0x0afff0b4, F(RR),   2, "Dd",    "14",
+		 TRICORE_V1_1, INDICES},
+  {"unpack",     1, 0x0080004b, 0x0f7ff0b4, F(RR),   2, "Dd",    "14",
+		 TRICORE_V1_2_UP, INDICES},
+  {"updfl",      1, 0x00c1004b, 0x0f3ef0b4, F(RR),   1, "d",     "5",
+		 TRICORE_V1_3_UP, INDICES},
+  {"utof",       1, 0x0161004b, 0x0e9ef0b4, F(RR),   2, "dd",    "14",
+		 TRICORE_V1_3_UP, INDICES},
+  {"wait",       1, 0x0580000d, 0xfa7ffff2, F(SYS),  0, "",      "",
+		 TRICORE_V1_6_1_UP, INDICES},
+  {"xnor",       1, 0x00d0000f, 0x0f2f00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"xnor",       1, 0x01a0008f, 0x0e400070, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"xnor.t",     1, 0x00400007, 0x002000f8, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+  {"xor",        0, 0x000000c6, 0xffff0039, F(SRR),  2, "dd",    "21",
+		 TRICORE_V1_2_UP, INDICES},
+  {"xor",        1, 0x00c0000f, 0x0f3f00f0, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"xor",        1, 0x0180008f, 0x0e600070, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"xor.eq",     1, 0x02f0000b, 0x0d0f00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"xor.eq",     1, 0x05e0008b, 0x0a000074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"xor.ge",     1, 0x0330000b, 0x0ccf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"xor.ge",     1, 0x0660008b, 0x09800074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"xor.ge.u",   1, 0x0340000b, 0x0cbf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"xor.ge.u",   1, 0x0680008b, 0x09600074, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"xor.lt",     1, 0x0310000b, 0x0cef00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"xor.lt",     1, 0x0620008b, 0x09c00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"xor.lt.u",   1, 0x0320000b, 0x0cdf00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"xor.lt.u",   1, 0x0640008b, 0x09a00074, F(RC),   3, "ddn",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"xor.ne",     1, 0x0300000b, 0x0cff00f4, F(RR),   3, "ddd",   "143",
+		 TRICORE_GENERIC, INDICES},
+  {"xor.ne",     1, 0x0600008b, 0x09e00074, F(RC),   3, "dd9",   "132",
+		 TRICORE_GENERIC, INDICES},
+  {"xor.t",      1, 0x00600007, 0x000000f8, F(BIT),  5, "dd5d5", "15342",
+		 TRICORE_GENERIC, INDICES},
+#undef INDICES
+};
+
+const int tricore_numopcodes =
+  sizeof tricore_opcodes / sizeof tricore_opcodes[0];
+
+/* Here are the opcodes for the PCP.  The assembler requires that all
+   instances of the same mnemonic must be consecutive.  If they aren't,
+   the assembler will bomb at runtime.  The disassembler shouldn't care,
+   though.  */
+
+struct pcp_opcode pcp_opcodes[] =
+{
+#define INDICES TRICORE_PCP, 0, 0
+  {"add",	0, 0x6000, 0x9e00, 3, 0, 3, "arr",   INDICES},
+  {"add",	0, 0x6000, 0x9e00, 3, 0, 3, "rra",   INDICES},
+  {"add.f",	0, 0x2000, 0xde04, 1, 0, 3, "rRf",   INDICES},
+  {"add.f",	0, 0x2000, 0xde04, 1, 0, 3, "rrf",   INDICES},
+  {"add.i",	0, 0x8000, 0x7e00, 4, 0, 2, "re",    INDICES},
+  {"add.pi",	0, 0x4000, 0xbe00, 2, 0, 2, "rE",    INDICES},
+  {"add.pi",	0, 0x4000, 0xbe00, 2, 0, 2, "re",    INDICES},
+  {"and",	0, 0x6a00, 0x9400, 3, 0, 3, "arr",   INDICES},
+  {"and",	0, 0x6a00, 0x9400, 3, 0, 3, "rra",   INDICES},
+  {"and.f",	0, 0x2a00, 0xd404, 1, 0, 3, "rRf",   INDICES},
+  {"and.f",	0, 0x2a00, 0xd404, 1, 0, 3, "rrf",   INDICES},
+  {"and.pi",	0, 0x4a00, 0xb400, 2, 0, 2, "rE",    INDICES},
+  {"and.pi",	0, 0x4a00, 0xb400, 2, 0, 2, "re",    INDICES},
+  {"bcopy",	0, 0x1800, 0xe013, 0, 1, 4, "dscn",  INDICES},
+  {"chkb",	0, 0x9c00, 0x6200, 4, 0, 3, "rel",   INDICES},
+  {"chkb",	0, 0x9c20, 0x6220, 4, 0, 3, "rek",   INDICES},
+  {"clr",	0, 0x9600, 0x6820, 4, 0, 2, "re",    INDICES},
+  {"clr.f",	0, 0xb000, 0x4c00, 5, 0, 3, "Ref",   INDICES},
+  {"clr.f",	0, 0xb000, 0x4c00, 5, 0, 3, "ref",   INDICES},
+  {"comp",	0, 0x6400, 0x9a00, 3, 0, 3, "arr",   INDICES},
+  {"comp",	0, 0x6400, 0x9a00, 3, 0, 3, "rra",   INDICES},
+  {"comp.f",	0, 0x2400, 0xda04, 1, 0, 3, "rRf",   INDICES},
+  {"comp.f",	0, 0x2400, 0xda04, 1, 0, 3, "rrf",   INDICES},
+  {"comp.i",	0, 0x8400, 0x7a00, 4, 0, 2, "re",    INDICES},
+  {"comp.pi",	0, 0x4400, 0xba00, 2, 0, 2, "rE",    INDICES},
+  {"comp.pi",	0, 0x4400, 0xba00, 2, 0, 2, "re",    INDICES},
+  {"copy",	0, 0x0800, 0xf000, 0, 1, 5, "dscnf", INDICES},
+  {"debug",	0, 0xfc00, 0x0030, 7, 1, 5, "bmopq", INDICES},
+  {"debug",	0, 0xfc00, 0x0030, 7, 1, 5, "amopq", INDICES},
+  {"dinit",	0, 0xc000, 0x3e07, 6, 0, 2, "rr",    INDICES},
+  {"dstep",	0, 0xc200, 0x3c07, 6, 0, 2, "rr",    INDICES},
+  {"exb",	0, 0x9c20, 0x6200, 4, 0, 2, "re",    INDICES},
+  {"exib",	0, 0x9c00, 0x6220, 4, 0, 2, "re",    INDICES},
+  {"exit",      0, 0x1000, 0xe870, 0, 1, 5, "ghijb", INDICES},
+  {"exit",      0, 0x1000, 0xe870, 0, 1, 5, "ghija", INDICES},
+  {"inb",	0, 0x7a00, 0x8400, 3, 0, 3, "arr",   INDICES},
+  {"inb",	0, 0x7a00, 0x8400, 3, 0, 3, "rra",   INDICES},
+  {"inb.i",	0, 0x9a00, 0x6420, 4, 0, 2, "re",    INDICES},
+  {"jc",	0, 0xe400, 0x1800, 7, 1, 2, "be",    INDICES},
+  {"jc",	0, 0xe400, 0x1800, 7, 1, 2, "ae",    INDICES},
+  {"jc.a",	1, 0xe800, 0x143f, 7, 1, 2, "be",    INDICES},
+  {"jc.a",	1, 0xe800, 0x143f, 7, 1, 2, "ae",    INDICES},
+  {"jc.i",	0, 0xf000, 0x0c07, 7, 1, 2, "bR",    INDICES},
+  {"jc.i",	0, 0xf000, 0x0c07, 7, 1, 2, "br",    INDICES},
+  {"jc.i",	0, 0xf000, 0x0c07, 7, 1, 2, "aR",    INDICES},
+  {"jc.i",	0, 0xf000, 0x0c07, 7, 1, 2, "ar",    INDICES},
+  {"jc.ia",	0, 0xf400, 0x0807, 7, 1, 2, "bR",    INDICES},
+  {"jc.ia",	0, 0xf400, 0x0807, 7, 1, 2, "br",    INDICES},
+  {"jc.ia",	0, 0xf400, 0x0807, 7, 1, 2, "aR",    INDICES},
+  {"jc.ia",	0, 0xf400, 0x0807, 7, 1, 2, "ar",    INDICES},
+  {"jl",	0, 0xe000, 0x1c00, 7, 0, 1, "e",     INDICES},
+  {"ld.f",	0, 0x3200, 0xcc04, 1, 0, 3, "rRf",   INDICES},
+  {"ld.f",	0, 0x3200, 0xcc04, 1, 0, 3, "rrf",   INDICES},
+  {"ld.i",	0, 0x9800, 0x6600, 4, 0, 2, "re",    INDICES},
+  {"ld.if",	0, 0xb400, 0x4800, 5, 0, 3, "Ref",   INDICES},
+  {"ld.if",	0, 0xb400, 0x4800, 5, 0, 3, "ref",   INDICES},
+  {"ld.p",	0, 0x7200, 0x8c00, 3, 0, 3, "arR",   INDICES},
+  {"ld.p",	0, 0x7200, 0x8c00, 3, 0, 3, "arr",   INDICES},
+  {"ld.p",	0, 0x7200, 0x8c00, 3, 0, 3, "rRa",   INDICES},
+  {"ld.p",	0, 0x7200, 0x8c00, 3, 0, 3, "rra",   INDICES},
+  {"ld.pi",	0, 0x5200, 0xac00, 2, 0, 2, "rE",    INDICES},
+  {"ld.pi",	0, 0x5200, 0xac00, 2, 0, 2, "re",    INDICES},
+  {"ldl.dptr",	1, 0x9200, 0x6c3f, 4, 0, 3, "ree",    INDICES},
+  {"ldl.il",	1, 0x9200, 0x6c3f, 4, 0, 2, "re",    INDICES},
+  {"ldl.iu",	1, 0x9000, 0x6e3f, 4, 0, 2, "re",    INDICES},
+  {"mclr.pi",	0, 0x4800, 0xb600, 2, 0, 2, "rE",    INDICES},
+  {"mclr.pi",	0, 0x4800, 0xb600, 2, 0, 2, "re",    INDICES},
+  {"minit",	0, 0xc400, 0x3a07, 6, 0, 2, "rr",    INDICES},
+  {"mov",	0, 0x7800, 0x8600, 3, 0, 3, "arr",   INDICES},
+  {"mov",	0, 0x7800, 0x8600, 3, 0, 3, "rra",   INDICES},
+  {"mset.pi",	0, 0x4c00, 0xb200, 2, 0, 2, "rE",    INDICES},
+  {"mset.pi",	0, 0x4c00, 0xb200, 2, 0, 2, "re",    INDICES},
+  {"mstep.l",	0, 0xc600, 0x3807, 6, 0, 2, "rr",    INDICES},
+  {"mstep.u",	0, 0xc800, 0x3607, 6, 0, 2, "rr",    INDICES},
+  {"mstep32",	0, 0xc600, 0x3807, 6, 0, 2, "rr",    INDICES},
+  {"mstep64",	0, 0xc800, 0x3607, 6, 0, 2, "rr",    INDICES},
+  {"neg",	0, 0x6600, 0x9800, 3, 0, 3, "arr",   INDICES},
+  {"neg",	0, 0x6600, 0x9800, 3, 0, 3, "rra",   INDICES},
+  {"nop",	0, 0x0000, 0xffff, 0, 0, 0, "",      INDICES},
+  {"not",	0, 0x6800, 0x9600, 3, 0, 3, "arr",   INDICES},
+  {"not",	0, 0x6800, 0x9600, 3, 0, 3, "rra",   INDICES},
+  {"or",	0, 0x6e00, 0x9000, 3, 0, 3, "arr",   INDICES},
+  {"or",	0, 0x6e00, 0x9000, 3, 0, 3, "rra",   INDICES},
+  {"or.f",	0, 0x2e00, 0xd004, 1, 0, 3, "rRf",   INDICES},
+  {"or.f",	0, 0x2e00, 0xd004, 1, 0, 3, "rrf",   INDICES},
+  {"or.pi",	0, 0x4e00, 0xb000, 2, 0, 2, "rE",    INDICES},
+  {"or.pi",	0, 0x4e00, 0xb000, 2, 0, 2, "re",    INDICES},
+  {"pri",	0, 0x7c00, 0x8200, 3, 0, 3, "arr",   INDICES},
+  {"pri",	0, 0x7c00, 0x8200, 3, 0, 3, "rra",   INDICES},
+  {"rl",	0, 0x8e00, 0x7020, 4, 0, 2, "re",    INDICES},
+  {"rr",	0, 0x8c00, 0x7220, 4, 0, 2, "re",    INDICES},
+  {"set",	0, 0x9400, 0x6a20, 4, 0, 2, "re",    INDICES},
+  {"set.f",	0, 0xac00, 0x5000, 5, 0, 3, "Ref",   INDICES},
+  {"set.f",	0, 0xac00, 0x5000, 5, 0, 3, "ref",   INDICES},
+  {"shl",	0, 0x8a00, 0x7420, 4, 0, 2, "re",    INDICES},
+  {"shr",	0, 0x8800, 0x7620, 4, 0, 2, "re",    INDICES},
+  {"st.f",	0, 0x3400, 0xca04, 1, 0, 3, "rRf",   INDICES},
+  {"st.f",	0, 0x3400, 0xca04, 1, 0, 3, "rrf",   INDICES},
+  {"st.if",	0, 0xb800, 0x4400, 5, 0, 3, "Ref",   INDICES},
+  {"st.if",	0, 0xb800, 0x4400, 5, 0, 3, "ref",   INDICES},
+  {"st.p",	0, 0x7400, 0x8a00, 3, 0, 3, "arR",   INDICES},
+  {"st.p",	0, 0x7400, 0x8a00, 3, 0, 3, "arr",   INDICES},
+  {"st.p",	0, 0x7400, 0x8a00, 3, 0, 3, "rRa",   INDICES},
+  {"st.p",	0, 0x7400, 0x8a00, 3, 0, 3, "rra",   INDICES},
+  {"st.pi",	0, 0x5400, 0xaa00, 2, 0, 2, "rE",    INDICES},
+  {"st.pi",	0, 0x5400, 0xaa00, 2, 0, 2, "re",    INDICES},
+  {"sub",	0, 0x6200, 0x9c00, 3, 0, 3, "arr",   INDICES},
+  {"sub",	0, 0x6200, 0x9c00, 3, 0, 3, "rra",   INDICES},
+  {"sub.f",	0, 0x2200, 0xdc04, 1, 0, 3, "rRf",   INDICES},
+  {"sub.f",	0, 0x2200, 0xdc04, 1, 0, 3, "rrf",   INDICES},
+  {"sub.i",	0, 0x8200, 0x7c00, 4, 0, 2, "re",    INDICES},
+  {"sub.pi",	0, 0x4200, 0xbc00, 2, 0, 2, "rE",    INDICES},
+  {"sub.pi",	0, 0x4200, 0xbc00, 2, 0, 2, "re",    INDICES},
+  {"xch.f",	0, 0x3600, 0xc804, 1, 0, 3, "rRf",   INDICES},
+  {"xch.f",	0, 0x3600, 0xc804, 1, 0, 3, "rrf",   INDICES},
+  {"xch.pi",	0, 0x5600, 0xa800, 2, 0, 2, "rE",    INDICES},
+  {"xch.pi",	0, 0x5600, 0xa800, 2, 0, 2, "re",    INDICES},
+  {"xor",	0, 0x7000, 0x8e00, 3, 0, 3, "arr",   INDICES},
+  {"xor",	0, 0x7000, 0x8e00, 3, 0, 3, "rra",   INDICES},
+  {"xor.f",	0, 0x3000, 0xce04, 1, 0, 3, "rRf",   INDICES},
+  {"xor.f",	0, 0x3000, 0xce04, 1, 0, 3, "rrf",   INDICES},
+  {"xor.pi",	0, 0x5000, 0xae00, 2, 0, 2, "rE",    INDICES},
+  {"xor.pi",	0, 0x5000, 0xae00, 2, 0, 2, "re",    INDICES}
+#undef INDICES
+};
+
+const int pcp_numopcodes = sizeof pcp_opcodes / sizeof pcp_opcodes[0];
+
+/* End of tricore-opc.c.  */
diff --git a/readline/readline/support/config.sub b/readline/readline/support/config.sub
index 7384e9198b4..b5e58d1212d 100755
--- a/readline/readline/support/config.sub
+++ b/readline/readline/support/config.sub
@@ -997,6 +997,10 @@ case $cpu-$vendor in
 	orion-unknown)
 		vendor=highlevel
 		;;
+	tricore-unknown)
+		vendor=infineon
+		;;
+
 	xps-unknown | xps100-unknown)
 		cpu=xps100
 		vendor=honeywell
@@ -1248,6 +1252,7 @@ case $cpu-$vendor in
 			| tahoe \
 			| thumbv7* \
 			| tic30 | tic4x | tic54x | tic55x | tic6x | tic80 \
+			| tricore \
 			| tron \
 			| ubicom32 \
 			| v70 | v850 | v850e | v850e1 | v850es | v850e2 | v850e2v3 \
-- 
2.34.1

